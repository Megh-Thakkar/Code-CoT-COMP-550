{
    "0": "function find_minimum_cost_path(cost_matrix, m, n):\n    # Create a 2D array to store the minimum cost to reach each cell\n    create a 2D array named \"min_cost\" with dimensions (m+1, n+1)\n\n    # Initialize the first cell of the min_cost array to the cost of the first cell in the cost_matrix\n    min_cost[0][0] = cost_matrix[0][0]\n\n    # Initialize the first row of the min_cost array to the cumulative sum of the first row in the cost_matrix\n    for each column in range 1 to n:\n        min_cost[0][column] = min_cost[0][column-1] + cost_matrix[0][column]\n\n    # Initialize the first column of the min_cost array to the cumulative sum of the first column in the cost_matrix\n    for each row in range 1 to m:\n        min_cost[row][0] = min_cost[row-1][0] + cost_matrix[row][0]\n\n    # Fill the rest of the min_cost array\n    for each row in range 1 to m:\n        for each column in range 1 to n:\n            min_cost[row][column] = cost_matrix[row][column] + min(min_cost[row-1][column], min_cost[row][column-1])\n\n    # Return the minimum cost to reach the bottom-right cell\n    return min_cost[m][n]",
    "1": "function find_similar_elements(list1, list2):\n    # Create an empty list to store the similar elements\n    create an empty list named \"similar_elements\"\n\n    # Loop through each element in the first list\n    for each element in list1:\n        # Check if the element is in the second list\n        if element is in list2:\n            # If it is, add it to the list of similar elements\n            add element to \"similar_elements\"\n\n    # Return the list of similar elements\n    return \"similar_elements\"",
    "2": "function identify_non_prime_numbers(list_of_numbers):\n    # Create an empty list to store non-prime numbers\n    create an empty list named \"non_prime_numbers\"\n\n    # Loop through each number in the list\n    for each number in list_of_numbers:\n        # Check if the number is less than 2 (the smallest prime number)\n        if number is less than 2:\n            # If it is, add it to the list of non-prime numbers\n            add number to \"non_prime_numbers\"\n        else:\n            # If it's not, check if it's divisible by any number up to its square root\n            for each number up to the square root of number:\n                if number is divisible by the current number:\n                    # If it is, add it to the list of non-prime numbers\n                    add number to \"non_prime_numbers\"\n                    break\n\n    # Return the list of non-prime numbers\n    return non_prime_numbers",
    "3": "function find_largest_integers(list_of_numbers, k):\n    # Create an empty heap queue\n    create an empty heap queue named \"heap\"\n\n    # Loop through each number in the list\n    for each number in list_of_numbers:\n        # If the heap is not full or the number is larger than the smallest number in the heap\n        if heap is not full or number is larger than the smallest number in the heap:\n            # If the heap is full, remove the smallest number from the heap\n            if heap is full:\n                remove the smallest number from the heap\n            # Add the number to the heap\n            add number to the heap\n\n    # Return the heap as the list of largest integers\n    return heap as the list of largest integers",
    "4": "function find_domino_ways(n):\n    # If the board is empty, there are no ways to fill it\n    if n is 0:\n        return 1\n\n    # If the board is 1x2, there is only one way to fill it with 1 domino\n    if n is 1:\n        return 1\n\n    # If the board is 2x2, there are two ways to fill it with 1 domino\n    if n is 2:\n        return 2\n\n    # If the board is 3x2, there are three ways to fill it with 1 domino\n    if n is 3:\n        return 3\n\n    # If the board is 3xn, we can either place a domino vertically or horizontally\n    # So, the number of ways to fill it is the sum of the number of ways to fill it for 3x(n-1) and 3x(n-2)\n    return find_domino_ways(n-1) + find_domino_ways(n-2)",
    "5": "function check_bit_difference(num1, num2):\n    # Initialize a counter to keep track of the number of differences\n    initialize a counter to 0\n\n    # Loop through each bit in the numbers\n    for each bit in num1 and num2:\n        # If the bits are different, increment the counter\n        if bit in num1 is different from bit in num2:\n            increment the counter\n\n        # If the counter is more than 1, return False\n        if counter is more than 1:\n            return False\n\n    # If the counter is exactly 1, return True\n    if counter is exactly 1:\n        return True\n\n    # If the counter is 0, return False\n    return False",
    "6": "function find_words_at_least_4_characters_long(input_string):\n    # Import the regular expression module\n    import regex\n\n    # Use the findall function to find all words that are at least 4 characters long\n    words = regex.findall(r'\\b\\w{4,}\\b', input_string)\n\n    # Return the list of words\n    return words",
    "7": "function find_squares_of_elements(list):\n    # Create an empty list to store the squares\n    create an empty list named \"squares\"\n\n    # Use the map function to apply a lambda function to each element in the list\n    # The lambda function squares the number\n    squares = map(lambda x: x**2, list)\n\n    # Convert the map object to a list and return it\n    return list(squares)",
    "8": "function find_minimum_rotations(input_string):\n    # Create a copy of the input string and append it to itself\n    create a new string named \"double_string\" by concatenating input_string and input_string\n\n    # Find the length of the input string\n    find the length of input_string and store it in a variable named \"length\"\n\n    # Loop through each possible rotation\n    for each rotation from 1 to length:\n        # Create a substring of the input string that is the rotation\n        create a substring of input_string from index rotation to index rotation + length\n\n        # Check if this substring is in the double_string\n        if the substring is in double_string:\n            # If it is, this is the minimum rotation, so return it\n            return rotation\n\n    # If we've checked all rotations and found no matches, return a signal (like None or a message)\n    return None",
    "9": "function get_n_smallest_items(dataset, n):\n    # Check if n is less than or equal to 0\n    if n <= 0:\n        # If so, return an empty list\n        return []\n\n    # Sort the dataset in ascending order\n    sort dataset in ascending order\n\n    # Return the first n items from the sorted dataset\n    return the first n items from dataset",
    "10": "function remove_first_and_last_occurrence(input_string, character):\n    # Find the first occurrence of the character in the string\n    find the first occurrence of character in input_string\n    if the character is found:\n        # Remove the first occurrence of the character from the string\n        remove the first occurrence of character from input_string\n\n    # Find the last occurrence of the character in the string\n    find the last occurrence of character in input_string\n    if the character is found:\n        # Remove the last occurrence of the character from the string\n        remove the last occurrence of character from input_string\n\n    # Return the modified string\n    return the modified string",
    "11": "function sort_matrix_by_row_sum(matrix):\n    # Create an empty list to store the sums of the rows\n    create an empty list named \"row_sums\"\n\n    # Loop through each row in the matrix\n    for each row in matrix:\n        # Calculate the sum of the row\n        calculate the sum of the row and store it in a variable named \"row_sum\"\n\n        # Add the row sum to the list of row sums\n        add row_sum to \"row_sums\"\n\n    # Sort the matrix by the row sums\n    sort the matrix based on the \"row_sums\"\n\n    # Return the sorted matrix\n    return the sorted matrix",
    "12": "function count_most_common_words(dictionary):\n    # Create an empty dictionary to keep track of word counts\n    create an empty dictionary named \"word_counts\"\n\n    # Loop through each word in the dictionary\n    for each word in dictionary:\n        # If the word is already in our word_counts dictionary, increment its count\n        if word is already in \"word_counts\":\n            increment the count for word in \"word_counts\"\n        else:\n            # If the word is not in our word_counts dictionary, add it with a count of 1\n            add word to \"word_counts\" with a count of 1\n\n    # Find the maximum count in the word_counts dictionary\n    find the maximum count in \"word_counts\"\n\n    # Return the word(s) with the maximum count\n    return the word(s) with the maximum count in \"word_counts\"",
    "13": "function calculate_volume_of_triangular_prism(base, height, length):\n    # Calculate the area of the base of the triangular prism\n    area_of_base = (1/2) * base * height\n\n    # Calculate the volume of the triangular prism\n    volume = area_of_base * length\n\n    # Return the volume of the triangular prism\n    return volume",
    "14": "function split_string_at_lowercase(input_string):\n    # Create an empty list to store the split strings\n    create an empty list named \"split_strings\"\n\n    # Create a variable to store the current split string\n    create a variable named \"current_string\" and set it to an empty string\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is lowercase\n        if character is a lowercase letter:\n            # If it is, add the current string to the list and start a new one\n            add current_string to split_strings\n            set current_string to an empty string\n        else:\n            # If it's not lowercase, add the character to the current string\n            add character to current_string\n\n    # Add the final current string to the list\n    add current_string to split_strings\n\n    # Return the list of split strings\n    return split_strings",
    "15": "function find_sequences(input_string):\n    # Create an empty list to store the sequences\n    create an empty list named \"sequences\"\n\n    # Split the input string into words\n    split input_string into words at spaces\n\n    # Loop through each word in the list of words\n    for each word in words:\n        # Check if the word is a sequence of lowercase letters joined with an underscore\n        if word is a sequence of lowercase letters joined with an underscore:\n            # If it is, add it to the list of sequences\n            add word to \"sequences\"\n\n    # Return the list of sequences\n    return \"sequences\"",
    "16": "function find_square_perimeter(side_length):\n    # Calculate the perimeter of the square\n    perimeter = 4 * side_length\n\n    # Return the calculated perimeter\n    return perimeter",
    "17": "function remove_characters(string1, string2):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the first string\n    for each character in string1:\n        # Check if the character is not in the second string\n        if character is not in string2:\n            # If it's not in the second string, add it to the result\n            add character to \"result\"\n\n    # Return the result\n    return \"result\"",
    "18": "function contains_duplicate(array):\n    # Create an empty set to keep track of elements we've seen\n    create an empty set named \"seen_elements\"\n\n    # Loop through each element in the array\n    for each element in array:\n        # Check if we've come across this element before\n        if element is already in \"seen_elements\":\n            # If we have, this is a duplicate, so return True\n            return True\n        else:\n            # If it's a new element, add it to our set to remember it\n            add element to \"seen_elements\"\n\n    # If we've checked all elements and found no duplicates, return False\n    return False",
    "19": "function is_woodball(number):\n    # Check if the number is divisible by 3 and 5\n    if number is divisible by 3 and number is divisible by 5:\n        # If it is, return True\n        return True\n    else:\n        # If it's not, return False\n        return False",
    "20": "function find_multiples(n, m):\n    # Create an empty list to store the multiples\n    create an empty list named \"multiples\"\n\n    # Loop through numbers from 1 to m\n    for each number from 1 to m:\n        # Calculate the multiple of n and the current number\n        calculate the product of n and number and store it in a variable named \"multiple\"\n\n        # Add the multiple to the list of multiples\n        add multiple to \"multiples\"\n\n    # Return the list of multiples\n    return \"multiples\"",
    "21": "function find_first_duplicate(input_array):\n    # Create an empty collection to keep track of elements we've seen\n    create an empty collection named \"seen_elements\"\n\n    # Loop through each element in the input array\n    for each element in input_array:\n        # Check if we've come across this element before\n        if element is already in \"seen_elements\":\n            # If we have, this is the first duplicate element, so return it\n            return element\n        else:\n            # If it's a new element, add it to our collection to remember it\n            add element to \"seen_elements\"\n\n    # If we've checked all elements and found no duplicates, return a signal (like None or a message)\n    return None",
    "22": "function find_max_sum_in_list_of_lists(list_of_lists):\n    # Initialize max_sum to be the sum of the first list\n    max_sum = sum of the first list in list_of_lists\n\n    # Loop through each list in list_of_lists\n    for each list in list_of_lists:\n        # Calculate the sum of the current list\n        current_sum = sum of the current list\n\n        # If the current sum is greater than max_sum, update max_sum\n        if current_sum > max_sum:\n            max_sum = current_sum\n\n    # Return the maximum sum\n    return max_sum",
    "23": "function binary_to_decimal(binary_number):\n    # Initialize the decimal number to 0\n    initialize decimal_number to 0\n\n    # Initialize the power of 2 to 0\n    initialize power_of_2 to 0\n\n    # Loop through each digit in the binary number from right to left\n    for each digit in binary_number from right to left:\n        # If the digit is 1, add 2 to the power of 2 to the decimal number\n        if digit is 1:\n            add 2 to the power of 2 to decimal_number\n\n        # Increment the power of 2\n        increment power_of_2 by 1\n\n    # Return the decimal number\n    return decimal_number",
    "24": "function find_product_of_non_repeated_elements(input_array):\n    # Create an empty dictionary to keep track of elements and their counts\n    create an empty dictionary named \"element_counts\"\n\n    # Loop through each element in the input array\n    for each element in input_array:\n        # If the element is already in the dictionary, increment its count\n        if element is already in \"element_counts\":\n            increment the count of element in \"element_counts\"\n        else:\n            # If it's a new element, add it to the dictionary with a count of 1\n            add element to \"element_counts\" with a count of 1\n\n    # Create a variable to keep track of the product of non-repeated elements\n    create a variable named \"product\" and set it to 1\n\n    # Loop through each element in the input array\n    for each element in input_array:\n        # If the count of the element is 1, multiply the product by the element\n        if the count of element in \"element_counts\" is 1:\n            multiply the product by element\n\n    # Return the product\n    return product",
    "25": "function check_tuple_list(tuple_list, k):\n    # Create an empty collection to keep track of elements we've seen\n    create an empty collection named \"seen_elements\"\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Loop through each element in the tuple\n        for each element in tuple:\n            # Check if we've come across this element before\n            if element is already in \"seen_elements\":\n                # If we have, this is the first repeated element, so return it\n                return element\n            else:\n                # If it's a new element, add it to our collection to remember it\n                add element to \"seen_elements\"\n\n    # If we've checked all elements and found no repeats, return a signal (like None or a message)\n    return None\n\n    # Check if the size of the seen_elements is equal to k\n    if the size of \"seen_elements\" is equal to k:\n        # If it is, return True\n        return True\n    else:\n        # If it's not, return False\n        return False",
    "26": "function remove_digits_from_list(input_list):\n    # Create an empty list to store the result\n    create an empty list named \"result\"\n\n    # Loop through each string in the input list\n    for each string in input_list:\n        # Create an empty string to store the string without digits\n        create an empty string named \"no_digits_string\"\n\n        # Loop through each character in the string\n        for each character in string:\n            # Check if the character is not a digit\n            if character is not a digit:\n                # If it's not a digit, add it to the \"no_digits_string\"\n                add character to \"no_digits_string\"\n\n        # Add the \"no_digits_string\" to the result list\n        add \"no_digits_string\" to \"result\"\n\n    # Return the result list\n    return \"result\"",
    "27": "function binomial_coefficient(n, k):\n    # If k is greater than n, return 0\n    if k > n:\n        return 0\n\n    # If k is 0 or n is k, return 1\n    if k is 0 or k is n:\n        return 1\n\n    # Initialize result\n    let result be 1\n\n    # Since C(n, k) = C(n, n-k)\n    if k > n-k:\n        k = n-k\n\n    # Calculate value of [n*(n-1)*---*(n-k+1)] / [k*(k-1)*---*1]\n    for i from 0 to k-1:\n        result = result * (n - i)\n        result = result / (i + 1)\n\n    return result",
    "28": "function find_odd_occurrence(input_list):\n    # Create an empty dictionary to keep track of the count of each element\n    create an empty dictionary named \"element_count\"\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # Check if we've come across this element before\n        if element is already in \"element_count\":\n            # If we have, increment its count\n            increment the count of element in \"element_count\"\n        else:\n            # If it's a new element, add it to our dictionary with a count of 1\n            add element to \"element_count\" with a count of 1\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # Check if the count of this element is odd\n        if the count of element in \"element_count\" is odd:\n            # If it is, this is the element we're looking for, so return it\n            return element\n\n    # If we've checked all elements and found no elements with odd counts, return a signal (like None or a message)\n    return None",
    "29": "function count_substrings(input_string):\n    # Initialize a counter to keep track of the number of substrings\n    initialize a variable named \"count\" to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Find all substrings starting and ending with the current character\n        find all substrings in input_string that start and end with the current character\n\n        # Increment the counter for each such substring\n        for each substring found:\n            increment \"count\" by 1\n\n    # Return the final count\n    return count",
    "30": "function find_top_k_frequent_integers(list_of_lists, k):\n    # Create an empty dictionary to keep track of the frequency of each integer\n    create an empty dictionary named \"frequency_dict\"\n\n    # Loop through each list in the list of lists\n    for each list in list_of_lists:\n        # Loop through each integer in the list\n        for each integer in list:\n            # If the integer is already in the dictionary, increment its count\n            if integer is already in \"frequency_dict\":\n                increment the count of integer in \"frequency_dict\"\n            else:\n                # If the integer is not in the dictionary, add it with a count of 1\n                add integer to \"frequency_dict\" with a count of 1\n\n    # Create a heap queue to keep track of the top k frequent integers\n    create a heap queue named \"heap_queue\"\n\n    # Loop through each item in the frequency dictionary\n    for each item in \"frequency_dict\":\n        # If the heap queue is not full, add the item to the heap queue\n        if the heap queue is not full:\n            add item to the heap queue\n        else:\n            # If the heap queue is full, check if the item's count is greater than the smallest count in the heap queue\n            if the count of item is greater than the count of the smallest item in the heap queue:\n                # If it is, remove the smallest item from the heap queue and add the item\n                remove the smallest item from the heap queue\n                add item to the heap queue\n\n    # Return the heap queue as the top k frequent integers\n    return the heap queue as the top k frequent integers",
    "31": "function find_largest_prime_factor(number):\n    # Create a variable to store the largest prime factor\n    create a variable named \"largest_prime\" and set it to 2\n\n    # While the number is divisible by 2, divide it by 2\n    while number is divisible by 2:\n        number = number divided by 2\n\n    # If the number is now 1, return 2 as the largest prime factor\n    if number is 1:\n        return 2\n\n    # Start checking for prime factors from 3 onwards\n    for each number from 3 to the square root of the original number:\n        # While the number is divisible by the current number, divide it by the current number\n        while number is divisible by the current number:\n            number = number divided by the current number\n            # If the current number is greater than the largest prime factor found so far, update the largest prime factor\n            if the current number is greater than largest_prime:\n                largest_prime = the current number\n\n    # If the number is still greater than 2, it must be a prime number greater than 2\n    if number is greater than 2:\n        largest_prime = number\n\n    # Return the largest prime factor\n    return largest_prime",
    "32": "function convert_decimal_to_binary(decimal_number):\n    # Create an empty string to store the binary representation\n    create an empty string named \"binary_representation\"\n\n    # While the decimal number is greater than 0\n    while decimal_number is greater than 0:\n        # Get the remainder of the decimal number divided by 2\n        remainder = decimal_number modulo 2\n\n        # Add the remainder to the front of the binary representation\n        add remainder to the front of \"binary_representation\"\n\n        # Divide the decimal number by 2 and round down\n        decimal_number = decimal_number divided by 2\n\n    # Return the binary representation\n    return binary_representation",
    "33": "function find_missing_number(sorted_array):\n    # Initialize the start and end pointers\n    set start to 0\n    set end to length of sorted_array - 1\n\n    # While the start pointer is less than the end pointer\n    while start <= end:\n        # Find the middle index\n        set mid to (start + end) / 2\n\n        # If the difference between the current index and the previous index is not 1,\n        # then the missing number is between the current index and the previous index\n        if sorted_array[mid] - sorted_array[mid - 1] != 1:\n            return sorted_array[mid] - 1\n\n        # If the difference between the next index and the current index is not 1,\n        # then the missing number is between the current index and the next index\n        if sorted_array[mid + 1] - sorted_array[mid] != 1:\n            return sorted_array[mid] + 1\n\n        # If the difference between the current index and the previous index is 1,\n        # then the missing number is in the right half of the array\n        if sorted_array[mid] - sorted_array[start] == mid - start:\n            start = mid + 1\n        # If the difference between the next index and the current index is 1,\n        # then the missing number is in the left half of the array\n        else:\n            end = mid - 1\n\n    # If no missing number is found, return a signal (like None or a message)\n    return None",
    "34": "function find_nth_rectangular_number(n):\n    # Check if n is a positive integer\n    if n is not a positive integer:\n        # If not, return an error message\n        return \"Error: n must be a positive integer\"\n\n    # Calculate the n-th rectangular number\n    rectangular_number = n * (n + 1) / 2\n\n    # Return the n-th rectangular number\n    return rectangular_number",
    "35": "function find_nth_digit_in_fraction(num1, num2, n):\n    # Calculate the fraction of the two numbers\n    fraction = num1 / num2\n\n    # Convert the fraction to a string\n    fraction_string = convert fraction to string\n\n    # Check if the nth digit exists in the fraction\n    if n is less than or equal to the length of fraction_string:\n        # If it does, return the nth digit\n        return the nth digit in fraction_string\n    else:\n        # If it doesn't, return a signal (like None or a message)\n        return None",
    "36": "function sort_mixed_list(input_list):\n    # Create an empty list to store the integers\n    create an empty list named \"integers\"\n\n    # Create an empty list to store the strings\n    create an empty list named \"strings\"\n\n    # Loop through each item in the input list\n    for each item in input_list:\n        # Check if the item is an integer\n        if item is an integer:\n            # If it is, add it to the list of integers\n            add item to \"integers\"\n        else:\n            # If it's not an integer, it must be a string, so add it to the list of strings\n            add item to \"strings\"\n\n    # Sort the list of integers in ascending order\n    sort \"integers\" in ascending order\n\n    # Sort the list of strings in alphabetical order\n    sort \"strings\" in alphabetical order\n\n    # Combine the sorted lists of integers and strings into one list\n    combine \"integers\" and \"strings\" into one list\n\n    # Return the combined list\n    return the combined list",
    "37": "function find_division_of_first_even_and_odd(input_list):\n    # Create two variables to keep track of the first even and odd numbers we've seen\n    create a variable named \"first_even\" and set it to None\n    create a variable named \"first_odd\" and set it to None\n\n    # Loop through each number in the input list\n    for each number in input_list:\n        # Check if this number is even\n        if number is even:\n            # If it is, and we haven't seen an even number yet, set \"first_even\" to this number\n            if first_even is None:\n                set first_even to number\n        else:\n            # If it's not even, and we haven't seen an odd number yet, set \"first_odd\" to this number\n            if first_odd is None:\n                set first_odd to number\n\n        # If we've found both an even and an odd number, we can stop looking\n        if first_even is not None and first_odd is not None:\n            break\n\n    # If we've found both an even and an odd number, return their division\n    if first_even is not None and first_odd is not None:\n        return first_even / first_odd\n    else:\n        # If we haven't found both an even and an odd number, return a signal (like None or a message)\n        return None",
    "38": "function can_rearrange_adjacent_different(input_string):\n    # Create a frequency map of the characters in the string\n    create a dictionary named \"frequency_map\"\n    for each character in input_string:\n        if character is already in \"frequency_map\":\n            increment the count of character in \"frequency_map\"\n        else:\n            add character to \"frequency_map\" with a count of 1\n\n    # Sort the frequency map by the count of each character\n    sort \"frequency_map\" by the count of each character\n\n    # Check if the most frequent character's count is more than half the length of the string\n    if the count of the most frequent character in \"frequency_map\" is more than half the length of the string:\n        return False\n    else:\n        return True",
    "39": "function find_frequency(list_of_lists):\n    # Import the collections module\n    import collections\n\n    # Create an empty dictionary to keep track of frequencies\n    create an empty dictionary named \"frequency_dict\"\n\n    # Loop through each list in the list of lists\n    for each list in list_of_lists:\n        # Loop through each element in the list\n        for each element in list:\n            # If the element is already in the dictionary, increment its count\n            if element is already in \"frequency_dict\":\n                increment the count of element in \"frequency_dict\" by 1\n            else:\n                # If it's a new element, add it to the dictionary with a count of 1\n                add element to \"frequency_dict\" with a count of 1\n\n    # Return the dictionary of frequencies\n    return \"frequency_dict\"",
    "40": "function filter_even_numbers(list_of_numbers):\n    # Use the filter function to apply a lambda function to each element in the list\n    # The lambda function checks if a number is even\n    # If it is, it returns True, otherwise it returns False\n    # The filter function then creates a new list of only the elements for which the lambda function returned True\n    return filter(lambda x: x % 2 == 0, list_of_numbers)",
    "41": "function find_sum_of_repeated_elements(input_array):\n    # Create an empty collection to keep track of elements we've seen\n    create an empty collection named \"seen_elements\"\n\n    # Create a variable to keep track of the sum of repeated elements\n    create a variable named \"sum_of_repeated_elements\" and set it to 0\n\n    # Loop through each element in the input array\n    for each element in input_array:\n        # Check if we've come across this element before\n        if element is already in \"seen_elements\":\n            # If we have, this is a repeated element, so add it to our sum\n            add element to \"sum_of_repeated_elements\"\n        else:\n            # If it's a new element, add it to our collection to remember it\n            add element to \"seen_elements\"\n\n    # Return the sum of repeated elements\n    return \"sum_of_repeated_elements\"",
    "42": "function find_sequences_with_underscore(input_string):\n    # Import the 're' module for regular expressions\n    import re\n\n    # Define the regular expression pattern for sequences of lowercase letters joined with an underscore\n    pattern = '[a-z]+_[a-z]+'\n\n    # Use the 'findall' function from the 're' module to find all matches of the pattern in the input string\n    matches = re.findall(pattern, input_string)\n\n    # Return the list of matches\n    return matches",
    "43": "function match_word_at_beginning(input_string, word_to_match):\n    # Check if the input string starts with the word to match\n    if the first characters of input_string are equal to word_to_match:\n        # If they are, return True\n        return True\n    else:\n        # If they aren't, return False\n        return False",
    "44": "function find_gcd(array):\n    # Initialize the gcd to the first element of the array\n    set gcd to the first element of array\n\n    # Loop through the array starting from the second element\n    for each element in array starting from the second element:\n        # Find the gcd of the current gcd and the current element\n        set gcd to the gcd of gcd and element\n\n        # If the gcd becomes 1, break the loop as it's not possible to find a larger gcd\n        if gcd is 1:\n            break\n\n    # Return the final gcd\n    return gcd",
    "45": "function are_all_numbers_different(input_list):\n    # Create an empty collection to keep track of numbers we've seen\n    create an empty collection named \"seen_numbers\"\n\n    # Loop through each number in the input list\n    for each number in input_list:\n        # Check if we've come across this number before\n        if number is already in \"seen_numbers\":\n            # If we have, this is not all different numbers, so return False\n            return False\n        else:\n            # If it's a new number, add it to our collection to remember it\n            add number to \"seen_numbers\"\n\n    # If we've checked all numbers and found no repeats, return True\n    return True",
    "46": "function find_last_digit_factorial(a, b):\n    # Calculate the factorial of a\n    create a variable named \"factorial_a\" and initialize it to 1\n    for each number from 1 to a:\n        multiply \"factorial_a\" by the current number\n\n    # Calculate the factorial of b\n    create a variable named \"factorial_b\" and initialize it to 1\n    for each number from 1 to b:\n        multiply \"factorial_b\" by the current number\n\n    # Find the last digit of the factorial of a\n    convert \"factorial_a\" to a string\n    get the last character of the string\n    convert it back to an integer\n    store it in a variable named \"last_digit_a\"\n\n    # Find the last digit of the factorial of b\n    convert \"factorial_b\" to a string\n    get the last character of the string\n    convert it back to an integer\n    store it in a variable named \"last_digit_b\"\n\n    # If the last digit of a is less than the last digit of b, return the last digit of a\n    if \"last_digit_a\" is less than \"last_digit_b\":\n        return \"last_digit_a\"\n    # If the last digit of b is less than the last digit of a, return the last digit of b\n    else if \"last_digit_b\" is less than \"last_digit_a\":\n        return \"last_digit_b\"\n    # If the last digits are equal, return the last digit of a\n    else:\n        return \"last_digit_a\"",
    "47": "function set_odd_bits(number):\n    # Create a mask to set odd bits\n    create a variable named \"mask\" and set it to 0xAAAAAAAA (in hexadecimal)\n\n    # Use bitwise OR to set odd bits\n    number = number OR mask\n\n    # Return the modified number\n    return number",
    "48": "function extract_first_elements(two_dimensional_list):\n    # Create an empty list to store the first elements\n    create an empty list named \"first_elements\"\n\n    # Loop through each sublist in the two-dimensional list\n    for each sublist in two_dimensional_list:\n        # Add the first element of the sublist to our list\n        add the first element of sublist to \"first_elements\"\n\n    # Return the list of first elements\n    return \"first_elements\"",
    "49": "function find_shortest_list(list_of_lists):\n    # Use the built-in function min() and lambda function to find the list with the smallest length\n    return min(list_of_lists, key=lambda x: len(x))",
    "50": "function is_equilateral_triangle(side1, side2, side3):\n    # Check if all sides are equal\n    if side1 is equal to side2 and side2 is equal to side3:\n        # If all sides are equal, it's an equilateral triangle\n        print \"The triangle is equilateral\"\n    else:\n        # If not all sides are equal, it's not an equilateral triangle\n        print \"The triangle is not equilateral\"",
    "51": "function calculate_area_of_parallelogram(base, height):\n    # Check if base and height are both positive numbers\n    if base and height are both positive numbers:\n        # Calculate the area of the parallelogram\n        area = base * height\n        # Return the calculated area\n        return area\n    else:\n        # If base or height is not a positive number, return an error message\n        return \"Error: Base and height must be positive numbers.\"",
    "52": "function check_first_last_characters_equal(input_string):\n    # Check if the first character of the string is the same as the last character\n    if the first character of input_string is the same as the last character of input_string:\n        # If they are, return True\n        return True\n    else:\n        # If they are not, return False\n        return False",
    "53": "function counting_sort(input_array):\n    # Create an empty array to hold the sorted output\n    create an empty array named \"sorted_array\"\n\n    # Find the maximum value in the input array\n    find the maximum value in input_array and store it in \"max_value\"\n\n    # Create an array of zeros with length equal to max_value + 1\n    create an array of zeros with length equal to max_value + 1 and store it in \"count_array\"\n\n    # Loop through each number in the input array\n    for each number in input_array:\n        # Increment the count at the corresponding index in count_array\n        increment the count at the index number in count_array\n\n    # Loop through each index in count_array\n    for each index in count_array:\n        # While the count at this index is greater than 0\n        while the count at index in count_array is greater than 0:\n            # Add the index to the sorted_array\n            add index to sorted_array\n            # Decrement the count at this index in count_array\n            decrement the count at index in count_array\n\n    # Return the sorted_array\n    return sorted_array",
    "54": "function find_t_nth_term(first_term, common_ratio, n):\n    # Calculate the t-nth term of the geometric series\n    t_nth_term = first_term * (common_ratio ** (n - 1))\n\n    # Return the t-nth term\n    return t_nth_term",
    "55": "function is_one_less_than_twice_reverse(number):\n    # Convert the number to a string to easily reverse it\n    convert number to string and assign it to \"number_string\"\n\n    # Reverse the string\n    reverse \"number_string\" and assign it to \"reversed_string\"\n\n    # Convert the reversed string back to a number\n    convert \"reversed_string\" to a number and assign it to \"reversed_number\"\n\n    # Check if the number is one less than twice its reverse\n    if number is equal to (reversed_number * 2) - 1:\n        # If it is, return True\n        return True\n    else:\n        # If it's not, return False\n        return False",
    "56": "function find_largest_number(input_digits):\n    # Sort the input digits in descending order\n    sort input_digits in descending order\n\n    # Join the sorted digits together to form a number\n    join sorted_digits together to form a number named \"largest_number\"\n\n    # Return the largest number\n    return largest_number",
    "57": "function check_opposite_sign(num1, num2):\n    # Check if both numbers are of the same sign\n    if num1 and num2 have the same sign:\n        # If they are, return True\n        return True\n    else:\n        # If they are not, return False\n        return False",
    "58": "function find_nth_octagonal_number(n):\n    # Check if n is a positive integer\n    if n is not a positive integer:\n        # If not, return an error message\n        return \"Error: n must be a positive integer\"\n\n    # Calculate the nth octagonal number using the formula: n*(2n-1)\n    octagonal_number = n*(2n-1)\n\n    # Return the nth octagonal number\n    return octagonal_number",
    "59": "function max_length_subsequence(array):\n    # Initialize the maximum length of the subsequence\n    max_length = 0\n\n    # Loop through the array\n    for i in range(len(array)):\n        # Initialize the current length of the subsequence\n        current_length = 1\n\n        # Loop through the rest of the array\n        for j in range(i+1, len(array)):\n            # Check if the difference between the current element and the next one is 1\n            if array[j] - array[j-1] == 1:\n                # If it is, increment the current length of the subsequence\n                current_length += 1\n            else:\n                # If it's not, break the loop and start a new subsequence\n                break\n\n        # Update the maximum length of the subsequence if the current length is greater\n        if current_length > max_length:\n            max_length = current_length\n\n    # Return the maximum length of the subsequence\n    return max_length",
    "60": "function count_substrings_with_sum_equal_to_length(input_string):\n    # Initialize a counter to keep track of the number of substrings\n    initialize a counter named \"count\" to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If the character is a digit, add it to the sum\n        if character is a digit:\n            add character to \"sum\"\n        else:\n            # If the character is not a digit, check if the sum is equal to the length of the substring\n            if \"sum\" is equal to the length of the substring:\n                # If it is, increment the counter\n                increment \"count\" by 1\n            # Reset the sum\n            initialize \"sum\" to 0\n\n    # Return the counter\n    return \"count\"",
    "61": "function find_smallest_number(list_of_numbers):\n    # Assume the first number in the list is the smallest\n    set smallest_number to the first number in list_of_numbers\n\n    # Loop through each number in the list\n    for each number in list_of_numbers:\n        # Check if this number is smaller than our current smallest number\n        if number is less than smallest_number:\n            # If it is, update smallest_number to be this number\n            set smallest_number to number\n\n    # Once we've checked all numbers, return the smallest number\n    return smallest_number",
    "62": "function find_max_difference(tuple_list):\n    # Initialize max_difference to negative infinity\n    max_difference = -infinity\n\n    # Loop through each tuple in the tuple_list\n    for each tuple in tuple_list:\n        # Loop through each pair in the tuple\n        for each pair in tuple:\n            # Calculate the difference between the pair\n            difference = pair[1] - pair[0]\n\n            # If the difference is greater than max_difference, update max_difference\n            if difference > max_difference:\n                max_difference = difference\n\n    # Return the maximum difference found\n    return max_difference",
    "63": "function sort_tuples(list_of_tuples):\n    # Sort the list of tuples using a lambda function\n    sort list_of_tuples using a lambda function that sorts by the first element of each tuple\n\n    # Return the sorted list of tuples\n    return sorted list_of_tuples",
    "64": "function recursive_list_sum(input_list):\n    # Base case: if the list is empty, return 0\n    if input_list is empty:\n        return 0\n\n    # Recursive case: if the list is not empty, return the first element plus the sum of the rest of the list\n    else:\n        return first element of input_list + recursive_list_sum(rest of input_list)",
    "65": "function count_positive_numbers(list_of_numbers):\n    # Initialize a counter to keep track of positive numbers\n    initialize a variable named \"positive_count\" to 0\n\n    # Loop through each number in the list\n    for each number in list_of_numbers:\n        # Check if the number is positive\n        if number is greater than 0:\n            # If it is, increment the counter\n            increment \"positive_count\" by 1\n\n    # After checking all numbers, return the count\n    return \"positive_count\"",
    "66": "function partition_bell_numbers(n):\n    # Initialize an array to store the first n Bell numbers\n    create an array named \"bell_numbers\" with n elements\n\n    # Initialize the first two Bell numbers\n    set the first element of \"bell_numbers\" to 1\n    set the second element of \"bell_numbers\" to 1\n\n    # Calculate the rest of the Bell numbers\n    for i from 2 to n:\n        for j from 0 to i:\n            set the i-th element of \"bell_numbers\" to the sum of the i-th element and the j-th element of \"bell_numbers\"\n\n    # Initialize an array to store the partition numbers\n    create an array named \"partition_numbers\" with n+1 elements\n\n    # Initialize the first partition number\n    set the first element of \"partition_numbers\" to 1\n\n    # Calculate the rest of the partition numbers\n    for i from 1 to n:\n        for j from 0 to i:\n            set the i-th element of \"partition_numbers\" to the sum of the i-th element and the j-th element of \"partition_numbers\"\n\n    # Return the partition number of n\n    return the n-th element of \"partition_numbers\"",
    "67": "function is_monotonic(array):\n    # Initialize variables to keep track of whether the array is increasing or decreasing\n    set increasing to True\n    set decreasing to True\n\n    # Loop through the array to check if it's increasing or decreasing\n    for each index in range from 1 to length of array - 1:\n        # If the current element is less than the previous one, it's not increasing\n        if array[index] < array[index - 1]:\n            set increasing to False\n        # If the current element is greater than the previous one, it's not decreasing\n        if array[index] > array[index - 1]:\n            set decreasing to False\n\n    # If the array is increasing or decreasing, it's monotonic\n    if increasing or decreasing:\n        return True\n    else:\n        return False",
    "68": "function is_sublist(main_list, sublist):\n    # Check if the sublist is empty\n    if sublist is empty:\n        # If it is, then it is always a sublist\n        return True\n\n    # Check if the main list is empty\n    if main_list is empty:\n        # If it is, then it cannot be a sublist\n        return False\n\n    # Check if the first element of the sublist is in the main list\n    if first element of sublist is in main_list:\n        # If it is, then we need to check the rest of the sublist\n        return is_sublist(rest of main_list, rest of sublist)\n    else:\n        # If it's not, then we need to start again from the next element in the main list\n        return is_sublist(rest of main_list, sublist)\n\n    # If we've checked all elements and found no matches, return False\n    return False",
    "69": "function all_tuples_equal_length(tuple_list):\n    # Get the length of the first tuple\n    set the variable \"length\" to the length of the first tuple in tuple_list\n\n    # Loop through each tuple in the tuple_list\n    for each tuple in tuple_list:\n        # Check if the length of the current tuple is equal to the length of the first tuple\n        if the length of the current tuple is not equal to \"length\":\n            # If it's not, return False\n            return False\n\n    # If we've checked all tuples and found they all have the same length, return True\n    return True",
    "70": "function comb_sort(input_list):\n    # Initialize gap size\n    gap = len(input_list)\n    swapped = True\n\n    # Keep running while gap is more than 1 and last swap was at least one\n    while gap != 1 or swapped:\n        # Find next gap\n        gap = get_next_gap(gap)\n\n        # Initialize swapped as false so that we can check if swap happened or not\n        swapped = False\n\n        # Compare all elements with current gap\n        for i in range(0, len(input_list) - gap):\n            if input_list[i] > input_list[i + gap]:\n                # Swap elements\n                input_list[i], input_list[i + gap] = input_list[i + gap], input_list[i]\n                swapped = True\n\n    return input_list\n\nfunction get_next_gap(gap):\n    # Shrink gap by Shrink factor\n    gap = (gap * 10) / 13\n    if gap < 1:\n        return 1\n    return gap",
    "71": "function check_difference_of_squares(number):\n    # Create a variable to keep track of the number of ways we can represent the number as the sum of two squares\n    create a variable named \"ways_to_represent\" and set it to 0\n\n    # Loop through all possible values for the first square\n    for i from 0 to sqrt(number):\n        # Calculate the square of the current value\n        square_i = i * i\n\n        # If the square of the current value is greater than the number, we can't represent the number as the sum of two squares\n        if square_i > number:\n            break\n\n        # Calculate the square of the difference between the number and the current value\n        square_difference = (number - square_i)\n\n        # If the square of the difference is a perfect square, we can represent the number as the sum of two squares\n        if is_perfect_square(square_difference):\n            # Increment the count of ways we can represent the number as the sum of two squares\n            increment \"ways_to_represent\" by 1\n\n    # If we found at least one way to represent the number as the sum of two squares, return True\n    if \"ways_to_represent\" is greater than 0:\n        return True\n    else:\n        # If we didn't find any ways to represent the number as the sum of two squares, return False\n        return False\n\n# Helper function to check if a number is a perfect square\nfunction is_perfect_square(number):\n    # Calculate the square root of the number\n    root = sqrt(number)\n\n    # If the square root is an integer, the number is a perfect square\n    if root is an integer:\n        return True\n    else:\n        return False",
    "72": "function split_string_with_multiple_delimiters(input_string, delimiters):\n    # Import the required module\n    import re\n\n    # Create a regular expression pattern that matches any of the delimiters\n    pattern = '|'.join(map(re.escape, delimiters))\n\n    # Use the re.split function to split the string\n    result = re.split(pattern, input_string)\n\n    # Return the result\n    return result",
    "73": "function check_sequence(input_array, patterns):\n    # Create an empty collection to keep track of the current sequence\n    create an empty collection named \"current_sequence\"\n\n    # Loop through each element in the input array\n    for each element in input_array:\n        # Check if the current sequence matches the next pattern\n        if current_sequence matches the next pattern in patterns:\n            # If it does, add the element to the current sequence\n            add element to current_sequence\n        else:\n            # If it doesn't, the sequence doesn't match, so return False\n            return False\n\n    # If we've checked all elements and found no mismatches, return True\n    return True",
    "74": "function find_tuples_divisible_by_k(tuple_list, k):\n    # Create an empty list to store the tuples that meet the criteria\n    create an empty list named \"divisible_tuples\"\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Assume the tuple is divisible by k\n        let \"is_divisible\" be True\n\n        # Loop through each element in the tuple\n        for each element in tuple:\n            # Check if the element is not divisible by k\n            if element modulo k is not equal to 0:\n                # If it's not divisible, set \"is_divisible\" to False and break the loop\n                set \"is_divisible\" to False\n                break\n\n        # If the tuple is divisible by k, add it to the list\n        if \"is_divisible\" is True:\n            add tuple to \"divisible_tuples\"\n\n    # Return the list of tuples that are divisible by k\n    return \"divisible_tuples\"",
    "75": "function count_squares_in_rectangle(length, width):\n    # Calculate the area of the rectangle\n    area = length * width\n\n    # Calculate the number of squares that can fit in the rectangle\n    # This is done by dividing the area by the area of a single square\n    # The result is rounded down to the nearest whole number\n    number_of_squares = area // 4\n\n    # Return the number of squares\n    return number_of_squares",
    "76": "function find_difference_between_sums(input_number):\n    # Initialize variables to keep track of the sum of even and odd digits\n    initialize variable \"sum_of_even_digits\" to 0\n    initialize variable \"sum_of_odd_digits\" to 0\n\n    # Convert the input number to a string so we can iterate over its digits\n    convert input_number to a string and assign it to \"number_as_string\"\n\n    # Loop through each digit in the number\n    for each character in \"number_as_string\":\n        # Convert the digit back to an integer\n        convert character to an integer and assign it to \"digit\"\n\n        # Check if the digit is even or odd\n        if digit is divisible by 2:\n            # If it's even, add it to the sum of even digits\n            add digit to \"sum_of_even_digits\"\n        else:\n            # If it's odd, add it to the sum of odd digits\n            add digit to \"sum_of_odd_digits\"\n\n    # Calculate the difference between the sums of even and odd digits\n    subtract \"sum_of_odd_digits\" from \"sum_of_even_digits\" and assign it to \"difference\"\n\n    # Return the difference\n    return difference",
    "77": "function count_odd_set_bits(input_list):\n    # Initialize a counter to keep track of the number of integers with odd number of set bits\n    initialize a counter named \"odd_set_bits_count\" to 0\n\n    # Loop through each integer in the input list\n    for each integer in input_list:\n        # Convert the integer to binary and count the number of set bits\n        convert integer to binary and count the number of set bits\n\n        # Check if the count is odd\n        if the count is odd:\n            # If it is, increment the counter\n            increment \"odd_set_bits_count\" by 1\n\n    # Return the counter\n    return \"odd_set_bits_count\"",
    "78": "function check_odd_length(word):\n    # Get the length of the word\n    length = length of word\n\n    # Check if the length is odd\n    if length is odd:\n        # If it is, return True\n        return True\n    else:\n        # If it's not, return False\n        return False",
    "79": "function find_nth_tetrahedral_number(n):\n    # Check if n is less than 1\n    if n is less than 1:\n        # If it is, return an error message\n        return \"Error: n must be greater than 0\"\n\n    # Calculate the nth tetrahedral number using the formula n*(n+1)*(n+2)/6\n    tetrahedral_number = n*(n+1)*(n+2)/6\n\n    # Return the nth tetrahedral number\n    return tetrahedral_number",
    "80": "function zip_tuples(tuple1, tuple2):\n    # Create an empty collection to store the zipped tuples\n    create an empty collection named \"zipped_tuples\"\n\n    # Loop through each element in the first tuple\n    for each element in tuple1:\n        # Add the current element from the first tuple and the corresponding element from the second tuple to the zipped tuples\n        add (element, tuple2[index of element in tuple1]) to \"zipped_tuples\"\n\n    # Return the zipped tuples\n    return \"zipped_tuples\"",
    "81": "function find_volume_of_sphere(radius):\n    # Calculate the volume of the sphere\n    volume = (4/3) * pi * radius^3\n\n    # Return the volume\n    return volume",
    "82": "function find_sum_of_characters(input_string):\n    # Initialize a variable to keep track of the sum\n    set sum_of_characters to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Convert the character to its ASCII value and add it to the sum\n        add ASCII value of character to sum_of_characters\n\n    # Return the sum\n    return sum_of_characters",
    "83": "function find_nth_newman_conway_number(n):\n    # Create a list to store the first two numbers of the sequence\n    create a list named \"sequence\" with the first two numbers as 0 and 1\n\n    # If n is less than or equal to 0, return an error message\n    if n is less than or equal to 0:\n        return \"Input must be a positive integer\"\n\n    # If n is 1 or 2, return the first or second number in the sequence\n    if n is 1:\n        return 0\n    if n is 2:\n        return 1\n\n    # For n greater than 2, calculate the nth number in the sequence\n    for i from 3 to n:\n        # The nth number is the sum of the (n-1)th and (n-sequence[n-1])th numbers\n        calculate the nth number as the sum of (n-1)th and (n-sequence[n-1])th numbers\n        add the calculated number to \"sequence\"\n\n    # Return the nth number in the sequence\n    return the nth number in \"sequence\"",
    "84": "function find_surface_area_of_sphere(radius):\n    # Calculate the surface area of a sphere using the formula 4 * \u03c0 * r^2\n    surface_area = 4 * \u03c0 * radius^2\n\n    # Return the calculated surface area\n    return surface_area",
    "85": "function find_nth_centered_hexagonal_number(n):\n    # Calculate the nth centered hexagonal number using the formula: n(2n-1)\n    centered_hexagonal_number = n * (2 * n - 1)\n\n    # Return the nth centered hexagonal number\n    return centered_hexagonal_number",
    "86": "function merge_dictionaries(dict1, dict2, dict3):\n    # Create a new dictionary to store the merged dictionaries\n    create a new dictionary named \"merged_dict\"\n\n    # Loop through each dictionary and add its contents to the merged dictionary\n    for each dictionary in dict1, dict2, dict3:\n        for each key, value in dictionary:\n            add key, value to \"merged_dict\"\n\n    # Return the merged dictionary\n    return merged_dict",
    "87": "function get_frequency(list):\n    # Create an empty dictionary to keep track of frequencies\n    create an empty dictionary named \"frequency_dict\"\n\n    # Loop through each element in the list\n    for each element in list:\n        # Check if the element is already in the dictionary\n        if element is already in \"frequency_dict\":\n            # If it is, increment its count\n            increment the count of element in \"frequency_dict\" by 1\n        else:\n            # If it's not, add it to the dictionary with a count of 1\n            add element to \"frequency_dict\" with a count of 1\n\n    # Return the dictionary of frequencies\n    return \"frequency_dict\"",
    "88": "function find_closest_smaller_number(n):\n    # Convert the number to a string to make it iterable\n    convert n to a string and store it in a variable named \"number_string\"\n\n    # Create an empty list to store the digits of the number\n    create an empty list named \"digits\"\n\n    # Loop through each digit in the number string\n    for each digit in number_string:\n        # Add the digit to the list of digits\n        add digit to \"digits\"\n\n    # Sort the list of digits in descending order\n    sort \"digits\" in descending order\n\n    # Join the sorted list of digits back into a string\n    join \"digits\" back into a string and store it in a variable named \"sorted_string\"\n\n    # Convert the sorted string back into an integer\n    convert sorted_string to an integer and store it in a variable named \"sorted_number\"\n\n    # If the sorted number is less than n, return it\n    if sorted_number is less than n:\n        return sorted_number\n    else:\n        # If the sorted number is not less than n, return a signal (like None or a message)\n        return None",
    "89": "function find_length_of_longest_word(input_string):\n    # Split the input string into words\n    split input_string into words\n\n    # Initialize a variable to keep track of the longest word's length\n    initialize a variable named \"longest_word_length\" to 0\n\n    # Loop through each word in the list of words\n    for each word in words:\n        # Check if the length of the current word is greater than the longest word's length\n        if the length of word is greater than longest_word_length:\n            # If it is, update the longest word's length\n            update longest_word_length to the length of word\n\n    # Return the longest word's length\n    return longest_word_length",
    "90": "function is_substring_present(list_of_strings, substring):\n    # Loop through each string in the list\n    for each string in list_of_strings:\n        # Check if the substring is in the string\n        if substring is in string:\n            # If it is, return True\n            return True\n\n    # If we've checked all strings and found no matches, return False\n    return False",
    "91": "function is_undulating(number):\n    # Convert the number to a string\n    convert number to string and store it in a variable named \"number_string\"\n\n    # Loop through each digit in the number string\n    for each digit in number_string:\n        # Check if the current digit is the same as the next digit\n        if digit is the same as the next digit:\n            # If it is, the number is not undulating, so return False\n            return False\n\n    # If we've checked all digits and found no repeats, the number is undulating, so return True\n    return True",
    "92": "function power(a, b):\n    # Initialize the result to 1\n    initialize result to 1\n\n    # If b is negative, set a to the reciprocal of a and b to its absolute value\n    if b is less than 0:\n        set a to the reciprocal of a\n        set b to its absolute value\n\n    # While b is greater than 0, multiply result by a and decrement b by 1\n    while b is greater than 0:\n        multiply result by a\n        decrement b by 1\n\n    # Return the final result\n    return result",
    "93": "function extract_min_index_record(tuples):\n    # Initialize variables to keep track of the minimum value and its index\n    set min_value to the first element of the first tuple\n    set min_index to the index of the first element of the first tuple\n\n    # Loop through each tuple in the list of tuples\n    for each tuple in tuples:\n        # Loop through each element in the tuple\n        for each element in tuple:\n            # If the element is less than the current minimum value\n            if element is less than min_value:\n                # Update the minimum value and its index\n                set min_value to element\n                set min_index to the index of element in the tuple\n\n    # Return the minimum value and its index\n    return min_value, min_index",
    "94": "function find_minimum_length_sublist(input_list):\n    # Initialize minimum length to infinity\n    set minimum_length to infinity\n\n    # Loop through each sublist in the input list\n    for each sublist in input_list:\n        # Check if the length of the current sublist is less than minimum_length\n        if length of sublist is less than minimum_length:\n            # If it is, update minimum_length\n            set minimum_length to length of sublist\n\n    # Return the minimum length\n    return minimum_length",
    "95": "function find_number_of_divisors(input_integer):\n    # Create a variable to keep track of the number of divisors\n    create a variable named \"number_of_divisors\" and set it to 0\n\n    # Loop from 1 to the input integer\n    for each number from 1 to input_integer:\n        # Check if the input integer is divisible by the current number\n        if input_integer is divisible by number:\n            # If it is, increment the number of divisors\n            increment \"number_of_divisors\" by 1\n\n    # Return the number of divisors\n    return \"number_of_divisors\"",
    "96": "function find_frequency_count(list_of_lists):\n    # Create an empty dictionary to keep track of frequency counts\n    create an empty dictionary named \"frequency_counts\"\n\n    # Loop through each list in the list of lists\n    for each list in list_of_lists:\n        # Loop through each item in the list\n        for each item in list:\n            # Check if the item is already in the dictionary\n            if item is already in \"frequency_counts\":\n                # If it is, increment its count\n                increment the count for item in \"frequency_counts\"\n            else:\n                # If it's not, add it to the dictionary with a count of 1\n                add item to \"frequency_counts\" with a count of 1\n\n    # Return the dictionary of frequency counts\n    return \"frequency_counts\"",
    "97": "function multiply_and_divide(list_of_numbers):\n    # Initialize a variable to keep track of the product of all numbers\n    set a variable named \"product\" to 1\n\n    # Loop through each number in the list\n    for each number in list_of_numbers:\n        # Multiply the current product by the current number\n        multiply \"product\" by number\n\n    # Divide the product by the length of the list\n    divide \"product\" by the length of list_of_numbers\n\n    # Return the result\n    return \"product\"",
    "98": "function convert_to_binary(decimal_number):\n    # Create an empty string to store the binary representation\n    create an empty string named \"binary_representation\"\n\n    # While the decimal number is greater than 0\n    while decimal_number is greater than 0:\n        # Get the remainder of the decimal number divided by 2\n        remainder = decimal_number modulo 2\n\n        # Add the remainder to the start of the binary representation\n        add remainder to the start of \"binary_representation\"\n\n        # Divide the decimal number by 2 and round down to the nearest whole number\n        decimal_number = decimal_number divided by 2\n\n    # Return the binary representation\n    return binary_representation",
    "99": "function find_next_smallest_palindrome(input_number):\n    # Convert the input number to a string\n    convert input_number to a string and store it in a variable named \"number_string\"\n\n    # Reverse the string\n    reverse \"number_string\" and store it in a variable named \"reversed_string\"\n\n    # If the reversed string is greater than the original string, increment the original string by 1\n    if \"reversed_string\" is greater than \"number_string\":\n        increment \"number_string\" by 1\n\n    # Convert the incremented string back to an integer\n    convert \"number_string\" back to an integer and store it in a variable named \"next_smallest_palindrome\"\n\n    # Return the next smallest palindrome\n    return \"next_smallest_palindrome\"",
    "100": "function find_kth_element(array, k):\n    # Check if the array is empty\n    if array is empty:\n        # If it is, return a message indicating that the array is empty\n        return \"The array is empty\"\n\n    # Check if k is less than 1 or greater than the length of the array\n    if k is less than 1 or k is greater than the length of the array:\n        # If it is, return a message indicating that k is out of range\n        return \"k is out of range\"\n\n    # If the array is not empty and k is within range, return the kth element\n    return the kth element in the array",
    "101": "function convert_snake_to_camel(snake_case_string):\n    # Split the snake case string into words\n    split snake_case_string into words at each underscore\n\n    # Create an empty string to store the camel case string\n    create an empty string named \"camel_case_string\"\n\n    # Loop through each word in the list of words\n    for each word in words:\n        # Capitalize the first letter of the word and add it to the camel case string\n        capitalize the first letter of word and add it to \"camel_case_string\"\n\n    # Return the camel case string\n    return \"camel_case_string\"",
    "102": "function eulerian_number(n, m):\n    # Initialize the result as 1\n    let result be 1\n\n    # Loop from 1 to n\n    for i from 1 to n:\n        # Multiply the result by i\n        result = result * i\n\n    # Loop from 1 to m\n    for i from 1 to m:\n        # Divide the result by i\n        result = result / i\n\n    # Return the result\n    return result",
    "103": "function sort_sublists(list_of_lists):\n    # Loop through each sublist in the list of lists\n    for each sublist in list_of_lists:\n        # Sort the sublist using a lambda function to sort by the first character of each string\n        sort sublist using a lambda function that returns the first character of each string\n\n    # Return the sorted list of lists\n    return list_of_lists",
    "104": "function count_true_booleans(boolean_list):\n    # Create a counter to keep track of the number of true booleans\n    create a variable named \"true_count\" and set it to 0\n\n    # Loop through each boolean in the boolean list\n    for each boolean in boolean_list:\n        # Check if the boolean is true\n        if boolean is true:\n            # If it is, increment the counter\n            increment \"true_count\" by 1\n\n    # Return the final count\n    return \"true_count\"",
    "105": "function add_list_to_tuples(tuples, list):\n    # Create an empty list to store the result\n    create an empty list named \"result\"\n\n    # Loop through each tuple in the tuples\n    for each tuple in tuples:\n        # Create a new tuple by adding the list to the current tuple\n        new_tuple = tuple + list\n        # Add the new tuple to the result list\n        add new_tuple to \"result\"\n\n    # Return the result list\n    return \"result\"",
    "106": "function count_hexadecimal_numbers(start, end):\n    # Initialize a counter to keep track of the number of hexadecimal numbers\n    initialize a counter named \"count\" to 0\n\n    # Loop through each number in the given range\n    for each number in range from start to end:\n        # Convert the number to hexadecimal\n        convert number to hexadecimal\n\n        # Check if the hexadecimal representation of the number contains any non-hexadecimal characters\n        if the hexadecimal representation of the number contains any non-hexadecimal characters:\n            # If it does, skip this number\n            continue\n        else:\n            # If it doesn't, increment the counter\n            increment \"count\" by 1\n\n    # Return the final count\n    return \"count\"",
    "107": "function merge_sorted_iterators(input_iterators):\n    # Create an empty heap queue\n    create an empty heap queue named \"heap_queue\"\n\n    # Loop through each iterator in the input\n    for each iterator in input_iterators:\n        # If the iterator has a next element, add it to the heap queue\n        if iterator has a next element:\n            add next element from iterator to \"heap_queue\"\n\n    # Create an empty list to store the merged elements\n    create an empty list named \"merged_elements\"\n\n    # While the heap queue is not empty\n    while \"heap_queue\" is not empty:\n        # Remove the smallest element from the heap queue\n        remove smallest element from \"heap_queue\" and store it in \"smallest_element\"\n\n        # Add the smallest element to the merged elements list\n        add \"smallest_element\" to \"merged_elements\"\n\n        # If the iterator that the smallest element came from has a next element, add it to the heap queue\n        if the iterator that \"smallest_element\" came from has a next element:\n            add next element from the iterator that \"smallest_element\" came from to \"heap_queue\"\n\n    # Return the merged elements list\n    return \"merged_elements\"",
    "108": "function count_rotations_of_binary_string(binary_string):\n    # Initialize count of rotations\n    initialize count_rotations to 0\n\n    # Initialize length of binary string\n    initialize length to length of binary_string\n\n    # Initialize count of ones\n    initialize count_ones to 0\n\n    # Traverse through the binary string\n    for each character in binary_string:\n        # If character is '1'\n        if character is '1':\n            # Increment count of ones\n            increment count_ones by 1\n\n    # If count of ones is odd\n    if count_ones is odd:\n        # Increment count of rotations\n        increment count_rotations by 1\n\n    # Return count of rotations\n    return count_rotations",
    "109": "function find_missing_ranges(input_list, start_range, end_range):\n    # Create an empty list to store the missing ranges\n    create an empty list named \"missing_ranges\"\n\n    # Loop through each number in the input list\n    for each number in input_list:\n        # Check if the number is within the start and end range\n        if number is within the range of start_range and end_range:\n            # If it is, remove it from the range\n            remove number from the range\n\n    # Loop through each number in the range\n    for each number in the range:\n        # Check if the number is in the input list\n        if number is not in input_list:\n            # If it's not, add it to the missing ranges\n            add number to \"missing_ranges\"\n\n    # Return the missing ranges\n    return \"missing_ranges\"",
    "110": "function find_common_elements(list1, list2):\n    # Create an empty list to store common elements\n    create an empty list named \"common_elements\"\n\n    # Loop through each element in the first list\n    for each element in list1:\n        # Check if the element is in the second list\n        if element is in list2:\n            # If it is, add it to the list of common elements\n            add element to \"common_elements\"\n\n    # Return the list of common elements\n    return \"common_elements\"",
    "111": "function find_cylinder_perimeter(radius, height):\n    # Calculate the perimeter of the cylinder\n    perimeter = 2 * 3.14 * radius * (radius + height)\n\n    # Return the calculated perimeter\n    return perimeter",
    "112": "function is_string_integer(input_string):\n    # Check if the string is empty\n    if input_string is empty:\n        return False\n\n    # Check if the string starts with a '-' sign\n    if the first character of input_string is '-':\n        # If it does, remove the '-' sign\n        input_string = remove the first character from input_string\n\n    # Check if the string is a number\n    for each character in input_string:\n        if character is not a digit:\n            return False\n\n    # If we've checked all characters and found no non-digit characters, return True\n    return True",
    "113": "function assign_frequency(tuple_list):\n    # Create an empty dictionary to keep track of frequencies\n    create an empty dictionary named \"frequency_dict\"\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Check if the tuple is already in the dictionary\n        if tuple is already in \"frequency_dict\":\n            # If it is, increment its count\n            increment the count for tuple in \"frequency_dict\"\n        else:\n            # If it's not, add it to the dictionary with a count of 1\n            add tuple to \"frequency_dict\" with a count of 1\n\n    # Return the dictionary\n    return \"frequency_dict\"",
    "114": "function check_empty_dictionaries(list_of_dictionaries):\n    # Loop through each dictionary in the list\n    for each dictionary in list_of_dictionaries:\n        # Check if the dictionary is not empty\n        if dictionary is not empty:\n            # If it's not empty, return False\n            return False\n\n    # If we've checked all dictionaries and found no non-empty ones, return True\n    return True",
    "115": "function convert_tuple_to_integer(input_tuple):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each element in the input tuple\n    for each element in input_tuple:\n        # Convert the element to a string and add it to the result\n        convert element to a string and add it to \"result\"\n\n    # Convert the result to an integer and return it\n    convert \"result\" to an integer and return it",
    "116": "function convert_to_float(input_list):\n    # Create an empty list to store the converted elements\n    create an empty list named \"converted_list\"\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # Try to convert the element to a float\n        try:\n            # If the conversion is successful, add the float to the converted list\n            add float(element) to \"converted_list\"\n        except:\n            # If the conversion fails (for example, if the element is not a number), add the original element to the converted list\n            add element to \"converted_list\"\n\n    # Return the converted list\n    return \"converted_list\"",
    "117": "function convert_string_to_list(input_string):\n    # Create an empty list to store the characters\n    create an empty list named \"character_list\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Add the character to the list\n        add character to \"character_list\"\n\n    # Return the list of characters\n    return \"character_list\"",
    "118": "function find_single_occurrence(sorted_array):\n    # Initialize two pointers, one at the start and the other at the end of the array\n    set pointer1 to 0\n    set pointer2 to length of sorted_array - 1\n\n    # Loop until the pointers meet\n    while pointer1 < pointer2:\n        # If the element at pointer1 is equal to the element at pointer2\n        if sorted_array[pointer1] equals sorted_array[pointer2]:\n            # Move both pointers one step towards the center\n            increment pointer1 by 1\n            decrement pointer2 by 1\n        else:\n            # If the element at pointer1 is not equal to the element at pointer2\n            # This means that the single occurrence is either to the left or to the right of the current pointers\n            # If the element at pointer1 is not equal to the element at pointer1 - 1\n            if sorted_array[pointer1] is not equal to sorted_array[pointer1 - 1]:\n                # This means the single occurrence is to the left of the current pointers\n                # Return the element at pointer1\n                return sorted_array[pointer1]\n            else:\n                # If the element at pointer1 is equal to the element at pointer1 - 1\n                # This means the single occurrence is to the right of the current pointers\n                # Return the element at pointer2\n                return sorted_array[pointer2]\n\n    # If the pointers meet, this means there is no single occurrence\n    # Return None\n    return None",
    "119": "function find_max_product(list_of_tuples):\n    # Initialize max_product to negative infinity\n    set max_product to negative infinity\n\n    # Loop through each tuple in the list\n    for each tuple in list_of_tuples:\n        # Calculate the product of the two numbers in the tuple\n        set product to the product of the two numbers in the tuple\n\n        # If the product is greater than max_product, update max_product\n        if product is greater than max_product:\n            set max_product to product\n\n    # Return the maximum product\n    return max_product",
    "120": "function find_triplet_with_sum(input_array, target_sum):\n    # Sort the input array\n    sort the input_array in ascending order\n\n    # Loop through each number in the input array\n    for each number in input_array:\n        # Initialize two pointers, one at the next number and one at the last number\n        set two pointers, one at the next number and one at the last number\n\n        # While the two pointers don't cross each other\n        while the two pointers don't cross each other:\n            # Calculate the sum of the numbers at the two pointers\n            calculate the sum of the numbers at the two pointers\n\n            # If the sum is less than the target sum, move the left pointer to the right\n            if the sum is less than the target sum:\n                move the left pointer to the right\n            # If the sum is more than the target sum, move the right pointer to the left\n            else if the sum is more than the target sum:\n                move the right pointer to the left\n            # If the sum is equal to the target sum, return the triplet\n            else:\n                return the numbers at the two pointers and the current number\n\n    # If no triplet is found, return a signal (like None or a message)\n    return None",
    "121": "function find_nth_smart_number(n):\n    # Initialize a counter for smart numbers\n    initialize a variable named \"smart_number_count\" to 0\n\n    # Initialize a number to check\n    initialize a variable named \"current_number\" to 1\n\n    # Loop until we've found n smart numbers\n    while smart_number_count < n:\n        # Check if the current number is a smart number\n        if is_smart_number(current_number):\n            # If it is, increment our smart number count\n            increment smart_number_count by 1\n\n        # Regardless of whether the current number is a smart number, move on to the next number\n        increment current_number by 1\n\n    # Return the last smart number we found\n    return current_number - 1\n\n# Helper function to check if a number is a smart number\nfunction is_smart_number(number):\n    # Initialize a sum of divisors\n    initialize a variable named \"sum_of_divisors\" to 0\n\n    # Loop through all numbers up to the square root of the given number\n    for each number from 1 to the square root of number:\n        # If the current number divides evenly into the given number, add it to our sum of divisors\n        if number is divisible by current_number:\n            increment sum_of_divisors by current_number\n            if current_number is not equal to the square root of number:\n                increment sum_of_divisors by number / current_number\n\n    # If the sum of divisors is equal to the given number, it's a smart number\n    if sum_of_divisors is equal to number:\n        return True\n    else:\n        return False",
    "122": "function sum_amicable_numbers(upper_limit):\n    # Create an empty collection to keep track of amicable numbers\n    create an empty collection named \"amicable_numbers\"\n\n    # Loop through each number from 1 to the upper limit\n    for each number from 1 to upper_limit:\n        # Calculate the sum of the divisors of the number\n        calculate the sum of the divisors of number and store it in a variable named \"sum_of_divisors\"\n\n        # If the sum of the divisors is greater than the number and is not equal to the number,\n        # then the number is amicable\n        if sum_of_divisors > number and sum_of_divisors != number:\n            # Calculate the sum of the divisors of the sum of the divisors\n            calculate the sum of the divisors of sum_of_divisors and store it in a variable named \"sum_of_sum_of_divisors\"\n\n            # If the sum of the divisors of the sum of the divisors is equal to the original number,\n            # then the number is amicable\n            if sum_of_sum_of_divisors == number:\n                # Add the number to the collection of amicable numbers\n                add number to \"amicable_numbers\"\n\n    # Calculate the sum of all amicable numbers\n    calculate the sum of all numbers in \"amicable_numbers\" and store it in a variable named \"sum_of_amicable_numbers\"\n\n    # Return the sum of all amicable numbers\n    return sum_of_amicable_numbers",
    "123": "function get_angle(complex_number):\n    # Extract the real and imaginary parts of the complex number\n    extract the real part of complex_number and store it in a variable named \"real_part\"\n    extract the imaginary part of complex_number and store it in a variable named \"imaginary_part\"\n\n    # Calculate the angle using the formula for the angle of a complex number\n    calculate the angle of the complex number using the formula atan2(imaginary_part, real_part)\n\n    # Return the calculated angle\n    return the calculated angle",
    "124": "function max_difference_in_binary_string(binary_string):\n    # Initialize max_difference to negative infinity\n    max_difference = -infinity\n\n    # Initialize count of 0s and 1s\n    count_of_0s = 0\n    count_of_1s = 0\n\n    # Traverse through the given binary string\n    for each character in binary_string:\n        # If the character is '0'\n        if character is '0':\n            # Increment count_of_0s\n            increment count_of_0s by 1\n        else:\n            # Increment count_of_1s\n            increment count_of_1s by 1\n\n        # Update max_difference if current difference is more\n        if absolute value of (count_of_0s - count_of_1s) is greater than max_difference:\n            max_difference = absolute value of (count_of_0s - count_of_1s)\n\n    # Return max_difference\n    return max_difference",
    "125": "function find_sum_of_common_divisors(num1, num2):\n    # Create a variable to keep track of the sum of common divisors\n    create a variable named \"sum_of_divisors\" and set it to 0\n\n    # Loop through each number from 1 to the smaller of the two input numbers\n    for each number from 1 to the smaller of num1 and num2:\n        # Check if the current number is a divisor of both input numbers\n        if number divides both num1 and num2:\n            # If it is, add it to the sum of divisors\n            add number to \"sum_of_divisors\"\n\n    # Return the sum of divisors\n    return sum_of_divisors",
    "126": "function multiply(num1, num2):\n    # Initialize result\n    set result to 0\n\n    # While num2 is greater than 0\n    while num2 is greater than 0:\n        # Add num1 to result\n        add num1 to result\n\n        # Decrement num2 by 1\n        decrement num2 by 1\n\n    # Return result\n    return result",
    "127": "function shortlist_long_words(word_list, n):\n    # Create an empty list to store the long words\n    create an empty list named \"long_words\"\n\n    # Loop through each word in the word list\n    for each word in word_list:\n        # Check if the word's length is greater than n\n        if length of word is greater than n:\n            # If it is, add it to the list of long words\n            add word to \"long_words\"\n\n    # Return the list of long words\n    return \"long_words\"",
    "128": "function calculate_magic_square(n):\n    # Create an empty 2D array to hold the magic square\n    create a 2D array of size n x n named \"magic_square\"\n\n    # Initialize variables\n    set variable \"num\" to 1\n    set variable \"row\" to 0\n    set variable \"col\" to n/2\n\n    # Fill the magic square\n    while num <= n*n:\n        # If the current position is out of bounds, wrap around to the other side\n        if row < 0 or col < 0 or row >= n or col >= n or magic_square[row][col] != 0:\n            row += 2\n            col -= 1\n            if row >= n:\n                row -= n\n            if col < 0:\n                col += n\n\n        # Place the current number in the magic square\n        magic_square[row][col] = num\n\n        # Move to the next position\n        num += 1\n        row -= 1\n        col += 1\n\n    # Return the magic square\n    return magic_square",
    "129": "function find_max_frequency_item(input_list):\n    # Create an empty dictionary to keep track of item frequencies\n    create an empty dictionary named \"item_frequencies\"\n\n    # Loop through each item in the input list\n    for each item in input_list:\n        # Check if we've come across this item before\n        if item is already in \"item_frequencies\":\n            # If we have, increment its count\n            increment the count for item in \"item_frequencies\"\n        else:\n            # If it's a new item, add it to our dictionary with a count of 1\n            add item to \"item_frequencies\" with a count of 1\n\n    # Initialize variables to keep track of the item with the maximum frequency and its count\n    set max_frequency_item to the first item in \"item_frequencies\"\n    set max_frequency to the count for max_frequency_item in \"item_frequencies\"\n\n    # Loop through each item in the dictionary\n    for each item in \"item_frequencies\":\n        # Check if this item's count is greater than the current max_frequency\n        if the count for item in \"item_frequencies\" is greater than max_frequency:\n            # If it is, update max_frequency_item and max_frequency\n            set max_frequency_item to item\n            set max_frequency to the count for item in \"item_frequencies\"\n\n    # Return the item with the maximum frequency\n    return max_frequency_item",
    "130": "function reverse_vowels(input_string):\n    # Create a list of vowels\n    create a list named \"vowels\" with the elements 'a', 'e', 'i', 'o', 'u', 'A', 'E', 'I', 'O', 'U'\n\n    # Create a list to hold the vowels in the input string\n    create an empty list named \"vowels_in_string\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is a vowel\n        if character is in \"vowels\":\n            # If it is, add it to our list of vowels in the string\n            add character to \"vowels_in_string\"\n\n    # Reverse the order of the vowels in our list\n    reverse the order of \"vowels_in_string\"\n\n    # Create a variable to hold the result\n    create a variable named \"result\" and set it to an empty string\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is a vowel\n        if character is in \"vowels\":\n            # If it is, get the next vowel from our reversed list and add it to our result\n            add the next element in \"vowels_in_string\" to \"result\"\n        else:\n            # If the character is not a vowel, add it to our result as is\n            add character to \"result\"\n\n    # Return the result\n    return \"result\"",
    "131": "function convert_tuple_to_string(input_tuple):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each element in the input tuple\n    for each element in input_tuple:\n        # Convert the element to a string and add it to the result\n        convert element to a string and add it to \"result\"\n\n        # If this isn't the last element, add a space to separate it from the next element\n        if this isn't the last element in the tuple:\n            add a space to \"result\"\n\n    # Return the result\n    return \"result\"",
    "132": "function calculate_sum_of_negative_numbers(list_of_numbers):\n    # Create a lambda function to check if a number is negative\n    create a lambda function named \"is_negative\" that takes a number as input and returns True if the number is negative and False otherwise\n\n    # Use the lambda function to filter out the negative numbers from the list\n    create a new list named \"negative_numbers\" that contains only the numbers from \"list_of_numbers\" that satisfy the condition \"is_negative(number)\"\n\n    # Calculate the sum of the negative numbers\n    create a variable named \"sum_of_negative_numbers\" and set it to the sum of the numbers in \"negative_numbers\"\n\n    # Return the sum of the negative numbers\n    return sum_of_negative_numbers",
    "133": "function check_last_element_after_operation(array, p):\n    # Perform the operation p times\n    for i in range(p):\n        # Perform the operation (for example, multiply by 2)\n        for j in range(len(array)):\n            array[j] = array[j] * 2\n\n    # Check if the last element of the array is even or odd\n    if array[-1] % 2 == 0:\n        return \"Even\"\n    else:\n        return \"Odd\"",
    "134": "function find_nth_hexagonal_number(n):\n    # Check if n is a positive integer\n    if n is not a positive integer:\n        # If not, return an error message\n        return \"Error: n must be a positive integer\"\n\n    # Calculate the nth hexagonal number using the formula n*(2n-1)\n    hexagonal_number = n*(2n-1)\n\n    # Return the nth hexagonal number\n    return hexagonal_number",
    "135": "function calculate_electricity_bill(unit_consumed, rate_per_unit):\n    # Calculate the total bill by multiplying the unit consumed by the rate per unit\n    total_bill = unit_consumed * rate_per_unit\n\n    # Return the total bill\n    return total_bill",
    "136": "function find_zero_ratio(array):\n    # Initialize a counter for zeroes\n    set a variable named \"zero_count\" to 0\n\n    # Loop through each number in the array\n    for each number in array:\n        # Check if the number is zero\n        if number is 0:\n            # If it is, increment the zero count\n            increment \"zero_count\" by 1\n\n    # Calculate the ratio of zeroes to the total numbers\n    set a variable named \"ratio\" to \"zero_count\" divided by the length of the array\n\n    # Return the ratio\n    return ratio",
    "137": "function check_sum_of_powers_of_2(number):\n    # Initialize a variable to keep track of the sum\n    initialize a variable named \"sum\" to 0\n\n    # Initialize a variable to keep track of the current power of 2\n    initialize a variable named \"power\" to 1\n\n    # Loop until the sum is greater than the number\n    while \"sum\" is less than \"number\":\n        # Add the current power of 2 to the sum\n        add \"power\" to \"sum\"\n\n        # Double the current power of 2\n        multiply \"power\" by 2\n\n    # If the sum is equal to the number, return True\n    if \"sum\" is equal to \"number\":\n        return True\n    else:\n        # If the sum is greater than the number, return False\n        return False",
    "138": "function find_circumference(radius):\n    # Calculate the circumference of a circle using the formula 2 * pi * radius\n    circumference = 2 * pi * radius\n\n    # Return the calculated circumference\n    return circumference",
    "139": "function extract_singly_occurring_elements(tuple_list):\n    # Create an empty dictionary to keep track of element counts\n    create an empty dictionary named \"element_counts\"\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Loop through each element in the tuple\n        for each element in tuple:\n            # If the element is already in the dictionary, increment its count\n            if element is already in \"element_counts\":\n                increment the count of element in \"element_counts\"\n            else:\n                # If it's a new element, add it to the dictionary with a count of 1\n                add element to \"element_counts\" with a count of 1\n\n    # Create an empty list to store the singly occurring elements\n    create an empty list named \"singly_occurring_elements\"\n\n    # Loop through each element in the dictionary\n    for each element in \"element_counts\":\n        # If the count of the element is 1, add it to the list of singly occurring elements\n        if the count of element in \"element_counts\" is 1:\n            add element to \"singly_occurring_elements\"\n\n    # Return the list of singly occurring elements\n    return \"singly_occurring_elements\"",
    "140": "function pancake_sort(list_to_sort):\n    # Create a variable to store the length of the list\n    set length_of_list to the length of list_to_sort\n\n    # Loop through each element in the list\n    for each element in list_to_sort:\n        # Find the index of the maximum element in the list\n        set max_index to the index of the maximum element in list_to_sort\n\n        # If the maximum element is not at the end of the list, flip the list to move it there\n        if max_index is not equal to length_of_list - 1:\n            flip list_to_sort from 0 to max_index\n\n        # Flip the list again to move the maximum element to the end\n        flip list_to_sort from 0 to length_of_list - 1\n\n        # Decrease the length of the list to sort\n        decrease length_of_list by 1\n\n    # Return the sorted list\n    return list_to_sort\n\nfunction flip(list_to_flip, start_index, end_index):\n    # Loop through the list from the start index to the end index\n    for each index from start_index to end_index:\n        # Swap the current element with the element at the end of the list\n        swap list_to_flip[index] with list_to_flip[end_index]\n\n        # Decrease the end index\n        decrease end_index by 1\n\n    # Return the flipped list\n    return list_to_flip",
    "141": "function count_same_pairs(list1, list2, list3):\n    # Create an empty collection to keep track of pairs we've seen\n    create an empty collection named \"seen_pairs\"\n\n    # Loop through each pair in the first two lists\n    for each pair in list1 and list2:\n        # Check if we've come across this pair before\n        if pair is already in \"seen_pairs\":\n            # If we have, this is the first repeated pair, so increment its count\n            increment the count of pair in \"seen_pairs\"\n        else:\n            # If it's a new pair, add it to our collection to remember it\n            add pair to \"seen_pairs\" with a count of 1\n\n    # Loop through each pair in the third list\n    for each pair in list3:\n        # Check if we've come across this pair before\n        if pair is already in \"seen_pairs\":\n            # If we have, this is the first repeated pair, so increment its count\n            increment the count of pair in \"seen_pairs\"\n        else:\n            # If it's a new pair, add it to our collection to remember it\n            add pair to \"seen_pairs\" with a count of 1\n\n    # Return the collection of pairs and their counts\n    return \"seen_pairs\"",
    "142": "function count_lists_in_tuple(input_tuple):\n    # Initialize a counter for the number of lists\n    set a variable named \"list_count\" to 0\n\n    # Loop through each element in the input tuple\n    for each element in input_tuple:\n        # Check if the element is a list\n        if type of element is list:\n            # If it is, increment the list count\n            increment \"list_count\" by 1\n\n    # Return the final count\n    return \"list_count\"",
    "143": "function sum_of_absolute_differences(array):\n    # Initialize sum to 0\n    initialize sum to 0\n\n    # Loop through each pair of elements in the array\n    for each pair of elements in array:\n        # Calculate the absolute difference between the pair\n        calculate the absolute difference between the pair\n\n        # Add the absolute difference to the sum\n        add the absolute difference to the sum\n\n    # Return the sum\n    return the sum",
    "144": "function find_max_difference(input_array):\n    # Check if the array has at least two elements\n    if the length of input_array is less than 2:\n        # If not, return a signal (like None or a message)\n        return None\n\n    # Initialize the minimum and maximum values to the first element of the array\n    initialize minimum_value to the first element of input_array\n    initialize maximum_value to the first element of input_array\n\n    # Loop through each element in the array\n    for each element in input_array:\n        # Check if the current element is less than the current minimum\n        if element is less than minimum_value:\n            # If it is, update the minimum value\n            update minimum_value to element\n        # Check if the current element is greater than the current maximum\n        else if element is greater than maximum_value:\n            # If it is, update the maximum value\n            update maximum_value to element\n\n    # Return the difference between the maximum and minimum values\n    return maximum_value - minimum_value",
    "145": "function find_ascii_value(input_string):\n    # Initialize a variable to keep track of the total ASCII value\n    set total_ascii_value to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Add the ASCII value of the character to the total\n        add the ASCII value of character to total_ascii_value\n\n    # Return the total ASCII value\n    return total_ascii_value",
    "146": "function find_max_path_sum(triangle):\n    # Start from the bottom of the triangle\n    for each row in triangle in reverse order:\n        # For each number in the row, add the maximum of the two below it\n        for each number in row:\n            # If the number is the last number in the row, it doesn't have a maximum\n            if number is the last number in row:\n                continue\n            # Otherwise, add the maximum of the two below it\n            else:\n                add the maximum of the two below it to the number\n\n    # The top number in the triangle is the maximum total path sum\n    return the top number in the triangle",
    "147": "function divide_number_into_parts(number):\n    # Convert the number into a string to easily access each digit\n    convert number to string and store it in \"number_string\"\n\n    # Initialize two empty strings to hold the two parts of the number\n    create an empty string named \"part1\"\n    create an empty string named \"part2\"\n\n    # Loop through each digit in the number\n    for each digit in number_string:\n        # If the sum of digits in part1 is less than or equal to the sum of digits in part2\n        if the sum of digits in part1 is less than or equal to the sum of digits in part2:\n            # Add the current digit to part1\n            add digit to part1\n        else:\n            # Add the current digit to part2\n            add digit to part2\n\n    # Convert the two parts back into numbers and return them\n    convert part1 and part2 back into numbers and return them\n\nThis pseudocode assumes that the number is a positive integer. If the number can be negative, the pseudocode would need to be modified to handle that case.",
    "148": "function find_longest_subsequence(input_array):\n    # Create a variable to keep track of the longest subsequence\n    create a variable named \"longest_subsequence\" and set it to 1\n\n    # Loop through each element in the input array\n    for each element in input_array:\n        # Create a variable to keep track of the current subsequence\n        create a variable named \"current_subsequence\" and set it to 1\n\n        # Loop through each subsequent element in the input array\n        for each subsequent element in input_array:\n            # Check if the difference between the current element and the subsequent element is 1\n            if the difference between element and subsequent element is 1:\n                # If it is, increment the current subsequence\n                increment \"current_subsequence\" by 1\n\n            # Check if the current subsequence is longer than the longest subsequence\n            if \"current_subsequence\" is greater than \"longest_subsequence\":\n                # If it is, update the longest subsequence\n                set \"longest_subsequence\" to \"current_subsequence\"\n\n    # Return the longest subsequence\n    return \"longest_subsequence\"",
    "149": "function is_number_present(number, sequence):\n    # Loop through each number in the sequence\n    for each number in sequence:\n        # Check if the current number is equal to the number we're looking for\n        if number equals number:\n            # If it is, return True\n            return True\n\n    # If we've checked all numbers and found no matches, return False\n    return False",
    "150": "function check_co_prime(num1, num2):\n    # Create a function to calculate the greatest common divisor (gcd)\n    function gcd(a, b):\n        while b != 0:\n            a, b = b, a % b\n        return a\n\n    # Check if the gcd of the two numbers is 1\n    if gcd(num1, num2) == 1:\n        # If it is, the numbers are co-prime\n        return True\n    else:\n        # If it's not, the numbers are not co-prime\n        return False",
    "151": "function merge_sort(input_array):\n    # If the input array has only one element, it is already sorted\n    if the length of input_array is 1:\n        return input_array\n\n    # Find the middle index of the array\n    middle_index = length of input_array divided by 2\n\n    # Split the array into two halves\n    left_half = elements from index 0 to middle_index in input_array\n    right_half = elements from middle_index+1 to end of input_array\n\n    # Recursively sort the two halves\n    sorted_left_half = merge_sort(left_half)\n    sorted_right_half = merge_sort(right_half)\n\n    # Merge the sorted halves\n    sorted_array = merge(sorted_left_half, sorted_right_half)\n\n    # Return the sorted array\n    return sorted_array\n\nfunction merge(left_half, right_half):\n    # Create an empty array to store the merged result\n    merged_array = []\n\n    # While there are elements in both halves\n    while there are elements in left_half and right_half:\n        # If the first element of the left half is smaller\n        if the first element of left_half is smaller than the first element of right_half:\n            # Add the first element of the left half to the merged array\n            add the first element of left_half to merged_array\n            # Remove the first element from the left half\n            remove the first element from left_half\n        else:\n            # Add the first element of the right half to the merged array\n            add the first element of right_half to merged_array\n            # Remove the first element from the right half\n            remove the first element from right_half\n\n    # If there are still elements in the left half, add them to the merged array\n    while there are elements in left_half:\n        add the first element of left_half to merged_array\n        remove the first element from left_half\n\n    # If there are still elements in the right half, add them to the merged array\n    while there are elements in right_half:\n        add the first element of right_half to merged_array\n        remove the first element from right_half\n\n    # Return the merged array\n    return merged_array",
    "152": "function find_vertex(a, b, c):\n    # Calculate the vertex of the parabola\n    vertex_x = -b / (2 * a)\n    vertex_y = -b^2 / (4 * a) + c\n\n    # Return the vertex as a tuple\n    return (vertex_x, vertex_y)",
    "153": "function extract_elements(two_dimensional_list, element_to_extract):\n    # Create an empty list to store the extracted elements\n    create an empty list named \"extracted_elements\"\n\n    # Loop through each sublist in the two dimensional list\n    for each sublist in two_dimensional_list:\n        # Loop through each element in the sublist\n        for each element in sublist:\n            # Check if the current element is the one we're looking for\n            if element is equal to element_to_extract:\n                # If it is, add it to our list of extracted elements\n                add element to \"extracted_elements\"\n\n    # Return the list of extracted elements\n    return \"extracted_elements\"",
    "154": "function toggle_even_bits(number):\n    # Create a mask to isolate the even bits\n    create a variable named \"mask\" and set it to 0xAAAAAAAA (in hexadecimal)\n\n    # Use the bitwise AND operator to isolate the even bits\n    isolate the even bits of the number using the \"mask\"\n\n    # Use the bitwise XOR operator to toggle the even bits\n    toggle the even bits of the number using the \"mask\"\n\n    # Return the modified number\n    return the modified number",
    "155": "function convert_tuple_to_integer(input_tuple):\n    # Create an empty list to store the converted values\n    create an empty list named \"converted_values\"\n\n    # Loop through each value in the input tuple\n    for each value in input_tuple:\n        # Try to convert the value to an integer\n        try to convert value to an integer\n            # If successful, add it to the list\n            add converted value to \"converted_values\"\n        except:\n            # If the conversion fails, skip this value\n            continue\n\n    # Convert the list back to a tuple and return it\n    return convert \"converted_values\" to a tuple",
    "156": "function reflect_run_length_encoding(input_list):\n    # Create an empty list to store the encoded list\n    create an empty list named \"encoded_list\"\n\n    # Initialize a counter to keep track of the current character and its count\n    initialize a variable named \"current_character\" to the first character in the input_list\n    initialize a variable named \"current_count\" to 1\n\n    # Loop through each character in the input list\n    for each character in input_list:\n        # If the current character is the same as the previous one\n        if character is the same as \"current_character\":\n            # Increment the count\n            increment \"current_count\" by 1\n        else:\n            # If it's a new character, add the previous character and its count to the encoded list\n            add a pair of \"current_character\" and \"current_count\" to \"encoded_list\"\n            # And reset the current character and count\n            set \"current_character\" to the new character\n            set \"current_count\" to 1\n\n    # After the loop, add the last character and its count to the encoded list\n    add a pair of \"current_character\" and \"current_count\" to \"encoded_list\"\n\n    # Return the encoded list\n    return \"encoded_list\"",
    "157": "function find_k_operations(input_list, k):\n    # Calculate the sum of all elements in the list\n    calculate the sum of all elements in \"input_list\" and store it in \"total_sum\"\n\n    # Calculate the length of the list\n    calculate the length of \"input_list\" and store it in \"list_length\"\n\n    # Calculate the average of all elements in the list\n    calculate the average of \"total_sum\" divided by \"list_length\" and store it in \"average\"\n\n    # Calculate the operations required to make all elements equal\n    calculate the absolute difference between each element in \"input_list\" and \"average\" and store it in \"difference\"\n\n    # Multiply the difference by k\n    multiply \"difference\" by k and store it in \"operations\"\n\n    # Return the number of operations required\n    return \"operations\"",
    "158": "function print_season(month, day):\n    # Create a dictionary to map months to seasons\n    create a dictionary named \"month_to_season\" with the following key-value pairs:\n    January -> Winter\n    February -> Winter\n    March -> Spring\n    April -> Spring\n    May -> Spring\n    June -> Summer\n    July -> Summer\n    August -> Summer\n    September -> Autumn\n    October -> Autumn\n    November -> Autumn\n    December -> Winter\n\n    # Get the season for the given month\n    season = get the value for month in \"month_to_season\"\n\n    # If the day is between 21 and 31 of the previous month, the season is the next one\n    if month is January and day is between 21 and 31:\n        season = get the value for December in \"month_to_season\"\n    else if month is February and day is between 21 and 31:\n        season = get the value for March in \"month_to_season\"\n    else if month is March and day is between 21 and 31:\n        season = get the value for April in \"month_to_season\"\n    else if month is April and day is between 21 and 30:\n        season = get the value for May in \"month_to_season\"\n    else if month is May and day is between 21 and 31:\n        season = get the value for June in \"month_to_season\"\n    else if month is June and day is between 21 and 30:\n        season = get the value for July in \"month_to_season\"\n    else if month is July and day is between 21 and 31:\n        season = get the value for August in \"month_to_season\"\n    else if month is August and day is between 21 and 31:\n        season = get the value for September in \"month_to_season\"\n    else if month is September and day is between 21 and 30:\n        season = get the value for October in \"month_to_season\"\n    else if month is October and day is between 21 and 31:\n        season = get the value for November in \"month_to_season\"\n    else if month is November and day is between 21 and 30:\n        season = get the value for December in \"month_to_season\"\n    else if month is December and day is between 21 and 31:\n        season = get the value for January in \"month_to_season\"\n\n    # Print the season\n    print \"The season is \" + season",
    "159": "function find_x_and_y(a, b, n):\n    # Create an empty collection to keep track of solutions\n    create an empty collection named \"solutions\"\n\n    # Loop through each possible value of x\n    for each x from 0 to n:\n        # Calculate the corresponding value of y\n        y = (n - a*x) / b\n\n        # Check if y is an integer\n        if y is an integer:\n            # If it is, this is a valid solution, so add it to our collection\n            add (x, y) to \"solutions\"\n\n    # If we've checked all possible x values and found no solutions, return a signal (like None or a message)\n    if \"solutions\" is empty:\n        return None\n    else:\n        # If we found solutions, return them\n        return \"solutions\"",
    "160": "function remove_elements_from_list(main_list, remove_list):\n    # Loop through each element in the remove_list\n    for each element in remove_list:\n        # If the element is in the main_list, remove it\n        if element is in main_list:\n            remove element from main_list\n\n    # Return the modified main_list\n    return main_list",
    "161": "function calculate_sum(n):\n    # Initialize sum to 0\n    set sum to 0\n\n    # Loop until n-x <= 0\n    while n > 0:\n        # Add n to sum\n        add n to sum\n\n        # Decrease n by 2\n        decrease n by 2\n\n    # Return the sum\n    return sum",
    "162": "function calculate_polygon_area(number_of_sides, length_of_side):\n    # Calculate the area of a regular polygon\n    # The formula for the area of a regular polygon is (n * s^2) / (4 * tan(\u03c0/n))\n    # where n is the number of sides and s is the length of a side\n\n    # Calculate the area\n    area = (number_of_sides * length_of_side^2) / (4 * tan(\u03c0/number_of_sides))\n\n    # Return the calculated area\n    return area",
    "163": "function check_sum_of_divisors(number):\n    # Create a variable to store the sum of divisors\n    create a variable named \"sum_of_divisors\" and initialize it to 0\n\n    # Loop through each number from 1 to the given number\n    for each number from 1 to number:\n        # Check if the given number is divisible by the current number\n        if number is divisible by current number:\n            # If it is, add the current number to the sum of divisors\n            add current number to \"sum_of_divisors\"\n\n    # Check if the sum of divisors is equal to the given number\n    if \"sum_of_divisors\" is equal to number:\n        # If it is, return True\n        return True\n    else:\n        # If it's not, return False\n        return False",
    "164": "function count_characters_at_same_position(input_string):\n    # Create a variable to keep track of the count\n    create a variable named \"count\" and set it to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is a letter\n        if character is a letter:\n            # If it is, check if it is at the same position in the alphabet as in the string\n            if the position of character in the alphabet is the same as the position of character in the string:\n                # If it is, increment the count\n                increment \"count\" by 1\n\n    # Return the count\n    return count",
    "165": "function count_pairs_with_even_xor(input_list):\n    # Initialize a counter to keep track of the number of pairs with an even XOR\n    initialize a counter named \"even_xor_pairs\" to 0\n\n    # Loop through each pair in the input list\n    for each pair in input_list:\n        # Calculate the XOR of the pair\n        calculate the XOR of the pair\n\n        # Check if the XOR is even\n        if the XOR is even:\n            # If it is, increment the counter\n            increment \"even_xor_pairs\" by 1\n\n    # Return the counter\n    return \"even_xor_pairs\"",
    "166": "function smallest_power_of_2(n):\n    # Initialize power to 1\n    power = 1\n\n    # Loop until power is greater than or equal to n\n    while power < n:\n        # Double the power\n        power = power * 2\n\n    # Return the final power\n    return power",
    "167": "function find_frequency(array, number):\n    # Initialize a counter to keep track of the frequency of the number\n    set counter to 0\n\n    # Loop through each element in the array\n    for each element in array:\n        # Check if the current element is equal to the number we're looking for\n        if element is equal to number:\n            # If it is, increment the counter\n            increment counter by 1\n\n    # After checking all elements, return the counter\n    return counter",
    "168": "function calculate_nth_pell_number(n):\n    # If n is 0, return 0\n    if n is 0:\n        return 0\n\n    # If n is 1, return 1\n    if n is 1:\n        return 1\n\n    # Initialize two variables to hold the first two Pell numbers\n    pell_number_minus_2 = 0\n    pell_number_minus_1 = 1\n\n    # Loop from 2 to n\n    for i from 2 to n:\n        # Calculate the current Pell number as the sum of the previous two\n        current_pell_number = pell_number_minus_2 + pell_number_minus_1 * 2\n\n        # Update the variables for the next iteration\n        pell_number_minus_2 = pell_number_minus_1\n        pell_number_minus_1 = current_pell_number\n\n    # Return the nth Pell number\n    return current_pell_number",
    "169": "function sum_numbers_in_range(list_of_numbers, start_index, end_index):\n    # Initialize a variable to keep track of the sum\n    set sum_of_numbers to 0\n\n    # Loop through the list of numbers from the start index to the end index\n    for each number in list_of_numbers from start_index to end_index:\n        # Add the current number to the sum\n        add number to sum_of_numbers\n\n    # Return the sum\n    return sum_of_numbers",
    "170": "function find_pentagon_perimeter(side_length):\n    # Calculate the perimeter of a pentagon\n    perimeter = 5 * side_length\n\n    # Return the calculated perimeter\n    return perimeter",
    "171": "function find_occurrences_of_std(input_string):\n    # Create a variable to keep track of the count of 'std'\n    create a variable named \"count\" and set it to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the current character is 's'\n        if character is 's':\n            # If it is, check the next character\n            if the next character is 't':\n                # If the next character is 't', check the character after that\n                if the next character is 'd':\n                    # If the next character is 'd', increment the count\n                    increment \"count\" by 1\n\n    # Return the count of 'std'\n    return count",
    "172": "function remove_non_alphanumeric_characters(input_string):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is alphanumeric\n        if character is alphanumeric:\n            # If it is, add it to the result string\n            add character to \"result\"\n\n    # Return the result string\n    return \"result\"",
    "173": "function group_pairs_into_dictionary(sequence_of_pairs):\n    # Create an empty dictionary to store the grouped pairs\n    create an empty dictionary named \"grouped_dictionary\"\n\n    # Loop through each pair in the sequence\n    for each pair in sequence_of_pairs:\n        # Split the pair into key and value\n        split pair into key and value\n\n        # Check if the key is already in the dictionary\n        if key is already in \"grouped_dictionary\":\n            # If it is, append the value to the list of values for that key\n            append value to \"grouped_dictionary\"[key]\n        else:\n            # If it's not, create a new list with the value and add it to the dictionary\n            create a new list with value and add it to \"grouped_dictionary\" with key\n\n    # Return the grouped dictionary\n    return \"grouped_dictionary\"",
    "174": "function verify_parentheses_validity(input_string):\n    # Create a stack to keep track of parentheses\n    create an empty stack named \"parentheses_stack\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If the character is an opening parenthesis, push it onto the stack\n        if character is an opening parenthesis:\n            push character onto \"parentheses_stack\"\n        # If the character is a closing parenthesis\n        else if character is a closing parenthesis:\n            # If the stack is empty, this is an invalid string of parentheses\n            if \"parentheses_stack\" is empty:\n                return False\n            # Otherwise, pop the top parenthesis off the stack\n            pop the top parenthesis from \"parentheses_stack\"\n\n    # If the stack is empty at the end, the string of parentheses is valid\n    if \"parentheses_stack\" is empty:\n        return True\n    # Otherwise, the string of parentheses is invalid\n    else:\n        return False",
    "175": "function find_perimeter(side1, side2, side3):\n    # Check if the inputs are valid (i.e., they are positive numbers)\n    if side1, side2, and side3 are all positive numbers:\n        # Calculate the perimeter\n        perimeter = side1 + side2 + side3\n        # Return the perimeter\n        return perimeter\n    else:\n        # If the inputs are not valid, return a signal (like None or a message)\n        return None",
    "176": "function find_lcm_in_range(start, end):\n    # Create a list to store the numbers whose lcm lies within the given range\n    create an empty list named \"numbers\"\n\n    # Loop through each number from 1 to 100\n    for each number from 1 to 100:\n        # Check if the lcm of the number and 100 is within the given range\n        if lcm(number, 100) is within the range (start, end):\n            # If it is, add the number to the list\n            add number to \"numbers\"\n\n    # Return the list of numbers\n    return \"numbers\"\n\n# Helper function to calculate the lcm of two numbers\nfunction lcm(a, b):\n    # Calculate the lcm using the formula lcm(a, b) = (a * b) / gcd(a, b)\n    return (a * b) / gcd(a, b)\n\n# Helper function to calculate the gcd of two numbers\nfunction gcd(a, b):\n    # Use the Euclidean algorithm to calculate the gcd\n    while b is not 0:\n        temp = b\n        b = a % b\n        a = temp\n    return a",
    "177": "function search_literals(input_string, literals_list):\n    # Create an empty collection to keep track of the found literals\n    create an empty collection named \"found_literals\"\n\n    # Loop through each literal in the literals list\n    for each literal in literals_list:\n        # Check if the literal is in the input string\n        if literal is in input_string:\n            # If it is, add it to our collection of found literals\n            add literal to \"found_literals\"\n\n    # Return the collection of found literals\n    return \"found_literals\"",
    "178": "function is_keith_number(n):\n    # Convert the number to a list of digits\n    convert n to a list of digits and call it \"digits\"\n\n    # Create a list to store the sequence\n    create an empty list named \"sequence\"\n\n    # Add the digits to the sequence\n    for each digit in \"digits\":\n        add digit to \"sequence\"\n\n    # Calculate the next number in the sequence\n    while the length of \"sequence\" is less than n:\n        calculate the next number in the sequence by adding the last n numbers in \"sequence\"\n        add the calculated number to \"sequence\"\n\n    # Check if the last number in the sequence is equal to the original number\n    if the last number in \"sequence\" is equal to n:\n        return True\n    else:\n        return False",
    "179": "function calculate_distance(point1, point2):\n    # Extract latitude and longitude from point1 and point2\n    extract latitude1 and longitude1 from point1\n    extract latitude2 and longitude2 from point2\n\n    # Convert latitude and longitude to radians\n    convert latitude1 and longitude1 to radians\n    convert latitude2 and longitude2 to radians\n\n    # Calculate the difference in latitude and longitude\n    calculate the difference in latitude as latitude2 - latitude1\n    calculate the difference in longitude as longitude2 - longitude1\n\n    # Calculate the Haversine distance\n    calculate the Haversine distance using the formula:\n    a = sin\u00b2(\u0394\u03c6/2) + cos \u03c61 \u22c5 cos \u03c62 \u22c5 sin\u00b2(\u0394\u03bb/2)\n    c = 2 \u22c5 atan2( \u221aa, \u221a(1\u2212a) )\n    d = R \u22c5 c\n    where R is the radius of the Earth (mean radius = 6,371km)\n\n    # Return the calculated distance\n    return the calculated distance",
    "180": "function find_longest_common_prefix(input_strings):\n    # Check if the input list is empty\n    if input_strings is empty:\n        # If it is, return an empty string as there are no common prefixes\n        return \"\"\n\n    # Assume the first string in the list is the longest common prefix\n    longest_common_prefix = input_strings[0]\n\n    # Loop through each string in the list\n    for each string in input_strings:\n        # Create a variable to store the current common prefix\n        current_common_prefix = \"\"\n\n        # Loop through each character in the current string and the longest common prefix\n        for each character in string and longest_common_prefix:\n            # If the characters match, add it to the current common prefix\n            if character is the same:\n                add character to current_common_prefix\n            else:\n                # If the characters don't match, break the loop\n                break\n\n        # Update the longest common prefix if the current common prefix is longer\n        if length of current_common_prefix is greater than length of longest_common_prefix:\n            longest_common_prefix = current_common_prefix\n\n    # Return the longest common prefix\n    return longest_common_prefix",
    "181": "function find_uppercase_lowercase_special_numeric(input_string):\n    # Import the 're' module for regular expressions\n    import re\n\n    # Define the regular expressions for each type of character\n    uppercase_regex = '[A-Z]'\n    lowercase_regex = '[a-z]'\n    special_regex = '[!@#$%^&*()_+\\-=\\[\\]{};:\"\\\\|,.<>\\/?]'\n    numeric_regex = '[0-9]'\n\n    # Use the 'findall' function from the 're' module to find all matches of each regex\n    uppercase_matches = re.findall(uppercase_regex, input_string)\n    lowercase_matches = re.findall(lowercase_regex, input_string)\n    special_matches = re.findall(special_regex, input_string)\n    numeric_matches = re.findall(numeric_regex, input_string)\n\n    # Return the matches as a dictionary\n    return {\n        'uppercase': uppercase_matches,\n        'lowercase': lowercase_matches,\n        'special': special_matches,\n        'numeric': numeric_matches\n    }",
    "182": "function count_distinct_pairs_with_difference_k(array, k):\n    # Create an empty collection to keep track of the numbers we've seen\n    create an empty collection named \"seen_numbers\"\n\n    # Initialize a counter for the number of distinct pairs\n    set a counter to 0\n\n    # Loop through each number in the array\n    for each number in array:\n        # Calculate the number we'd need to have in the array to make a pair with the current number\n        calculate the number we'd need to have in the array to make a pair with the current number\n\n        # Check if we've seen this number before\n        if the number is already in \"seen_numbers\":\n            # If we have, we've found a pair, so increment the counter\n            increment the counter\n        else:\n            # If it's a new number, add it to our collection to remember it\n            add the number to \"seen_numbers\"\n\n    # Return the counter, which will be the number of distinct pairs\n    return counter",
    "183": "function find_values_greater_than(list_of_values, specified_number):\n    # Create an empty list to store the values that are greater than the specified number\n    create an empty list named \"greater_values\"\n\n    # Loop through each value in the list\n    for each value in list_of_values:\n        # Check if the value is greater than the specified number\n        if value is greater than specified_number:\n            # If it is, add it to the list of greater values\n            add value to \"greater_values\"\n\n    # Return the list of values that are greater than the specified number\n    return \"greater_values\"",
    "184": "function find_focus_of_parabola(a, b, c):\n    # Calculate the focus of the parabola\n    focus_x = -b / (2 * a)\n    focus_y = -b^2 / (4 * a) + c\n\n    # Return the coordinates of the focus\n    return focus_x, focus_y",
    "185": "function search_strings_in_string(input_string, search_strings):\n    # Import the regular expression module\n    import re\n\n    # Create an empty list to store the results\n    results = []\n\n    # Loop through each search string\n    for search_string in search_strings:\n        # Use the regular expression search function to find matches\n        matches = re.findall(search_string, input_string)\n\n        # Add the matches to the results list\n        results.extend(matches)\n\n    # Return the results\n    return results",
    "186": "function find_longest_common_subsequence(sequence1, sequence2):\n    # Create a 2D array to store the lengths of common subsequences\n    create a 2D array named \"lengths\" with dimensions (length of sequence1 + 1) x (length of sequence2 + 1)\n\n    # Initialize the first row and column to 0\n    for each row in lengths:\n        set the first element of row to 0\n    for each column in lengths:\n        set the first element of column to 0\n\n    # Fill in the lengths array\n    for each row from 1 to length of sequence1:\n        for each column from 1 to length of sequence2:\n            if sequence1[row - 1] is equal to sequence2[column - 1]:\n                set lengths[row][column] to lengths[row - 1][column - 1] + 1\n            else:\n                set lengths[row][column] to maximum of lengths[row - 1][column] and lengths[row][column - 1]\n\n    # Create a string to store the longest common subsequence\n    create an empty string named \"common_subsequence\"\n\n    # Backtrack to find the longest common subsequence\n    set row to length of sequence1 and column to length of sequence2\n    while row is greater than 0 and column is greater than 0:\n        if sequence1[row - 1] is equal to sequence2[column - 1]:\n            add sequence1[row - 1] to the beginning of common_subsequence\n            decrement row and column by 1\n        else if lengths[row - 1][column] is greater than lengths[row][column - 1]:\n            decrement row by 1\n        else:\n            decrement column by 1\n\n    # Return the longest common subsequence\n    return common_subsequence",
    "187": "function check_product_of_squares(number):\n    # Create a variable to keep track of the square root of the number\n    create a variable named \"square_root\" and set it to the square root of the number\n\n    # Check if the square root is an integer\n    if square_root is an integer:\n        # If it is, the number can be represented by the product of two squares\n        return True\n    else:\n        # If it's not, the number can't be represented by the product of two squares\n        return False",
    "188": "function find_first_missing_positive(input_list):\n    # Create a set from the input list to quickly check if a number is in the list\n    create a set named \"numbers_set\" from input_list\n\n    # Start from 1 and keep incrementing until we find a number that's not in the list\n    for each number from 1 to infinity:\n        if number is not in \"numbers_set\":\n            return number\n\n    # If we've checked all numbers and found no missing numbers, return a signal (like None or a message)\n    return None",
    "189": "function count_integral_coordinates_in_square(square_coordinates):\n    # Initialize a counter for integral coordinates\n    initialize a variable named \"count\" to 0\n\n    # Loop through each coordinate in the square\n    for each coordinate in square_coordinates:\n        # Check if the coordinate is integral\n        if coordinate is integral:\n            # If it is, increment the counter\n            increment \"count\" by 1\n\n    # Return the final count\n    return count",
    "190": "function check_month_has_30_days(month_name):\n    # Create a list of months that have 30 days\n    create a list named \"months_with_30_days\" with the values \"April\", \"June\", \"September\", \"November\"\n\n    # Check if the given month name is in the list of months with 30 days\n    if month_name is in \"months_with_30_days\":\n        # If it is, return True\n        return True\n    else:\n        # If it's not, return False\n        return False",
    "191": "function check_string_for_letters_and_numbers(input_string):\n    # Initialize a flag to track whether we've seen a letter and a number\n    set a flag named \"has_letter\" to False\n    set a flag named \"has_number\" to False\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is a letter\n        if character is a letter:\n            # If it is, set the flag to True\n            set \"has_letter\" to True\n        # Check if the character is a number\n        if character is a number:\n            # If it is, set the flag to True\n            set \"has_number\" to True\n\n    # If we've seen at least one letter and one number, return True\n    if \"has_letter\" is True and \"has_number\" is True:\n        return True\n    else:\n        # If we've only seen one or no letters and numbers, return False\n        return False",
    "192": "function remove_duplicates(input_tuple):\n    # Create an empty list to store the unique elements\n    create an empty list named \"unique_elements\"\n\n    # Loop through each element in the input tuple\n    for each element in input_tuple:\n        # Check if the element is already in the unique_elements list\n        if element is not in \"unique_elements\":\n            # If it's not, add it to the list\n            add element to \"unique_elements\"\n\n    # Convert the list back into a tuple and return it\n    return convert \"unique_elements\" to a tuple",
    "193": "function convert_octal_to_decimal(octal_number):\n    # Initialize decimal number\n    decimal_number = 0\n\n    # Initialize base value\n    base = 1\n\n    # Loop through each digit in the octal number\n    for each digit in octal_number:\n        # Multiply the current digit by the base and add it to the decimal number\n        decimal_number = decimal_number + (digit * base)\n\n        # Double the base value\n        base = base * 8\n\n    # Return the final decimal number\n    return decimal_number",
    "194": "function find_first_position(sorted_array, target):\n    # Initialize the start and end indices of the search range\n    set start_index to 0\n    set end_index to the length of sorted_array - 1\n\n    # While the search range is not empty\n    while start_index <= end_index:\n        # Calculate the middle index of the search range\n        set mid_index to (start_index + end_index) / 2\n\n        # If the target is less than the middle element,\n        # the first occurrence of the target must be in the left half of the search range\n        if target is less than sorted_array[mid_index]:\n            set end_index to mid_index - 1\n        # If the target is greater than the middle element,\n        # the first occurrence of the target must be in the right half of the search range\n        else if target is greater than sorted_array[mid_index]:\n            set start_index to mid_index + 1\n        # If the target is equal to the middle element,\n        # we've found the first occurrence of the target\n        else:\n            # If the middle element is not the first element in the array\n            # and the previous element is not the target,\n            # the first occurrence of the target is found\n            if mid_index is not 0 and sorted_array[mid_index - 1] is not target:\n                return mid_index\n            # If the middle element is the first element in the array\n            # or the previous element is the target,\n            # the first occurrence of the target is in the left half of the search range\n            else:\n                set end_index to mid_index - 1\n\n    # If the target is not found in the array, return -1\n    return -1",
    "195": "function remove_tuples_of_length_k(tuple_list, k):\n    # Create an empty list to store the tuples that are not of length k\n    create an empty list named \"result\"\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Check if the length of the tuple is not equal to k\n        if length of tuple is not equal to k:\n            # If it's not of length k, add it to the result list\n            add tuple to \"result\"\n\n    # Return the result list\n    return \"result\"",
    "196": "function exponentiate_tuples(tuple1, tuple2):\n    # Initialize the result to 1\n    initialize result to 1\n\n    # Loop through each element in the first tuple\n    for each element in tuple1:\n        # Multiply the result by the element raised to the power of the corresponding element in the second tuple\n        result = result * (element ^ tuple2[index of element in tuple1])\n\n    # Return the final result\n    return result",
    "197": "function find_largest_triangle(ellipse_radius):\n    # Calculate the semi-major and semi-minor axes of the ellipse\n    semi_major_axis = ellipse_radius\n    semi_minor_axis = ellipse_radius / sqrt(2)\n\n    # Calculate the area of the ellipse\n    ellipse_area = pi * semi_major_axis * semi_minor_axis\n\n    # Calculate the area of the largest possible triangle inscribed in the ellipse\n    # This is the triangle with the largest area, which is a right triangle with the hypotenuse on the ellipse's major axis\n    largest_triangle_area = 0.5 * semi_major_axis * semi_major_axis\n\n    # Return the area of the largest triangle\n    return largest_triangle_area",
    "198": "function find_highest_power_of_2(number):\n    # Initialize a variable to keep track of the highest power of 2 found\n    initialize a variable named \"highest_power\" to 1\n\n    # Loop until we've found a power of 2 that's greater than the number\n    while highest_power is less than or equal to number:\n        # If we've found a power of 2 that's greater than the number, return it\n        if highest_power is greater than number:\n            return highest_power\n        # Otherwise, double the highest power of 2 found\n        else:\n            highest_power = highest_power * 2\n\n    # If we've checked all powers of 2 and found no matches, return a signal (like None or a message)\n    return None",
    "199": "function find_max_indexes(input_list):\n    # Create an empty list to store the maximum values\n    create an empty list named \"max_values\"\n\n    # Loop through each item in the input list\n    for each item in input_list:\n        # Check if this item is greater than any we've seen so far\n        if item is greater than all items in \"max_values\":\n            # If it is, clear the list of max values and add this item\n            clear \"max_values\"\n            add item to \"max_values\"\n        else if item is equal to all items in \"max_values\":\n            # If it's equal to any we've seen so far, add it to the list\n            add item to \"max_values\"\n\n    # Create an empty list to store the indexes of the max values\n    create an empty list named \"max_indexes\"\n\n    # Loop through each item in the input list\n    for each item in input_list:\n        # Check if this item is in the list of max values\n        if item is in \"max_values\":\n            # If it is, find its index in the input list and add it to the list of max indexes\n            find the index of item in input_list and add it to \"max_indexes\"\n\n    # Return the list of max indexes\n    return \"max_indexes\"",
    "200": "function check_same_elements(input_list):\n    # If the list is empty, return True\n    if input_list is empty:\n        return True\n\n    # Get the first element in the list\n    first_element = get the first element from input_list\n\n    # Loop through each element in the list\n    for each element in input_list:\n        # If the element is not the same as the first element, return False\n        if element is not equal to first_element:\n            return False\n\n    # If we've checked all elements and found they're all the same, return True\n    return True",
    "201": "function remove_even_characters(input_string):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the index of the character is odd\n        if the index of character in input_string is odd:\n            # If it is, add it to the result string\n            add character to \"result\"\n\n    # Return the result string\n    return \"result\"",
    "202": "function hamming_distance(integer1, integer2):\n    # Convert the integers to binary strings\n    convert integer1 to binary and store it in a variable named \"binary1\"\n    convert integer2 to binary and store it in a variable named \"binary2\"\n\n    # Initialize a counter for the hamming distance\n    create a variable named \"distance\" and set it to 0\n\n    # Loop through each bit in the binary strings\n    for each bit in binary1:\n        # If the bits are different, increment the distance\n        if bit in binary1 is different from bit in binary2:\n            increment \"distance\" by 1\n\n    # Return the final hamming distance\n    return \"distance\"",
    "203": "function count_occurrences(input_string, target_character):\n    # Initialize a counter to keep track of the number of times the target character appears\n    set a counter to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the current character is the target character\n        if character is equal to target_character:\n            # If it is, increment the counter\n            increment counter by 1\n\n    # After checking all characters, return the counter\n    return counter",
    "204": "function find_inversions(tuple_list):\n    # Create an empty list to store the inversions\n    create an empty list named \"inversions\"\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Loop through each element in the tuple\n        for each element in tuple:\n            # Check if the element is a number\n            if element is a number:\n                # If it is, check if it's a negative number\n                if element is a negative number:\n                    # If it is, add it to the inversions list\n                    add element to \"inversions\"\n\n    # Return the list of inversions\n    return \"inversions\"",
    "205": "function adjacent_element_concatenation(tuples):\n    # Create an empty list to store the concatenated strings\n    create an empty list named \"concatenated_strings\"\n\n    # Loop through each tuple in the input list\n    for each tuple in tuples:\n        # Loop through each element in the tuple\n        for each element in tuple:\n            # Convert the element to a string\n            convert element to string\n\n            # Check if the element is not the first one in the tuple\n            if element is not the first one in the tuple:\n                # Get the previous element\n                get the previous element\n\n                # Convert the previous element to a string\n                convert previous element to string\n\n                # Concatenate the previous and current elements\n                concatenate previous element and current element\n\n                # Add the concatenated string to the list\n                add concatenated string to \"concatenated_strings\"\n\n    # Return the list of concatenated strings\n    return concatenated_strings",
    "206": "function count_longest_repeating_subsequences(input_string):\n    # Create a dictionary to store the count of each substring\n    create a dictionary named \"substring_count\"\n\n    # Create a variable to store the maximum length of repeating subsequence\n    create a variable named \"max_length\" and initialize it to 0\n\n    # Create a variable to store the count of longest repeating subsequence\n    create a variable named \"max_count\" and initialize it to 0\n\n    # Loop through each substring in the input string\n    for each substring in all substrings of input_string:\n        # If the substring is not a single character and is repeated\n        if substring is not a single character and substring is repeated:\n            # Increment the count of the substring in the dictionary\n            increment the count of substring in \"substring_count\"\n\n            # If the length of the substring is greater than the maximum length\n            if length of substring is greater than \"max_length\":\n                # Update the maximum length and the count\n                update \"max_length\" to the length of substring\n                update \"max_count\" to the count of substring in \"substring_count\"\n\n            # If the length of the substring is equal to the maximum length\n            else if length of substring is equal to \"max_length\":\n                # Increment the count of the longest repeating subsequence\n                increment \"max_count\"\n\n    # Return the count of longest repeating subsequence\n    return \"max_count\"",
    "207": "function check_decimal_precision(input_string):\n    # Import the regex module\n    import regex\n\n    # Define the regular expression pattern for a decimal number with precision of 2\n    pattern = \"^\\d+\\.\\d{2}$\"\n\n    # Use the regex module to check if the input string matches the pattern\n    if regex.match(pattern, input_string):\n        # If it does, return True\n        return True\n    else:\n        # If it doesn't, return False\n        return False",
    "208": "function delete_and_insert(heap, new_item):\n    # Delete the smallest element from the heap\n    smallest_element = delete_min(heap)\n\n    # Insert the new item into the heap\n    insert(heap, new_item)\n\n    # Return the deleted smallest element\n    return smallest_element\n\nNote: The pseudocode assumes that the heap is a binary heap and the delete_min and insert functions are implemented accordingly.",
    "209": "function check_string_contains_only_certain_characters(input_string):\n    # Import the regex module\n    import regex\n\n    # Define the pattern for the characters we're interested in\n    pattern = '^[a-zA-Z0-9]*$'\n\n    # Check if the input string matches the pattern\n    if regex.match(pattern, input_string):\n        # If it does, return True\n        return True\n    else:\n        # If it doesn't, return False\n        return False",
    "210": "function count_numbers_with_set_bits(input_list):\n    # Initialize a counter to keep track of numbers with set bits\n    create a variable named \"count\" and set it to 0\n\n    # Loop through each number in the input list\n    for each number in input_list:\n        # Convert the number to binary and remove the '0b' prefix\n        convert number to binary and remove '0b' prefix\n\n        # Check if the 1st and 2nd bits are set\n        if the 1st bit is set and the 2nd bit is set:\n            # If they are, increment the counter\n            increment \"count\" by 1\n\n    # Return the final count\n    return \"count\"",
    "211": "function sum_of_fourth_power_of_natural_numbers(n):\n    # Initialize sum to 0\n    initialize sum to 0\n\n    # Loop from 1 to n\n    for i from 1 to n:\n        # Add the fourth power of i to the sum\n        add i^4 to sum\n\n    # Return the sum\n    return sum",
    "212": "function concatenate_tuples(tuple1, tuple2):\n    # Create an empty string to store the concatenated string\n    create an empty string named \"concatenated_string\"\n\n    # Loop through each string in the first tuple\n    for each string in tuple1:\n        # Add the string to the concatenated string\n        add string to \"concatenated_string\"\n\n    # Loop through each string in the second tuple\n    for each string in tuple2:\n        # Add the string to the concatenated string\n        add string to \"concatenated_string\"\n\n    # Return the concatenated string\n    return \"concatenated_string\"",
    "213": "function convert_radians_to_degrees(radians):\n    # Define the conversion factor\n    define the constant PI as 3.14159\n\n    # Perform the conversion\n    degrees = radians * (180 / PI)\n\n    # Return the result\n    return degrees",
    "214": "function decode_run_length_encoding(input_list):\n    # Create an empty list to store the decoded output\n    create an empty list named \"decoded_output\"\n\n    # Loop through each pair in the input list\n    for each pair in input_list:\n        # Extract the number and character from the pair\n        extract the first element of the pair and call it \"number\"\n        extract the second element of the pair and call it \"character\"\n\n        # Repeat the character \"number\" times and add it to the decoded output\n        repeat the character \"number\" times and add the result to \"decoded_output\"\n\n    # Return the decoded output\n    return \"decoded_output\"",
    "215": "function is_subset(subset, superset):\n    # Check if the subset is empty\n    if subset is empty:\n        # If it is, the subset is a subset of the superset\n        return True\n\n    # Check if the superset is empty\n    if superset is empty:\n        # If it is, the subset is not a subset of the superset\n        return False\n\n    # Check if the first element of the subset is in the superset\n    if first element of subset is in superset:\n        # If it is, remove the first element of the subset from the superset\n        remove first element of subset from superset\n        # Recursively check if the rest of the subset is a subset of the superset\n        return is_subset(rest of subset, superset)\n    else:\n        # If the first element of the subset is not in the superset, the subset is not a subset of the superset\n        return False",
    "216": "function find_first_repeated_character(input_string):\n    # Create an empty collection to keep track of characters we've seen\n    create an empty collection named \"seen_characters\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if we've come across this character before\n        if character is already in \"seen_characters\":\n            # If we have, this is the first repeated character, so return it\n            return character\n        else:\n            # If it's a new character, add it to our collection to remember it\n            add character to \"seen_characters\"\n\n    # If we've checked all characters and found no repeats, return a signal (like None or a message)\n    return None",
    "217": "function find_minimum_operations(num1, num2):\n    # Initialize a counter for the number of operations\n    initialize a variable named \"operations\" to 0\n\n    # While num1 is not equal to num2\n    while num1 is not equal to num2:\n        # If num1 is greater than num2\n        if num1 is greater than num2:\n            # Subtract the smaller number from the larger one\n            subtract the smaller number from the larger one\n        else:\n            # If num1 is less than num2\n            # Add the smaller number to the larger one\n            add the smaller number to the larger one\n\n        # Increment the counter for the number of operations\n        increment \"operations\" by 1\n\n    # Return the number of operations\n    return operations",
    "218": "function extract_max_min_k_elements(input_tuple, k):\n    # Check if k is less than 1 or greater than the length of the tuple\n    if k is less than 1 or k is greater than the length of input_tuple:\n        # If so, return an error message\n        return \"Invalid value for k\"\n\n    # Sort the tuple in ascending order\n    sorted_tuple = sort input_tuple in ascending order\n\n    # Extract the first k elements from the sorted tuple\n    max_elements = first k elements of sorted_tuple\n\n    # Extract the last k elements from the sorted tuple\n    min_elements = last k elements of sorted_tuple\n\n    # Return the max and min elements\n    return max_elements, min_elements",
    "219": "function replace_max_occurrences(input_string, max_occurrences, characters_to_replace):\n    # Create a dictionary to keep track of the occurrences of each character we're replacing\n    create an empty dictionary named \"occurrences\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If the character is one of the characters we're replacing\n        if character is in characters_to_replace:\n            # If it's not already in our dictionary, add it with a count of 1\n            if character is not in \"occurrences\":\n                add character to \"occurrences\" with a count of 1\n            # If it is in our dictionary, increment its count\n            else:\n                increment the count of character in \"occurrences\"\n\n    # Loop through each character in the input string again\n    for each character in input_string:\n        # If the character is one of the characters we're replacing\n        if character is in characters_to_replace:\n            # If the count of the character in our dictionary is less than max_occurrences\n            if the count of character in \"occurrences\" is less than max_occurrences:\n                # Replace the character with a colon\n                replace character with a colon in the input_string\n\n    # Return the modified string\n    return input_string",
    "220": "function find_first_even_number(list_of_numbers):\n    # Loop through each number in the list\n    for each number in list_of_numbers:\n        # Check if the number is even\n        if number is even:\n            # If it is, return the number\n            return number\n\n    # If we've checked all numbers and found no even numbers, return a signal (like None or a message)\n    return None",
    "221": "function check_same_data_type(input_tuple):\n    # Check if the tuple is empty\n    if input_tuple is empty:\n        # If it is, return False because there are no elements to check\n        return False\n\n    # Get the data type of the first element in the tuple\n    data_type_to_check = type of the first element in input_tuple\n\n    # Loop through each element in the tuple\n    for each element in input_tuple:\n        # Check if the element's data type matches the data type of the first element\n        if type of element is not equal to data_type_to_check:\n            # If it doesn't, return False because the elements are not all the same data type\n            return False\n\n    # If we've checked all elements and found no discrepancies, return True\n    return True",
    "222": "function find_majority_element(input_array):\n    # Calculate the length of the array\n    calculate the length of input_array and store it in variable \"length\"\n\n    # Calculate the majority element index\n    calculate the floor of length divided by 2 and store it in variable \"majority_index\"\n\n    # Return the element at the majority index\n    return the element at index majority_index in input_array",
    "223": "function count_set_bits(number):\n    # Initialize a counter for set bits\n    set_bit_count = 0\n\n    # Loop through each bit in the number\n    for each bit in number:\n        # Check if the bit is set (1)\n        if bit is 1:\n            # If it is, increment the set bit count\n            increment set_bit_count by 1\n\n    # Return the set bit count\n    return set_bit_count",
    "224": "function find_minimum_element(sorted_rotated_array):\n    # Initialize start and end pointers\n    start = 0\n    end = len(sorted_rotated_array) - 1\n\n    # If the array is not rotated, return the first element\n    if sorted_rotated_array[start] < sorted_rotated_array[end]:\n        return sorted_rotated_array[start]\n\n    # While the start pointer is less than the end pointer\n    while start <= end:\n        # Calculate the midpoint\n        mid = start + (end - start) // 2\n\n        # If the midpoint is smaller than the previous element, return it\n        if mid > 0 and sorted_rotated_array[mid] < sorted_rotated_array[mid - 1]:\n            return sorted_rotated_array[mid]\n\n        # If the midpoint is larger than the next element, return it\n        if mid < len(sorted_rotated_array) - 1 and sorted_rotated_array[mid] > sorted_rotated_array[mid + 1]:\n            return sorted_rotated_array[mid + 1]\n\n        # If the midpoint is larger than the start element, the minimum element is in the right half\n        if sorted_rotated_array[mid] >= sorted_rotated_array[start]:\n            start = mid + 1\n        # If the midpoint is smaller than the start element, the minimum element is in the left half\n        else:\n            end = mid - 1\n\n    # If we've checked all elements and found no repeats, return a signal (like None or a message)\n    return None",
    "225": "function remove_odd_indexed_characters(input_string):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the input string\n    for each index in range(0, length of input_string):\n        # Check if the index is even (i.e., the index is not odd)\n        if index is even:\n            # If it's even, add the character at this index to the result\n            add character at index in input_string to \"result\"\n\n    # Return the result string\n    return \"result\"",
    "226": "function find_minimum(num1, num2, num3):\n    # Check if num1 is less than num2\n    if num1 is less than num2:\n        # If num1 is less than num2, check if num1 is less than num3\n        if num1 is less than num3:\n            # If num1 is less than both num2 and num3, return num1\n            return num1\n        else:\n            # If num1 is not less than num2 but is less than num3, return num3\n            return num3\n    else:\n        # If num1 is not less than num2, check if num2 is less than num3\n        if num2 is less than num3:\n            # If num2 is less than num3, return num2\n            return num2\n        else:\n            # If num2 is not less than num3, return num3\n            return num3",
    "227": "function check_bits_unset(number, start, end):\n    # Create a mask to isolate the bits in the range we're interested in\n    create a variable named \"mask\" and set it to 0\n    for each bit in the range from start to end:\n        set the bit in \"mask\" to 1\n\n    # Apply the mask to the number\n    create a variable named \"masked_number\" and set it to the result of \"number AND mask\"\n\n    # If the masked number is 0, all the bits in the range were unset\n    if masked_number is 0:\n        return True\n    else:\n        return False",
    "228": "function rearrange_elements(input_array):\n    # Create two empty lists to hold the negative and positive numbers\n    create an empty list named \"negative_numbers\"\n    create an empty list named \"positive_numbers\"\n\n    # Loop through each element in the input array\n    for each element in input_array:\n        # Check if the element is negative\n        if element is less than 0:\n            # If it is, add it to the negative_numbers list\n            add element to \"negative_numbers\"\n        else:\n            # If it's not, add it to the positive_numbers list\n            add element to \"positive_numbers\"\n\n    # Combine the negative_numbers and positive_numbers lists into a single list\n    combine \"negative_numbers\" and \"positive_numbers\" into a new list named \"rearranged_array\"\n\n    # Return the rearranged_array\n    return \"rearranged_array\"",
    "229": "function replace_blank_spaces(input_string, replacement_character):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If the character is a blank space, replace it with the replacement character\n        if character is a blank space:\n            add replacement_character to \"result\"\n        else:\n            add character to \"result\"\n\n    # Return the result string\n    return \"result\"",
    "230": "function find_max_sum(triangle):\n    # Start at the bottom of the triangle\n    current_row = len(triangle) - 1\n    current_column = 0\n\n    # While we're not at the top of the triangle\n    while current_row > 0:\n        # If the number to the left is larger, move to that number\n        if triangle[current_row][current_column] > triangle[current_row][current_column + 1]:\n            current_column = current_column\n        else:\n            # If the number to the right is larger, move to that number\n            current_column = current_column + 1\n\n        # Move up a row\n        current_row = current_row - 1\n\n    # Return the number at the top of the triangle\n    return triangle[0][0]",
    "231": "function get_n_largest_items(dataset, n):\n    # Sort the dataset in descending order\n    sort dataset in descending order\n\n    # Return the first n items from the sorted dataset\n    return the first n items from dataset",
    "232": "function find_lateral_surface_area(radius, height):\n    # Calculate the lateral surface area of a cylinder\n    # The formula for the lateral surface area of a cylinder is 2*pi*radius*height\n    # So, we need to multiply 2 with pi, radius and height\n    # Store the result in a variable named \"lateral_surface_area\"\n    lateral_surface_area = 2 * pi * radius * height\n\n    # Return the lateral surface area\n    return lateral_surface_area",
    "233": "function find_volume_of_cube(side_length):\n    # Calculate the volume of the cube\n    volume = side_length * side_length * side_length\n\n    # Return the calculated volume\n    return volume",
    "234": "function set_even_bits(number):\n    # Create a variable to keep track of the current bit position\n    create a variable named \"bit_position\" and set it to 0\n\n    # Loop through each bit in the number\n    while bit_position is less than the number of bits in the number:\n        # Check if the current bit position is even\n        if bit_position modulo 2 equals 0:\n            # If it is, set the bit at this position in the number\n            set the bit at bit_position in the number to 1\n\n        # Move on to the next bit position\n        increment bit_position by 1\n\n    # Return the modified number\n    return number",
    "235": "function count_max_equilateral_triangles(base_length):\n    # Initialize a counter for the number of triangles\n    initialize a variable named \"triangle_count\" to 0\n\n    # While the base length is greater than or equal to 1\n    while base_length >= 1:\n        # Calculate the number of triangles that can be formed with the current base length\n        calculate the number of triangles that can be formed with the current base length\n        add the number of triangles to \"triangle_count\"\n\n        # Decrease the base length by 2\n        decrease the base length by 2\n\n    # Return the total number of triangles\n    return triangle_count",
    "236": "function check_occurrences(tuples):\n    # Create an empty dictionary to keep track of record occurrences\n    create an empty dictionary named \"record_occurrences\"\n\n    # Loop through each tuple in the input list of tuples\n    for each tuple in tuples:\n        # Extract the record from the tuple\n        extract the record from the tuple\n\n        # Check if we've come across this record before\n        if record is already in \"record_occurrences\":\n            # If we have, increment the count of this record\n            increment the count of record in \"record_occurrences\"\n        else:\n            # If it's a new record, add it to our dictionary with a count of 1\n            add record to \"record_occurrences\" with a count of 1\n\n    # Create an empty list to store records with similar occurrences\n    create an empty list named \"similar_records\"\n\n    # Loop through each record in \"record_occurrences\"\n    for each record in \"record_occurrences\":\n        # Check if the count of this record is more than 1\n        if the count of record in \"record_occurrences\" is more than 1:\n            # If it is, add the record to \"similar_records\"\n            add record to \"similar_records\"\n\n    # Return the list of records with similar occurrences\n    return \"similar_records\"",
    "237": "function count_non_empty_substrings(input_string):\n    # Initialize a variable to keep track of the count\n    set count to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Loop through each substring of the input string starting from the current character\n        for each substring in all substrings of input_string starting from character:\n            # If the substring is not empty, increment the count\n            if substring is not empty:\n                increment count by 1\n\n    # Return the final count\n    return count",
    "238": "function count_sequences(n, m):\n    # Create a list to store the count of sequences for each length\n    create a list named \"sequence_counts\" with n+1 elements, all initialized to 0\n\n    # Base case: there is only one sequence of length 1\n    set the first element of \"sequence_counts\" to 1\n\n    # Loop through each length from 2 to n\n    for i from 2 to n:\n        # For each length, calculate the count of sequences\n        for j from 2 to m:\n            # If the current element is less than or equal to the previous element,\n            # then the sequence is invalid, so skip it\n            if j <= 2*sequence_counts[i-1]:\n                continue\n            # Otherwise, add the count of sequences for the previous length to the current length\n            sequence_counts[i] += sequence_counts[i-1]\n\n    # Return the count of sequences for length n\n    return sequence_counts[n]",
    "239": "function replace_last_element(list1, list2):\n    # Check if list1 is not empty\n    if list1 is not empty:\n        # Remove the last element from list1\n        remove the last element from list1\n\n        # Add all elements of list2 to list1\n        for each element in list2:\n            add element to list1\n\n    # Return the modified list1\n    return list1",
    "240": "function generate_3d_array(dimensions):\n    # Create an empty 3d array\n    create an empty 3d array named \"array\"\n\n    # Loop through each dimension\n    for each dimension in dimensions:\n        # Create a 2d array with each element as '*'\n        create a 2d array named \"sub_array\" with each element as '*'\n\n        # Add the 2d array to the 3d array\n        add \"sub_array\" to \"array\"\n\n    # Return the 3d array\n    return \"array\"",
    "241": "function count_total_characters(input_string):\n    # Create a variable to keep track of the total characters\n    create a variable named \"total_characters\" and set it to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Increment the total characters count\n        increment \"total_characters\" by 1\n\n    # Return the total characters count\n    return \"total_characters\"",
    "242": "function sort_list_based_on_occurrence(input_list):\n    # Create an empty dictionary to keep track of the occurrences of each tuple\n    create an empty dictionary named \"occurrences\"\n\n    # Loop through each tuple in the input list\n    for each tuple in input_list:\n        # If the tuple is already in the dictionary, increment its count\n        if tuple is already in \"occurrences\":\n            increment the count of tuple in \"occurrences\"\n        else:\n            # If it's a new tuple, add it to the dictionary with a count of 1\n            add tuple to \"occurrences\" with a count of 1\n\n    # Sort the input list based on the counts in the dictionary\n    sort input_list based on the counts in \"occurrences\"\n\n    # Return the sorted list\n    return input_list",
    "243": "function find_next_perfect_square(input_number):\n    # Create a variable to store the next perfect square\n    create a variable named \"next_perfect_square\" and set it to 0\n\n    # Loop through each number starting from the input number\n    for each number starting from input_number:\n        # Check if the number is a perfect square\n        if number is a perfect square:\n            # If it is, set the next_perfect_square to this number\n            set next_perfect_square to number\n            # And break out of the loop\n            break\n\n    # Return the next perfect square\n    return next_perfect_square",
    "244": "function find_max_sum_bi_tonic_subsequence(input_array):\n    # Create two empty lists to keep track of increasing and decreasing sequences\n    create an empty list named \"increasing_sequence\"\n    create an empty list named \"decreasing_sequence\"\n\n    # Loop through each number in the input array\n    for each number in input_array:\n        # If the list is empty or the number is greater than the last number in the increasing sequence\n        if increasing_sequence is empty or number is greater than the last number in increasing_sequence:\n            # Add the number to the increasing sequence\n            add number to the end of increasing_sequence\n        else:\n            # Find the first number in increasing_sequence that is greater than or equal to number\n            find the index i in increasing_sequence where increasing_sequence[i] is greater than or equal to number\n            # Replace the number at index i with number\n            replace increasing_sequence[i] with number\n\n        # If the list is empty or the number is less than the last number in the decreasing sequence\n        if decreasing_sequence is empty or number is less than the last number in decreasing_sequence:\n            # Add the number to the decreasing sequence\n            add number to the end of decreasing_sequence\n        else:\n            # Find the first number in decreasing_sequence that is less than or equal to number\n            find the index i in decreasing_sequence where decreasing_sequence[i] is less than or equal to number\n            # Replace the number at index i with number\n            replace decreasing_sequence[i] with number\n\n    # The maximum sum of bi-tonic sub-sequence is the sum of the lengths of increasing_sequence and decreasing_sequence\n    return the sum of the lengths of increasing_sequence and decreasing_sequence",
    "245": "function babylonian_square_root(number):\n    # Initialize the guess to be the number divided by 2\n    guess = number / 2\n\n    # Loop until the guess is good enough\n    while True:\n        # Calculate the improved guess\n        improved_guess = (guess + number / guess) / 2\n\n        # If the guess is good enough, return it\n        if abs(guess - improved_guess) < 0.0001:\n            return improved_guess\n\n        # Otherwise, update the guess and continue\n        guess = improved_guess",
    "246": "function longest_palindromic_subsequence(input_string):\n    # Create a 2D array to store the lengths of the longest palindromic subsequences\n    create a 2D array named \"dp\" with dimensions equal to the length of the input string\n\n    # Initialize the dp array\n    for i from 0 to length of input_string:\n        for j from 0 to length of input_string:\n            if i == j:\n                dp[i][j] = 1\n            else:\n                dp[i][j] = 0\n\n    # Fill the dp array in a bottom-up manner\n    for cl from 2 to length of input_string:\n        for i from 0 to length of input_string - cl:\n            j = i + cl\n            if input_string[i] == input_string[j]:\n                dp[i][j] = dp[i + 1][j - 1] + 2\n            else:\n                dp[i][j] = max(dp[i + 1][j], dp[i][j - 1])\n\n    # Return the longest palindromic subsequence\n    return dp[0][length of input_string - 1]",
    "247": "function calculate_harmonic_sum(n):\n    # Initialize the sum to 0\n    initialize a variable named \"sum\" to 0\n\n    # Loop from 1 to n\n    for i from 1 to n:\n        # Add 1/i to the sum\n        add 1/i to \"sum\"\n\n    # Return the sum\n    return \"sum\"",
    "248": "function find_intersection_of_arrays(array1, array2):\n    # Create an empty list to store the intersection\n    create an empty list named \"intersection\"\n\n    # Use the lambda function to filter the arrays\n    for each element in array1:\n        if element is in array2:\n            add element to \"intersection\"\n\n    # Return the intersection\n    return \"intersection\"",
    "249": "function count_occurrences(tuple, element):\n    # Initialize a counter to keep track of the number of times the element appears\n    initialize a variable named \"counter\" to 0\n\n    # Loop through each item in the tuple\n    for each item in tuple:\n        # Check if the item is equal to the element we're looking for\n        if item is equal to element:\n            # If it is, increment the counter\n            increment \"counter\" by 1\n\n    # After checking all items, return the counter\n    return counter",
    "250": "function insert_before_each_element(input_list, element_to_insert):\n    # Create an empty list to store the result\n    create an empty list named \"result\"\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # Add the element to the result list\n        add element_to_insert to \"result\"\n        # Then add the original element to the result list\n        add element to \"result\"\n\n    # Return the result list\n    return \"result\"",
    "251": "function convert_complex_to_polar(complex_number):\n    # Extract the real and imaginary parts of the complex number\n    extract the real part of complex_number and store it in a variable named \"real_part\"\n    extract the imaginary part of complex_number and store it in a variable named \"imaginary_part\"\n\n    # Calculate the magnitude of the complex number\n    calculate the square root of (real_part^2 + imaginary_part^2) and store it in a variable named \"magnitude\"\n\n    # Calculate the phase of the complex number\n    calculate the arctangent of (imaginary_part / real_part) and store it in a variable named \"phase\"\n\n    # Return the magnitude and phase as a tuple\n    return (magnitude, phase)",
    "252": "function count_integers(input_list):\n    # Initialize a counter to keep track of the number of integers\n    initialize a variable named \"integer_count\" to 0\n\n    # Loop through each item in the input list\n    for each item in input_list:\n        # Check if the item is an integer\n        if item is an integer:\n            # If it is, increment the counter\n            increment \"integer_count\" by 1\n\n    # After checking all items, return the count of integers\n    return integer_count",
    "253": "function find_words_starting_with_a_or_e(input_string):\n    # Split the input string into words\n    split input_string into words\n\n    # Create an empty list to store the words we're interested in\n    create an empty list named \"words_starting_with_a_or_e\"\n\n    # Loop through each word in the list of words\n    for each word in words:\n        # Check if the word starts with 'a' or 'e'\n        if the first character of word is 'a' or 'e':\n            # If it does, add it to our list\n            add word to \"words_starting_with_a_or_e\"\n\n    # Return the list of words we found\n    return \"words_starting_with_a_or_e\"",
    "254": "function generate_combinations(number_of_colours):\n    # Define the three different colours\n    define the colours as \"red\", \"green\", \"blue\"\n\n    # Create an empty list to store the combinations\n    create an empty list named \"combinations\"\n\n    # Loop through the three colours\n    for each colour in colours:\n        # Loop the specified number of times\n        for each time in range(number_of_colours):\n            # Add the colour to the combinations list\n            add colour to combinations\n\n    # Return the combinations\n    return combinations",
    "255": "function count_primes(number):\n    # Create a variable to keep track of the count of prime numbers\n    create a variable named \"prime_count\" and set it to 0\n\n    # Loop through each number up to the given number\n    for each number from 2 to given number:\n        # Assume the current number is prime\n        create a variable named \"is_prime\" and set it to True\n\n        # Check if the current number is divisible by any number up to its square root\n        for each number from 2 to square root of current number:\n            if current number is divisible by number:\n                # If it is, the current number is not prime\n                set \"is_prime\" to False\n                break the loop\n\n        # If the current number is prime, increment the count\n        if \"is_prime\" is True:\n            increment \"prime_count\" by 1\n\n    # Return the count of prime numbers\n    return \"prime_count\"",
    "256": "function swap_numbers(a, b):\n    # Create a temporary variable to hold the value of a\n    create a variable named \"temp\" and set it equal to a\n\n    # Set a equal to b\n    set a equal to b\n\n    # Set b equal to the value of temp (which we stored the original value of a)\n    set b equal to temp\n\n    # Return the new values of a and b\n    return a and b",
    "257": "function count_odd_elements(input_list):\n    # Use the lambda function to create a new list that contains only the odd elements\n    create a new list named \"odd_elements\" by using the lambda function on input_list\n\n    # Count the number of elements in the new list\n    count the number of elements in \"odd_elements\" and store the result in a variable named \"count\"\n\n    # Return the count\n    return count\n\n# Example usage:\nprint(count_odd_elements([1, 2, 3, 4, 5]))  # Output: 3",
    "258": "function maximize_tuples(tuple1, tuple2):\n    # Initialize variables to store the maximum values of each tuple\n    max_tuple1 = 0\n    max_tuple2 = 0\n\n    # Loop through each element in the first tuple\n    for each element in tuple1:\n        # If the element is greater than the current maximum, update the maximum\n        if element > max_tuple1:\n            max_tuple1 = element\n\n    # Loop through each element in the second tuple\n    for each element in tuple2:\n        # If the element is greater than the current maximum, update the maximum\n        if element > max_tuple2:\n            max_tuple2 = element\n\n    # Return the maximum values of the two tuples\n    return max_tuple1, max_tuple2",
    "259": "function find_nth_newman_shanks_williams_prime(n):\n    # Create a list to store the prime numbers\n    create an empty list named \"prime_numbers\"\n\n    # Start from 2 (the first prime number)\n    set current_number to 2\n\n    # Loop until we've found n prime numbers\n    while the size of \"prime_numbers\" is less than n:\n        # Check if the current number is prime\n        if is_prime(current_number):\n            # If it is, add it to our list\n            add current_number to \"prime_numbers\"\n\n        # Move on to the next number\n        increment current_number by 1\n\n    # Return the nth prime number\n    return the last item in \"prime_numbers\"\n\n# Helper function to check if a number is prime\nfunction is_prime(number):\n    # Check if the number is less than 2 (it's not prime)\n    if number is less than 2:\n        return False\n\n    # Check if the number is divisible by any number up to its square root\n    for each number from 2 to the square root of number:\n        if number is divisible by the current number:\n            return False\n\n    # If we've checked all numbers and found no divisors, it's prime\n    return True",
    "260": "function divide_tuples(tuple1, tuple2):\n    # Create an empty list to store the results\n    create an empty list named \"results\"\n\n    # Loop through each element in the first tuple\n    for each element in tuple1:\n        # If the corresponding element in the second tuple is not zero\n        if element in tuple2 is not zero:\n            # Divide the elements and add the result to the list\n            add element / corresponding element in tuple2 to \"results\"\n        else:\n            # If the corresponding element in the second tuple is zero, add a message to the list\n            add \"Error: Division by zero\" to \"results\"\n\n    # Return the list of results\n    return \"results\"",
    "261": "function split_list(input_list, length_of_first_part):\n    # Check if the length of the first part is valid\n    if length_of_first_part is greater than the length of the input_list:\n        # If not, return an error message\n        return \"Error: Length of first part is greater than the length of the list.\"\n\n    # Create an empty list to hold the first part of the list\n    create an empty list named \"first_part\"\n\n    # Create an empty list to hold the second part of the list\n    create an empty list named \"second_part\"\n\n    # Loop through the input list\n    for each item in input_list:\n        # If the length of the first part is not yet reached\n        if the length of \"first_part\" is less than length_of_first_part:\n            # Add the item to the first part\n            add item to \"first_part\"\n        else:\n            # Add the item to the second part\n            add item to \"second_part\"\n\n    # Return the two parts of the list\n    return \"first_part\", \"second_part\"",
    "262": "function merge_dictionaries(dict1, dict2):\n    # Create a new dictionary to store the merged result\n    create a new dictionary named \"merged_dict\"\n\n    # Loop through each key-value pair in the first dictionary\n    for each key-value pair in dict1:\n        # Add the key-value pair to the merged dictionary\n        add key-value pair to \"merged_dict\"\n\n    # Loop through each key-value pair in the second dictionary\n    for each key-value pair in dict2:\n        # Check if the key already exists in the merged dictionary\n        if key from dict2 is already in \"merged_dict\":\n            # If it does, replace the value in the merged dictionary with the value from dict2\n            replace value in \"merged_dict\" with value from dict2\n        else:\n            # If it doesn't, add the key-value pair to the merged dictionary\n            add key-value pair to \"merged_dict\"\n\n    # Return the merged dictionary\n    return \"merged_dict\"",
    "263": "function calculate_dog_age_in_dog_years(dog_age_in_human_years):\n    # The first two years of a dog's life count as 10.5 human years each.\n    if dog_age_in_human_years is less than or equal to 2:\n        return dog_age_in_human_years * 10.5\n    # Each year after counts as 4 human years.\n    else:\n        return 21 + (dog_age_in_human_years - 2) * 4",
    "264": "function split_list_every_nth_element(input_list, n):\n    # Create an empty list to hold the split lists\n    create an empty list named \"split_lists\"\n\n    # Loop through the input list, splitting it every nth element\n    for each element in input_list:\n        # If the length of \"split_lists\" is 0 or the length of the last list in \"split_lists\" is equal to n\n        if length of \"split_lists\" is 0 or length of last list in \"split_lists\" is equal to n:\n            # Create a new list and add it to \"split_lists\"\n            create a new list and add it to \"split_lists\"\n\n        # Add the current element to the last list in \"split_lists\"\n        add element to last list in \"split_lists\"\n\n    # Return the \"split_lists\"\n    return \"split_lists\"",
    "265": "function find_lateral_surface_area(side_length):\n    # Calculate the lateral surface area of a cube\n    # The lateral surface area of a cube is 4 times the square of the side length\n    # So, the formula is 4 * side_length * side_length\n    # Return the result\n    return 4 * side_length * side_length",
    "266": "function sum_of_squares_of_first_n_odd_numbers(n):\n    # Initialize sum to 0\n    initialize sum to 0\n\n    # Initialize count to 0\n    initialize count to 0\n\n    # Initialize number to 1\n    initialize number to 1\n\n    # Loop until count is equal to n\n    while count is not equal to n:\n        # Add the square of the number to the sum\n        add the square of number to sum\n\n        # Increment the count\n        increment count by 1\n\n        # Increment the number by 2 to get the next odd number\n        increment number by 2\n\n    # Return the sum\n    return sum",
    "267": "function find_nth_star_number(n):\n    # Initialize the first two star numbers\n    let star1 = 0\n    let star2 = 1\n\n    # If n is 1, return star1\n    if n is 1:\n        return star1\n\n    # If n is 2, return star2\n    if n is 2:\n        return star2\n\n    # For n greater than 2, calculate the nth star number\n    for i from 3 to n:\n        let temp = star1 + star2\n        star1 = star2\n        star2 = temp\n\n    # Return the nth star number\n    return star2",
    "268": "function find_ascii_value(character):\n    # Use the built-in Python function ord() to find the ASCII value of the character\n    ascii_value = ord(character)\n\n    # Return the ASCII value\n    return ascii_value",
    "269": "function sum_even_numbers_at_even_positions(input_list):\n    # Initialize a variable to keep track of the sum\n    set sum_even_numbers to 0\n\n    # Loop through each number in the input list\n    for each index in range from 0 to length of input_list:\n        # Check if the index is even\n        if index is even:\n            # Check if the number at this index is even\n            if number at index is even:\n                # If it is, add it to the sum\n                add number at index to sum_even_numbers\n\n    # Return the sum\n    return sum_even_numbers",
    "270": "function sum_of_fifth_power_of_first_n_even_numbers(n):\n    # Initialize sum to 0\n    initialize sum to 0\n\n    # Initialize count to 0\n    initialize count to 0\n\n    # Initialize number to 2\n    initialize number to 2\n\n    # Loop until count is equal to n\n    while count is not equal to n:\n        # Add the fifth power of number to sum\n        add the fifth power of number to sum\n\n        # Increment count by 1\n        increment count by 1\n\n        # Increment number by 2 (to get the next even number)\n        increment number by 2\n\n    # Return the sum\n    return sum",
    "271": "function extract_last_element(list_of_tuples):\n    # Create an empty list to store the last elements\n    create an empty list named \"last_elements\"\n\n    # Loop through each tuple in the list of tuples\n    for each tuple in list_of_tuples:\n        # Extract the last element from the tuple\n        extract the last element from the tuple\n\n        # Add the last element to the list of last elements\n        add the last element to \"last_elements\"\n\n    # Return the list of last elements\n    return \"last_elements\"",
    "272": "function subtract_tuples(tuple1, tuple2):\n    # Check if the tuples have the same length\n    if length of tuple1 is not equal to length of tuple2:\n        # If not, return an error message\n        return \"Error: Tuples must have the same length\"\n\n    # Create an empty list to store the result\n    create an empty list named \"result\"\n\n    # Loop through each index in the tuples\n    for each index in range from 0 to length of tuple1:\n        # Subtract the corresponding elements in the tuples and add the result to the list\n        add tuple1[index] - tuple2[index] to \"result\"\n\n    # Return the list of results\n    return \"result\"",
    "273": "function sum_of_even_index_binomial_coefficients(n):\n    # Initialize sum to 0\n    initialize sum to 0\n\n    # Loop from 0 to n\n    for i from 0 to n:\n        # Calculate binomial coefficient at index i\n        calculate binomial coefficient at index i\n\n        # If index is even, add it to sum\n        if index is even:\n            add binomial coefficient to sum\n\n    # Return the sum\n    return sum",
    "274": "function find_last_removed_element_position(array):\n    # Create an empty collection to keep track of removed elements\n    create an empty collection named \"removed_elements\"\n\n    # Loop through each element in the array\n    for each element in array:\n        # Check if the element is in the array\n        if element is not in array:\n            # If it's not in the array, this is the last removed element, so return its position\n            return position of element in \"removed_elements\"\n        else:\n            # If it's in the array, add it to our collection to remember it\n            add element to \"removed_elements\"\n\n    # If we've checked all elements and found no removed elements, return a signal (like None or a message)\n    return None",
    "275": "function find_volume_of_cylinder(radius, height):\n    # Calculate the area of the base of the cylinder\n    area_of_base = calculate_area_of_circle(radius)\n\n    # Calculate the volume of the cylinder\n    volume = area_of_base * height\n\n    # Return the volume\n    return volume\n\nfunction calculate_area_of_circle(radius):\n    # Calculate the area of the circle\n    area = pi * radius^2\n\n    # Return the area\n    return area",
    "276": "function filter_dictionary_by_value(input_dictionary, filter_value):\n    # Create an empty dictionary to store the filtered results\n    create an empty dictionary named \"filtered_dictionary\"\n\n    # Loop through each key-value pair in the input dictionary\n    for each key-value pair in input_dictionary:\n        # Check if the value of the current key-value pair is equal to the filter value\n        if value of key-value pair is equal to filter_value:\n            # If it is, add the key-value pair to the filtered dictionary\n            add key-value pair to \"filtered_dictionary\"\n\n    # Return the filtered dictionary\n    return \"filtered_dictionary\"",
    "277": "function find_element_count(tuple_input):\n    # Create an empty dictionary to keep track of element counts\n    create an empty dictionary named \"element_counts\"\n\n    # Loop through each element in the tuple\n    for each element in tuple_input:\n        # If the element is already in the dictionary, increment its count\n        if element is already in \"element_counts\":\n            increment the count for element in \"element_counts\"\n        else:\n            # If it's a new element, add it to the dictionary with a count of 1\n            add element to \"element_counts\" with a count of 1\n\n    # Sort the dictionary by count in descending order\n    sort \"element_counts\" by count in descending order\n\n    # Loop through each element in the sorted dictionary\n    for each element in \"element_counts\":\n        # If the count of the element is less than the count of the previous element, return the count of the previous element\n        if the count of element is less than the count of the previous element:\n            return the count of the previous element\n\n    # If no element has a count less than the count of the previous element, return a signal (like None or a message)\n    return None",
    "278": "function find_nth_decagonal_number(n):\n    # Calculate the nth decagonal number using the formula n*(7n-5)/2\n    decagonal_number = n*(7*n-5)/2\n\n    # Return the nth decagonal number\n    return decagonal_number",
    "279": "function sequential_search(array, target):\n    # Loop through each element in the array\n    for each element in array:\n        # Check if the current element is the target\n        if element is equal to target:\n            # If it is, return the index of the element\n            return the index of the element\n\n    # If we've checked all elements and found no matches, return a signal (like None or a message)\n    return None",
    "280": "function check_unique_elements(input_list):\n    # Create an empty collection to keep track of elements we've seen\n    create an empty collection named \"seen_elements\"\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # Check if we've come across this element before\n        if element is already in \"seen_elements\":\n            # If we have, this list has repeated elements, so return False\n            return False\n        else:\n            # If it's a new element, add it to our collection to remember it\n            add element to \"seen_elements\"\n\n    # If we've checked all elements and found no repeats, return True\n    return True",
    "281": "function subtract_lists(list1, list2):\n    # Check if both lists have the same length\n    if length of list1 is not equal to length of list2:\n        # If not, return an error message\n        return \"Error: Lists must be of the same length\"\n\n    # Use the map function to apply a lambda function to each pair of corresponding elements in the two lists\n    result = map(lambda x, y: x - y, list1, list2)\n\n    # Convert the result to a list and return it\n    return list(result)",
    "282": "function check_frequency(input_string):\n    # Create a dictionary to keep track of the frequency of each digit\n    create an empty dictionary named \"digit_frequency\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is a digit\n        if character is a digit:\n            # If it is, increment the count for that digit in the dictionary\n            increment the count for character in \"digit_frequency\"\n\n    # Loop through each key in the dictionary\n    for each key in \"digit_frequency\":\n        # Check if the count for the key is greater than the key itself\n        if \"digit_frequency\"[key] > key:\n            # If it is, return False\n            return False\n\n    # If we've checked all keys and found no counts greater than the keys, return True\n    return True",
    "283": "function check_all_items_equal(input_list, target_string):\n    # Loop through each item in the input list\n    for each item in input_list:\n        # Check if the item is not equal to the target string\n        if item is not equal to target_string:\n            # If it's not, return False\n            return False\n\n    # If we've checked all items and found they're all equal, return True\n    return True",
    "284": "function match_string_with_ab(input_string):\n    # Create a regular expression pattern to match the string\n    create a pattern that matches a string with an 'a' followed by two to three 'b's\n\n    # Check if the input string matches the pattern\n    if input_string matches the pattern:\n        # If it does, return True\n        return True\n    else:\n        # If it doesn't, return False\n        return False",
    "285": "function find_largest_sum_contiguous_array(input_array, k):\n    # Calculate the total sum of the array\n    total_sum = sum(input_array)\n\n    # Calculate the sum of the array if it were repeated k times\n    repeated_sum = total_sum * k\n\n    # Initialize the maximum sum and the current sum\n    max_sum = -float('inf')\n    current_sum = 0\n\n    # Loop through the array k times\n    for i in range(k):\n        # Loop through each element in the array\n        for j in range(len(input_array)):\n            # Update the current sum\n            current_sum += input_array[j]\n\n            # Update the maximum sum if the current sum is greater\n            if current_sum > max_sum:\n                max_sum = current_sum\n\n            # If the current sum is negative, reset it to 0\n            if current_sum < 0:\n                current_sum = 0\n\n    # Return the maximum sum\n    return max_sum",
    "286": "function sum_of_squares_of_first_n_even_numbers(n):\n    # Initialize a variable to keep track of the sum\n    initialize a variable named \"sum\" to 0\n\n    # Initialize a variable to keep track of the count of even numbers\n    initialize a variable named \"count\" to 0\n\n    # Initialize a variable to keep track of the current number\n    initialize a variable named \"current_number\" to 1\n\n    # Loop until we've found n even numbers\n    while count < n:\n        # Check if the current number is even\n        if current_number is divisible by 2:\n            # If it is, add its square to the sum\n            add current_number squared to \"sum\"\n            # Increment the count of even numbers\n            increment \"count\" by 1\n\n        # Move on to the next number\n        increment \"current_number\" by 1\n\n    # Return the sum\n    return \"sum\"",
    "287": "function count_elements_with_modular_inverse(array, p):\n    # Initialize a counter to keep track of elements with modular inverse equal to itself\n    initialize a counter to 0\n\n    # Loop through each element in the array\n    for each element in array:\n        # Calculate the modular inverse of the element\n        calculate the modular inverse of the element modulo p\n\n        # Check if the modular inverse is equal to the element itself\n        if the calculated modular inverse equals the element:\n            # If it is, increment the counter\n            increment the counter\n\n    # Return the counter\n    return the counter",
    "288": "function calculate_odd_days(year):\n    # Create a variable to keep track of the number of odd days\n    create a variable named \"odd_days\" and set it to 0\n\n    # Loop through each month in the year\n    for each month in the year:\n        # Calculate the number of days in the month\n        calculate the number of days in the month\n\n        # If the number of days is odd, increment the \"odd_days\" counter\n        if the number of days is odd:\n            increment \"odd_days\" by 1\n\n    # Return the total number of odd days\n    return \"odd_days\"",
    "289": "function find_max_length_lists(list_of_lists):\n    # Initialize max_length to 0 and max_lists to an empty list\n    max_length = 0\n    max_lists = []\n\n    # Loop through each list in the list_of_lists\n    for each list in list_of_lists:\n        # If the length of the current list is greater than max_length\n        if length of list is greater than max_length:\n            # Update max_length and max_lists\n            max_length = length of list\n            max_lists = [list]\n        # If the length of the current list is equal to max_length\n        else if length of list is equal to max_length:\n            # Add the current list to max_lists\n            add list to max_lists\n\n    # Return max_lists\n    return max_lists",
    "290": "function count_ways_to_paint_fence(n, k):\n    # If there are no posts or no colors, return 0\n    if n == 0 or k == 0:\n        return 0\n\n    # If there is only one post, return k\n    if n == 1:\n        return k\n\n    # If there are only two posts, return k*k\n    if n == 2:\n        return k*k\n\n    # Create a list to store the number of ways to paint the fence\n    ways = [0]*(n+1)\n\n    # There are k ways to paint the first post\n    ways[1] = k\n\n    # There are k*k ways to paint the first two posts\n    ways[2] = k*k\n\n    # For each post from the third post to the nth post\n    for i from 3 to n:\n        # The number of ways to paint the post is the sum of the ways to paint the previous post and the ways to paint the previous two posts\n        ways[i] = (k-1)*(ways[i-1] + ways[i-2])\n\n    # Return the number of ways to paint the nth post\n    return ways[n]",
    "291": "function find_quotient(dividend, divisor):\n    # Check if divisor is zero\n    if divisor is equal to zero:\n        # If it is, raise an error\n        raise an error \"Division by zero is not allowed\"\n    else:\n        # If it's not, calculate the quotient\n        quotient = dividend / divisor\n        # Return the quotient\n        return quotient",
    "292": "function find_third_side(side1, side2):\n    # Calculate the square of the first side\n    square_side1 = side1 * side1\n\n    # Calculate the square of the second side\n    square_side2 = side2 * side2\n\n    # Calculate the square of the third side\n    square_side3 = square_side1 + square_side2\n\n    # Return the square root of the third side\n    return square_side3 ** 0.5",
    "293": "function find_max_value(input_list):\n    # Initialize max_value to the smallest possible value\n    set max_value to negative infinity\n\n    # Loop through each item in the input list\n    for each item in input_list:\n        # Check if the item is a number\n        if item is a number:\n            # If it's a number, check if it's greater than max_value\n            if item is greater than max_value:\n                # If it's greater, update max_value\n                set max_value to item\n\n    # Return the maximum value found\n    return max_value",
    "294": "function sum_of_divisors(number):\n    # Initialize the sum of divisors to 0\n    set sum_of_divisors to 0\n\n    # Loop from 1 to the number\n    for each integer i from 1 to number:\n        # Check if the number is divisible by i\n        if number is divisible by i:\n            # If it is, add i to the sum of divisors\n            add i to sum_of_divisors\n\n    # Return the sum of divisors\n    return sum_of_divisors",
    "295": "function count_inversions(input_array):\n    # Initialize count of inversions as 0\n    initialize count_of_inversions as 0\n\n    # Get the length of the array\n    get the length of input_array and store it in variable named \"length\"\n\n    # Run a nested loop to compare each element with every other element\n    for i from 0 to length - 1:\n        for j from i + 1 to length:\n            # If the element at i is greater than the element at j, increment the count of inversions\n            if input_array[i] > input_array[j]:\n                increment count_of_inversions by 1\n\n    # Return the count of inversions\n    return count_of_inversions",
    "296": "function flatten_nested_list(nested_list):\n    # Create an empty list to store the flattened list\n    create an empty list named \"flattened_list\"\n\n    # Loop through each item in the nested list\n    for each item in nested_list:\n        # If the item is a list, recursively flatten it\n        if item is a list:\n            add the result of flatten_nested_list(item) to \"flattened_list\"\n        else:\n            # If the item is not a list, add it to the flattened list\n            add item to \"flattened_list\"\n\n    # Return the flattened list\n    return \"flattened_list\"",
    "297": "function find_nested_elements(nested_list, main_list):\n    # Create an empty list to store the result\n    create an empty list named \"result\"\n\n    # Loop through each element in the nested list\n    for each element in nested_list:\n        # Check if the element is in the main list\n        if element is in main_list:\n            # If it is, add it to the result list\n            add element to \"result\"\n\n    # Return the result list\n    return \"result\"",
    "298": "function calculate_max_aggregate(list_of_tuples):\n    # Initialize a variable to keep track of the maximum aggregate\n    set max_aggregate to 0\n\n    # Loop through each tuple in the list\n    for each tuple in list_of_tuples:\n        # Calculate the aggregate of the current tuple\n        set aggregate to the sum of the elements in the tuple\n\n        # Check if this aggregate is greater than the current maximum aggregate\n        if aggregate is greater than max_aggregate:\n            # If it is, update the maximum aggregate\n            set max_aggregate to aggregate\n\n    # Return the maximum aggregate\n    return max_aggregate",
    "299": "function count_binary_sequences(n):\n    # Create a list to store the count of binary sequences\n    create a list named \"count\" with n+1 elements, all initialized to 0\n\n    # Initialize the first two elements of the list\n    count[0] = 1\n    count[1] = 2\n\n    # Loop through the rest of the list\n    for i from 2 to n:\n        # Update the count for each element\n        count[i] = 2 * count[i-1] + count[i-2]\n\n    # Return the count for the nth element\n    return count[n]",
    "300": "function find_depth_of_dictionary(input_dictionary):\n    # Initialize depth to 1\n    set depth to 1\n\n    # Loop through each value in the dictionary\n    for each value in input_dictionary.values():\n        # If the value is a dictionary, recursively find the depth of that dictionary\n        if value is a dictionary:\n            # Add 1 to the depth\n            depth = depth + 1\n            # Recursively call the function with the new dictionary\n            depth = find_depth_of_dictionary(value)\n\n    # Return the depth\n    return depth",
    "301": "function find_most_significant_bit(number):\n    # Convert the number to binary\n    convert number to binary\n\n    # Loop through each bit in the binary representation\n    for each bit in binary representation:\n        # Check if the bit is a 1\n        if bit is 1:\n            # If it is, return the bit\n            return bit\n\n    # If no 1s are found, return a signal (like None or a message)\n    return None",
    "302": "function check_inversion_count(type1_list, type2_list):\n    # Initialize count of inversions for both types\n    initialize count_type1_inversions to 0\n    initialize count_type2_inversions to 0\n\n    # Loop through each element in the first list\n    for each element in type1_list:\n        # Loop through each element in the second list\n        for each element in type2_list:\n            # If the current element in the first list is greater than the current element in the second list\n            if element in type1_list is greater than element in type2_list:\n                # Increment the count of inversions for the first type\n                increment count_type1_inversions by 1\n\n    # Loop through each element in the second list\n    for each element in type2_list:\n        # Loop through each element in the first list\n        for each element in type1_list:\n            # If the current element in the second list is greater than the current element in the first list\n            if element in type2_list is greater than element in type1_list:\n                # Increment the count of inversions for the second type\n                increment count_type2_inversions by 1\n\n    # If the counts of inversions for both types are equal\n    if count_type1_inversions is equal to count_type2_inversions:\n        # Return True\n        return True\n    else:\n        # Return False\n        return False",
    "303": "function find_element_after_rotations(list_of_elements, number_of_rotations, index_to_find):\n    # Calculate the effective rotation\n    effective_rotation = number_of_rotations % len(list_of_elements)\n\n    # Calculate the new index\n    new_index = (index_to_find + effective_rotation) % len(list_of_elements)\n\n    # Return the element at the new index\n    return list_of_elements[new_index]",
    "304": "function match_two_words_starting_with_p(list_of_words):\n    # Create an empty list to keep track of words starting with 'p'\n    create an empty list named \"words_starting_with_p\"\n\n    # Loop through each word in the list of words\n    for each word in list_of_words:\n        # Check if the word starts with 'p'\n        if word starts with 'p':\n            # If it does, add it to our list of words starting with 'p'\n            add word to \"words_starting_with_p\"\n\n    # If we have less than two words starting with 'p', return a signal (like None or a message)\n    if the length of \"words_starting_with_p\" is less than 2:\n        return None\n\n    # If we have two or more words starting with 'p', return the first two\n    return the first two words in \"words_starting_with_p\"",
    "305": "function max_sum_increasing_subsequence(input_array, k):\n    # Initialize variables\n    max_sum = 0\n    current_sum = 0\n    max_element = input_array[k]\n\n    # Loop through the array\n    for i in range(len(input_array)):\n        # If the current element is greater than the max_element\n        if input_array[i] > max_element:\n            # Add the current element to the current_sum\n            current_sum += input_array[i]\n            # If the current_sum is greater than max_sum, update max_sum\n            if current_sum > max_sum:\n                max_sum = current_sum\n        else:\n            # Reset the current_sum\n            current_sum = 0\n\n    # Return the max_sum\n    return max_sum",
    "306": "function get_colon_of_tuple(input_tuple):\n    # Check if the input is a tuple\n    if input_tuple is not a tuple:\n        # If it's not a tuple, return an error message\n        return \"Error: Input is not a tuple\"\n\n    # Check if the tuple has at least two elements\n    if the length of input_tuple is less than 2:\n        # If it doesn't, return an error message\n        return \"Error: Tuple has less than two elements\"\n\n    # Return the second element of the tuple\n    return the second element of input_tuple",
    "307": "function find_largest_products(list1, list2, number_of_products):\n    # Create an empty list to keep track of products\n    create an empty list named \"products\"\n\n    # Loop through each number in the first list\n    for each number in list1:\n        # Loop through each number in the second list\n        for each number in list2:\n            # Calculate the product of the two numbers\n            calculate the product of the two numbers\n\n            # Add the product to the list of products\n            add the product to the \"products\" list\n\n    # Sort the list of products in descending order\n    sort the \"products\" list in descending order\n\n    # Return the first \"number_of_products\" products from the sorted list\n    return the first \"number_of_products\" elements from the \"products\" list",
    "308": "function find_maximum(num1, num2):\n    # Check if num1 is greater than num2\n    if num1 is greater than num2:\n        # If it is, return num1\n        return num1\n    else:\n        # If num1 is not greater than num2, return num2\n        return num2",
    "309": "function convert_string_to_tuple(input_string):\n    # Create an empty list to store the characters\n    create an empty list named \"characters\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Add the character to the list\n        add character to \"characters\"\n\n    # Convert the list to a tuple\n    convert \"characters\" to a tuple\n\n    # Return the tuple\n    return the tuple",
    "310": "function set_left_most_unset_bit(number):\n    # Convert the number to binary\n    convert number to binary\n\n    # Loop through each bit in the binary representation\n    for each bit in binary representation:\n        # Check if the bit is unset (0)\n        if bit is 0:\n            # If it is, set it and return the new number\n            set bit to 1\n            convert binary back to number\n            return number\n\n    # If no unset bits are found, return the original number\n    return number",
    "311": "function find_volume_of_cone(radius, height):\n    # Calculate the volume of the cone\n    volume = (1/3) * pi * radius^2 * height\n\n    # Return the volume\n    return volume",
    "312": "function print_positive_numbers(list_of_numbers):\n    # Loop through each number in the list\n    for each number in list_of_numbers:\n        # Check if the number is positive\n        if number is greater than 0:\n            # If it is, print it\n            print number\n\n    # If we've checked all numbers and found no positive numbers, return a signal (like None or a message)\n    return None",
    "313": "function max_sum(grid):\n    # Initialize variables\n    n = length of grid\n    dp = array of size n initialized with 0\n\n    # Base cases\n    dp[0] = max(grid[0][0], grid[1][0])\n    if n > 1:\n        dp[1] = max(grid[0][1] + dp[0], grid[1][1])\n\n    # Dynamic programming\n    for i from 2 to n:\n        dp[i] = max(dp[i-2] + max(grid[0][i], grid[1][i]), dp[i-1])\n\n    # Return the maximum sum\n    return dp[n-1]",
    "314": "function find_max_length_even_word(input_string):\n    # Split the input string into words\n    split input_string into words\n\n    # Create an empty collection to keep track of even length words\n    create an empty collection named \"even_length_words\"\n\n    # Loop through each word in the list of words\n    for each word in words:\n        # Check if the length of the word is even\n        if length of word is even:\n            # If it is, add it to our collection of even length words\n            add word to \"even_length_words\"\n\n    # If we've checked all words and found no even length words, return a signal (like None or a message)\n    if \"even_length_words\" is empty:\n        return None\n    else:\n        # Otherwise, find the maximum length of the even length words\n        find the maximum length in \"even_length_words\"\n        return the maximum length",
    "315": "function find_last_occurrence(array, target):\n    # Initialize variables\n    set left to 0\n    set right to length of array - 1\n    set result to -1\n\n    # Loop until left is less than or equal to right\n    while left <= right:\n        # Calculate the middle index\n        set mid to (left + right) / 2\n\n        # If the middle element is equal to the target\n        if array[mid] equals target:\n            # Update result and move left to mid + 1\n            set result to mid\n            set left to mid + 1\n        else if array[mid] is less than target:\n            # Move left to mid + 1\n            set left to mid + 1\n        else:\n            # Move right to mid - 1\n            set right to mid - 1\n\n    # Return the result\n    return result",
    "316": "function reflect_modified_run_length_encoding(input_list):\n    # Create an empty list to store the result\n    create an empty list named \"result\"\n\n    # Create a variable to keep track of the current character and its count\n    create a variable named \"current_char\" and set it to the first character in the input list\n    create a variable named \"current_count\" and set it to 1\n\n    # Loop through the input list starting from the second character\n    for each character in input_list starting from the second character:\n        # If the current character is the same as the previous one\n        if character is the same as \"current_char\":\n            # Increment the count\n            increment \"current_count\" by 1\n        else:\n            # If it's a new character, add the previous character and its count to the result list\n            add \"current_char\" and \"current_count\" to \"result\"\n            # And then reset the current character and count\n            set \"current_char\" to the new character\n            set \"current_count\" to 1\n\n    # After the loop, add the last character and its count to the result list\n    add \"current_char\" and \"current_count\" to \"result\"\n\n    # Return the result list\n    return \"result\"",
    "317": "function find_max_volume(sum_of_sides):\n    # Initialize the maximum volume to 0\n    initialize max_volume to 0\n\n    # Loop through each possible length for the shortest side\n    for each length from 1 to sum_of_sides:\n        # Calculate the remaining sides\n        remaining_sum = sum_of_sides - length\n        # Calculate the possible maximum height and width\n        max_height = remaining_sum / 2\n        max_width = remaining_sum / 2\n\n        # Loop through each possible height and width\n        for each height from 1 to max_height:\n            for each width from 1 to max_width:\n                # Calculate the volume of the cuboid\n                volume = length * height * width\n\n                # If this volume is greater than the current maximum, update the maximum\n                if volume > max_volume:\n                    max_volume = volume\n\n    # Return the maximum volume\n    return max_volume",
    "318": "function find_five_characters_long_words(input_string):\n    # Import the regular expression module\n    import regular_expression_module\n\n    # Create a regular expression pattern to match five characters long words\n    create a regular expression pattern named \"pattern\" that matches five characters long words\n\n    # Use the findall function from the regular expression module to find all matches in the input string\n    find all matches in input_string that match \"pattern\"\n\n    # Return the matches\n    return the matches",
    "319": "function calculate_difference(n):\n    # Calculate the sum of the first n natural numbers\n    sum_of_numbers = 0\n    for i in range(1, n+1):\n        sum_of_numbers += i\n\n    # Calculate the sum of the squares of the first n natural numbers\n    sum_of_squares = 0\n    for i in range(1, n+1):\n        sum_of_squares += i*i\n\n    # Calculate the square of the sum of the first n natural numbers\n    square_of_sum = sum_of_numbers * sum_of_numbers\n\n    # Calculate the difference between the square of the sum and the sum of the squares\n    difference = square_of_sum - sum_of_squares\n\n    # Return the difference\n    return difference",
    "320": "function find_demlo_number(n):\n    # Check if n is less than 1\n    if n is less than 1:\n        # If it is, return an error message\n        return \"Error: Input must be a positive integer\"\n\n    # Initialize a variable to keep track of the current number\n    set current_number to 1\n\n    # Initialize a variable to keep track of the number of Demlo numbers found\n    set demlo_count to 0\n\n    # Loop until we've found n Demlo numbers\n    while demlo_count is less than n:\n        # Check if current_number is a Demlo number\n        if current_number is a Demlo number:\n            # If it is, increment the Demlo count\n            increment demlo_count by 1\n\n            # If we've found n Demlo numbers, return the current number\n            if demlo_count is equal to n:\n                return current_number\n\n        # Move on to the next number\n        increment current_number by 1\n\n    # If we've checked all numbers and found no repeats, return a signal (like None or a message)\n    return None",
    "321": "function find_min_indexes(input_list):\n    # Create an empty list to keep track of minimum values\n    create an empty list named \"min_indexes\"\n\n    # Initialize the minimum value to be the first element of the list\n    set the minimum value to be the first element of input_list\n\n    # Loop through each element in the input list\n    for each index in range from 0 to length of input_list:\n        # Check if the current element is less than the minimum value\n        if the element at index is less than the minimum value:\n            # If it is, update the minimum value and clear the list of previous minimum values\n            set the minimum value to be the element at index\n            clear \"min_indexes\"\n            add index to \"min_indexes\"\n        else if the element at index is equal to the minimum value:\n            # If it is, add the index to the list of minimum values\n            add index to \"min_indexes\"\n\n    # Return the list of minimum values\n    return min_indexes",
    "322": "function rearrange_alternating_positive_negative(input_array):\n    # Create two empty lists to hold positive and negative numbers\n    create an empty list named \"positive_numbers\"\n    create an empty list named \"negative_numbers\"\n\n    # Loop through each number in the input array\n    for each number in input_array:\n        # Check if the number is positive or negative\n        if number is positive:\n            # If it's positive, add it to the positive numbers list\n            add number to \"positive_numbers\"\n        else:\n            # If it's negative, add it to the negative numbers list\n            add number to \"negative_numbers\"\n\n    # Create an empty list to hold the rearranged array\n    create an empty list named \"rearranged_array\"\n\n    # Loop through each list of positive and negative numbers\n    for each list in \"positive_numbers\", \"negative_numbers\":\n        # Loop through each number in the list\n        for each number in list:\n            # Add the number to the rearranged array\n            add number to \"rearranged_array\"\n\n    # Return the rearranged array\n    return \"rearranged_array\"",
    "323": "function extract_sum_of_alternate_chains(tuple_list):\n    # Create a variable to keep track of the sum\n    create a variable named \"sum\" and set it to 0\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Add the sum of the tuple to our total sum\n        add the sum of the elements in the tuple to \"sum\"\n\n        # Skip the next tuple if there is one\n        skip the next tuple if it exists\n\n    # Return the total sum\n    return \"sum\"",
    "324": "function find_minimum_squares(number):\n    # Create a list to keep track of the squares\n    create an empty list named \"squares\"\n\n    # Loop from 1 to the square root of the number\n    for i from 1 to square root of number:\n        # Add the square of i to the list\n        add i squared to \"squares\"\n\n    # Create a list to keep track of the minimum number of squares\n    create an empty list named \"minimum_squares\"\n\n    # Loop through each square in the list\n    for each square in \"squares\":\n        # If the square is less than or equal to the number, add it to the list\n        if square is less than or equal to number:\n            add square to \"minimum_squares\"\n\n    # Return the length of the list\n    return length of \"minimum_squares\"",
    "325": "function get_most_occurrences_word(input_list):\n    # Create an empty dictionary to keep track of words and their occurrences\n    create an empty dictionary named \"word_counts\"\n\n    # Loop through each string in the input list\n    for each string in input_list:\n        # Split the string into words\n        split string into words\n\n        # Loop through each word in the list of words\n        for each word in words:\n            # Check if we've come across this word before\n            if word is already in \"word_counts\":\n                # If we have, increment its count\n                increment the count for word in \"word_counts\"\n            else:\n                # If it's a new word, add it to our dictionary with a count of 1\n                add word to \"word_counts\" with a count of 1\n\n    # Find the word with the highest count\n    find the word with the highest count in \"word_counts\"\n\n    # Return the word with the highest count\n    return the word with the highest count",
    "326": "function is_isosceles_triangle(side1, side2, side3):\n    # Check if all sides are equal\n    if side1 is equal to side2 and side2 is equal to side3:\n        return \"Equilateral triangle\"\n    # Check if any two sides are equal\n    else if side1 is equal to side2 or side1 is equal to side3 or side2 is equal to side3:\n        return \"Isosceles triangle\"\n    # If none of the above conditions are met, the triangle is scalene\n    else:\n        return \"Scalene triangle\"",
    "327": "function rotate_list_left(list, num_rotations):\n    # Calculate the effective number of rotations\n    effective_rotations = num_rotations % len(list)\n\n    # If there are no rotations, return the original list\n    if effective_rotations == 0:\n        return list\n\n    # Create a new list that is the concatenation of the end of the original list and the start\n    rotated_list = list[effective_rotations:] + list[:effective_rotations]\n\n    # Return the new list\n    return rotated_list",
    "328": "function count_negative_numbers(input_list):\n    # Initialize a counter to keep track of negative numbers\n    initialize a variable named \"negative_count\" to 0\n\n    # Loop through each number in the input list\n    for each number in input_list:\n        # Check if the number is negative\n        if number is less than 0:\n            # If it is, increment the counter\n            increment \"negative_count\" by 1\n\n    # After checking all numbers, return the count\n    return \"negative_count\"",
    "329": "function find_all_words_of_length(input_string, length):\n    # Import the regular expression module\n    import re\n\n    # Create a regular expression pattern to match words of the given length\n    pattern = \"\\b\\w{\" + length + \"}\\b\"\n\n    # Use the findall function from the re module to find all matches of the pattern in the input string\n    matches = re.findall(pattern, input_string)\n\n    # Return the list of matches\n    return matches",
    "330": "function count_unset_bits(number):\n    # Initialize a counter for unset bits\n    create a variable named \"unset_bits_count\" and set it to 0\n\n    # Convert the number to binary and remove the '0b' prefix\n    convert number to binary and assign it to a variable named \"binary_number\"\n\n    # Loop through each character in the binary number\n    for each character in binary_number:\n        # Check if the character is '0'\n        if character is '0':\n            # If it is, increment the unset bits count\n            increment \"unset_bits_count\" by 1\n\n    # Return the count of unset bits\n    return \"unset_bits_count\"",
    "331": "function count_character_frequency(input_string):\n    # Create an empty dictionary to keep track of character frequencies\n    create an empty dictionary named \"character_frequencies\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if we've come across this character before\n        if character is already in \"character_frequencies\":\n            # If we have, increment the count for this character\n            increment the count for character in \"character_frequencies\" by 1\n        else:\n            # If it's a new character, add it to our dictionary with a count of 1\n            add character to \"character_frequencies\" with a count of 1\n\n    # Return the dictionary of character frequencies\n    return \"character_frequencies\"",
    "332": "function sort_list_by_second_element(input_list):\n    # Create a new list to store the sorted list\n    create a new list named \"sorted_list\"\n\n    # Loop through each sublist in the input list\n    for each sublist in input_list:\n        # Add the sublist to the sorted list, sorted by the second element\n        add sublist to \"sorted_list\" sorted by the second element\n\n    # Return the sorted list\n    return \"sorted_list\"",
    "333": "function is_valid_triangle(side1, side2, side3):\n    # Check if all sides are greater than 0\n    if side1 <= 0 or side2 <= 0 or side3 <= 0:\n        return False\n\n    # Check if the sum of the lengths of any two sides is greater than the length of the third side\n    if side1 + side2 <= side3 or side1 + side3 <= side2 or side2 + side3 <= side1:\n        return False\n\n    # If all checks pass, the triangle is valid\n    return True",
    "334": "function sum_of_arithmetic_progression(first_term, common_difference, number_of_terms):\n    # Calculate the sum of an arithmetic progression using the formula: n/2 * (a + l)\n    sum = number_of_terms / 2 * (first_term + first_term + (number_of_terms - 1) * common_difference)\n\n    # Return the sum\n    return sum",
    "335": "function check_month_days(month_name):\n    # Create a list of months with 28 days\n    create a list named \"months_with_28_days\" with the following elements: \"February\", \"September\", \"November\", \"April\"\n\n    # Check if the given month name is in the list of months with 28 days\n    if month_name is in \"months_with_28_days\":\n        # If it is, return True\n        return True\n    else:\n        # If it's not, return False\n        return False",
    "336": "function match_word_at_end_of_string(input_string, word):\n    # Remove punctuation from the end of the input string\n    while the last character of input_string is a punctuation mark:\n        remove the last character from input_string\n\n    # Split the input string into words\n    split input_string into words\n\n    # Check if the last word in the list of words is the same as the word we're looking for\n    if the last word in the list of words is the same as word:\n        # If it is, return True\n        return True\n    else:\n        # If it's not, return False\n        return False",
    "337": "function count_substrings_with_same_first_and_last_characters(input_string):\n    # Initialize a counter to keep track of the number of substrings\n    initialize a counter named \"substring_count\" to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Loop through each substring starting from the current character\n        for each substring starting from character in input_string:\n            # Check if the first and last characters of the substring are the same\n            if the first character of substring is the same as the last character of substring:\n                # If they are, increment the counter\n                increment \"substring_count\" by 1\n\n    # Return the final count\n    return \"substring_count\"",
    "338": "function find_max_occurring_divisor(start, end, number):\n    # Create a dictionary to keep track of divisors and their counts\n    create an empty dictionary named \"divisor_counts\"\n\n    # Loop through each number in the interval\n    for each number in range from start to end:\n        # Check if the number is a divisor of the given number\n        if number is a divisor of number:\n            # If it is, increment the count for that divisor in our dictionary\n            increment the count for number in \"divisor_counts\"\n\n    # Find the divisor with the maximum count\n    find the maximum count in \"divisor_counts\"\n\n    # Return the divisor with the maximum count\n    return the divisor with the maximum count in \"divisor_counts\"",
    "339": "function find_sum_of_three_lowest_positive_numbers(list_of_numbers):\n    # Create an empty list to keep track of positive numbers\n    create an empty list named \"positive_numbers\"\n\n    # Loop through each number in the input list\n    for each number in list_of_numbers:\n        # Check if the number is positive\n        if number is greater than 0:\n            # If it is, add it to our list of positive numbers\n            add number to \"positive_numbers\"\n\n    # Sort the list of positive numbers in ascending order\n    sort \"positive_numbers\" in ascending order\n\n    # If there are less than three positive numbers, return a signal (like None or a message)\n    if the length of \"positive_numbers\" is less than 3:\n        return None\n\n    # If there are three or more positive numbers, calculate and return the sum of the three smallest\n    calculate the sum of the first three numbers in \"positive_numbers\"\n    return the sum",
    "340": "function convert_set_to_ordered_tuples(input_set):\n    # Create an empty list to store the ordered tuples\n    create an empty list named \"ordered_tuples\"\n\n    # Loop through each item in the input set\n    for each item in input_set:\n        # Convert the item to a tuple and add it to the list\n        convert item to a tuple and add it to \"ordered_tuples\"\n\n    # Sort the list of tuples in ascending order\n    sort \"ordered_tuples\" in ascending order\n\n    # Return the list of tuples\n    return \"ordered_tuples\"",
    "341": "function smallest_range(arrays):\n    # Create a priority queue to keep track of the smallest element from each array\n    create a priority queue named \"queue\"\n\n    # Create a variable to keep track of the maximum element we've seen so far\n    create a variable named \"max_seen\" and set it to negative infinity\n\n    # Loop through each array\n    for each array in arrays:\n        # Add the smallest element from the array to the queue\n        add the smallest element from array to \"queue\"\n\n        # Update the maximum element seen so far\n        if the maximum element from array is greater than \"max_seen\":\n            set \"max_seen\" to the maximum element from array\n\n    # Create a variable to keep track of the smallest range we've found\n    create a variable named \"smallest_range\" and set it to positive infinity\n\n    # Loop until the queue is empty\n    while \"queue\" is not empty:\n        # Dequeue the smallest element from the queue\n        dequeue the smallest element from \"queue\"\n\n        # Calculate the range from the smallest element to the maximum element seen so far\n        calculate the range from the smallest element to \"max_seen\"\n\n        # Update the smallest range if this range is smaller\n        if the range is smaller than \"smallest_range\":\n            set \"smallest_range\" to the range\n\n        # If the queue is not empty, add the next smallest element from the array to the queue\n        if \"queue\" is not empty:\n            add the next smallest element from the array to \"queue\"\n\n            # Update the maximum element seen so far\n            if the maximum element from the array is greater than \"max_seen\":\n                set \"max_seen\" to the maximum element from the array\n\n    # Return the smallest range\n    return \"smallest_range\"",
    "342": "function count_digits_and_letters(input_string):\n    # Initialize counters for digits and letters\n    set digit_count to 0\n    set letter_count to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is a digit\n        if character is a digit:\n            # If it is, increment the digit count\n            increment digit_count by 1\n        # Check if the character is a letter\n        else if character is a letter:\n            # If it is, increment the letter count\n            increment letter_count by 1\n\n    # Return the counts\n    return digit_count, letter_count",
    "343": "function count_odd_factors(start, end):\n    # Initialize a counter to keep track of numbers with odd factors\n    initialize a counter named \"odd_factor_count\" to 0\n\n    # Loop through each number in the given range\n    for each number in range from start to end:\n        # Initialize a counter for factors of the current number\n        initialize a counter named \"factor_count\" to 0\n\n        # Loop through each potential factor of the current number\n        for each potential_factor in range from 1 to number:\n            # Check if the potential factor divides the current number evenly\n            if number mod potential_factor equals 0:\n                # If it does, increment the factor count\n                increment \"factor_count\" by 1\n\n        # Check if the factor count is odd\n        if \"factor_count\" is odd:\n            # If it is, increment the odd factor count\n            increment \"odd_factor_count\" by 1\n\n    # Return the count of numbers with odd factors\n    return \"odd_factor_count\"",
    "344": "function find_difference_between_consecutive_numbers(input_list):\n    # Create an empty list to store the differences\n    create an empty list named \"differences\"\n\n    # Loop through each number in the input list\n    for each number in input_list:\n        # Check if this is not the first number in the list\n        if number is not the first number in the list:\n            # Calculate the difference between this number and the previous one\n            calculate the difference between number and the previous number\n\n            # Add the difference to our list of differences\n            add the difference to \"differences\"\n\n    # Return the list of differences\n    return \"differences\"",
    "345": "function e(n, k):\n    # Initialize the result to 1\n    result = 1\n\n    # Loop from 1 to n\n    for i from 1 to n:\n        # Multiply the result by i\n        result = result * i\n\n    # Return the result\n    return result",
    "346": "function count_squares_in_rectangle(length, width):\n    # Calculate the area of the rectangle\n    area = length * width\n\n    # Calculate the number of squares that can fit in the rectangle\n    # This is done by dividing the area by the area of a single square (which is 1x1)\n    number_of_squares = area / 1\n\n    # Return the number of squares\n    return number_of_squares",
    "347": "function count_sequences(values, length, sum):\n    # Create a list to store the count of sequences\n    create a list named \"count\" with length+1 elements, all initialized to 0\n\n    # Initialize the count of sequences with sum 0\n    set count[0] to 1\n\n    # Loop through each value in the values list\n    for each value in values:\n        # Loop from the end of the count list to the beginning\n        for i from length to 0:\n            # If the sum of the current sequence and the current value is less than or equal to the target sum\n            if count[i] > 0 and i + value <= sum:\n                # Increment the count of sequences with the sum i + value\n                increment count[i + value] by count[i]\n\n    # Return the count of sequences with the target sum\n    return count[sum]",
    "348": "function is_binary_string(input_string):\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is not 0 or 1\n        if character is not \"0\" and character is not \"1\":\n            # If it's not a 0 or 1, this is not a binary string, so return False\n            return False\n\n    # If we've checked all characters and found no non-binary characters, return True\n    return True",
    "349": "function minimize_string(input_string):\n    # Create an empty dictionary to keep track of character counts\n    create an empty dictionary named \"character_counts\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If the character is already in the dictionary, increment its count\n        if character is already in \"character_counts\":\n            increment the count for character in \"character_counts\"\n        else:\n            # If it's a new character, add it to the dictionary with a count of 1\n            add character to \"character_counts\" with a count of 1\n\n    # Create an empty string to hold the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If the character's count is more than 1, add it to the result string\n        if the count for character in \"character_counts\" is more than 1:\n            add character to \"result\"\n\n    # Return the result string\n    return \"result\"",
    "350": "function find_first_repeated_element(input_array, k):\n    # Create an empty dictionary to keep track of elements and their counts\n    create an empty dictionary named \"element_counts\"\n\n    # Loop through each element in the input array\n    for each element in input_array:\n        # Check if we've come across this element before\n        if element is already in \"element_counts\":\n            # If we have, increment its count\n            increment the count of element in \"element_counts\"\n        else:\n            # If it's a new element, add it to our dictionary with a count of 1\n            add element to \"element_counts\" with a count of 1\n\n        # Check if the count of this element is equal to k\n        if the count of element in \"element_counts\" is equal to k:\n            # If it is, this is the first element occurring k times, so return it\n            return element\n\n    # If we've checked all elements and found no elements occurring k times, return a signal (like None or a message)\n    return None",
    "351": "function check_unique_characters(input_string):\n    # Create an empty collection to keep track of characters we've seen\n    create an empty collection named \"seen_characters\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if we've come across this character before\n        if character is already in \"seen_characters\":\n            # If we have, this string has repeated characters, so return False\n            return False\n        else:\n            # If it's a new character, add it to our collection to remember it\n            add character to \"seen_characters\"\n\n    # If we've checked all characters and found no repeats, return True\n    return True",
    "352": "function remove_column(nested_list, column_index):\n    # Create a new list to hold the modified list\n    create a new list named \"modified_list\"\n\n    # Loop through each row in the nested list\n    for each row in nested_list:\n        # Create a new row to hold the modified row\n        create a new list named \"modified_row\"\n\n        # Loop through each column in the row\n        for each column in row:\n            # If the column index is not the one we want to remove, add it to the modified row\n            if column index is not equal to column_index:\n                add column to \"modified_row\"\n\n        # Add the modified row to the modified list\n        add \"modified_row\" to \"modified_list\"\n\n    # Return the modified list\n    return \"modified_list\"",
    "353": "function find_nth_term(first_term, common_difference, n):\n    # Calculate the nth term using the formula for an arithmetic progression\n    nth_term = first_term + (n - 1) * common_difference\n\n    # Return the nth term\n    return nth_term",
    "354": "function count_rectangles_in_circle(r):\n    # Calculate the area of the circle\n    area_of_circle = calculate_area_of_circle(r)\n\n    # Calculate the area of the rectangle\n    area_of_rectangle = calculate_area_of_rectangle(r)\n\n    # Calculate the number of rectangles\n    number_of_rectangles = area_of_circle / area_of_rectangle\n\n    # Return the number of rectangles\n    return number_of_rectangles\n\nfunction calculate_area_of_circle(r):\n    # Calculate the area of the circle\n    area = 3.14 * r * r\n\n    # Return the area of the circle\n    return area\n\nfunction calculate_area_of_rectangle(r):\n    # Calculate the area of the rectangle\n    area = 2 * r * r\n\n    # Return the area of the rectangle\n    return area",
    "355": "function find_third_angle(angle1, angle2):\n    # Check if the sum of the two angles is less than 180 degrees\n    if angle1 + angle2 < 180:\n        # If it is, calculate the third angle by subtracting the sum of the two angles from 180\n        third_angle = 180 - (angle1 + angle2)\n        # Return the third angle\n        return third_angle\n    else:\n        # If the sum of the two angles is not less than 180, return a message indicating that the triangle is not valid\n        return \"The triangle is not valid\"",
    "356": "function find_max_element(tuple_records):\n    # Initialize a variable to keep track of the maximum element\n    set max_element to the first element of the tuple_records\n\n    # Loop through each record in the tuple_records\n    for each record in tuple_records:\n        # Check if the current record is greater than the current max_element\n        if record is greater than max_element:\n            # If it is, update max_element to be the current record\n            set max_element to record\n\n    # After checking all records, return the max_element\n    return max_element",
    "357": "function find_modulo_division(list1, list2):\n    # Check if both lists are of the same length\n    if length of list1 is not equal to length of list2:\n        # If not, return an error message\n        return \"Error: Lists must be of the same length\"\n\n    # Use the map function to apply the lambda function to each pair of corresponding elements in the two lists\n    result = map(lambda x, y: x % y, list1, list2)\n\n    # Convert the result to a list and return it\n    return list(result)",
    "358": "function check_roots_twice(a, b, c):\n    # Calculate the roots of the quadratic equation\n    root1 = (-b + sqrt(b^2 - 4ac)) / 2a\n    root2 = (-b - sqrt(b^2 - 4ac)) / 2a\n\n    # Check if one root is twice the other\n    if root1 == 2 * root2 or root2 == 2 * root1:\n        return True\n    else:\n        return False",
    "359": "function find_nth_carol_number(n):\n    # Initialize the first two carol numbers\n    let first_number be 0\n    let second_number be 1\n\n    # If n is 1, return the first number\n    if n is 1:\n        return first_number\n\n    # If n is 2, return the second number\n    if n is 2:\n        return second_number\n\n    # For n greater than 2, calculate the nth carol number\n    for i from 3 to n:\n        let next_number be the sum of first_number and second_number\n        let first_number be the value of second_number\n        let second_number be the value of next_number\n\n    # Return the nth carol number\n    return next_number",
    "360": "function remove_empty_lists(list_of_lists):\n    # Create a new list to hold the lists that are not empty\n    create an empty list named \"non_empty_lists\"\n\n    # Loop through each list in the input list of lists\n    for each list in list_of_lists:\n        # Check if the list is not empty\n        if list is not empty:\n            # If it's not empty, add it to our new list\n            add list to \"non_empty_lists\"\n\n    # Return the new list of non-empty lists\n    return \"non_empty_lists\"",
    "361": "function find_max_occurrences(input_list):\n    # Create an empty dictionary to keep track of the occurrences of each item\n    create an empty dictionary named \"occurrences\"\n\n    # Loop through each item in the input list\n    for each item in input_list:\n        # If the item is already in our dictionary, increment its count\n        if item is already in \"occurrences\":\n            increment the count for item in \"occurrences\"\n        else:\n            # If it's a new item, add it to our dictionary with a count of 1\n            add item to \"occurrences\" with a count of 1\n\n    # Find the item with the maximum count\n    set max_count to 0\n    set max_item to None\n    for each item in \"occurrences\":\n        if the count for item in \"occurrences\" is greater than max_count:\n            set max_count to the count for item in \"occurrences\"\n            set max_item to item\n\n    # Return the item with the maximum count\n    return max_item",
    "362": "function add_k_to_each_element(tuple, k):\n    # Create an empty list to store the result\n    create an empty list named \"result\"\n\n    # Loop through each element in the tuple\n    for each element in tuple:\n        # Add k to the element and add the result to the list\n        add k to element and add the result to \"result\"\n\n    # Return the list\n    return \"result\"",
    "363": "function count_flips(binary_string):\n    # Initialize count of flips as 0\n    initialize count_flips as 0\n\n    # Initialize the expected character as the first character in the string\n    initialize expected_character as the first character in binary_string\n\n    # Traverse through the given binary string\n    for each character in binary_string:\n        # If the current character is not the expected character\n        if character is not equal to expected_character:\n            # Increment the count of flips\n            increment count_flips by 1\n\n        # Flip the expected character\n        if expected_character is '0':\n            expected_character = '1'\n        else:\n            expected_character = '0'\n\n    # Return the count of flips\n    return count_flips",
    "364": "function count_digits(number):\n    # Convert the number to a string\n    convert number to string and store it in a variable named \"number_string\"\n\n    # Return the length of the string, which is the number of digits\n    return the length of \"number_string\"",
    "365": "function find_largest_product(list_of_integers):\n    # Initialize the largest product to be the product of the first two elements\n    largest_product = list_of_integers[0] * list_of_integers[1]\n\n    # Loop through each pair of adjacent elements in the list\n    for i in range(len(list_of_integers) - 1):\n        # Calculate the product of the current pair\n        current_product = list_of_integers[i] * list_of_integers[i + 1]\n\n        # If the current product is larger than the largest product found so far,\n        # update the largest product\n        if current_product > largest_product:\n            largest_product = current_product\n\n    # Return the largest product found\n    return largest_product",
    "366": "function is_balanced(root):\n    # If the tree is empty, it's balanced\n    if root is None:\n        return True\n\n    # Calculate the height of the left and right subtrees\n    left_height = height(root.left)\n    right_height = height(root.right)\n\n    # If the absolute difference between the heights of the left and right subtrees is more than 1, the tree is not balanced\n    if abs(left_height - right_height) > 1:\n        return False\n\n    # If the left and right subtrees are balanced, and the tree itself is balanced, return True\n    return is_balanced(root.left) and is_balanced(root.right)\n\nfunction height(root):\n    # If the tree is empty, its height is 0\n    if root is None:\n        return 0\n\n    # Calculate the height of the left and right subtrees\n    left_height = height(root.left)\n    right_height = height(root.right)\n\n    # Return the maximum height between the left and right subtrees plus 1 (for the root)\n    return max(left_height, right_height) + 1",
    "367": "function repeat_tuple(tuple, n):\n    # Create an empty list to store the repeated tuples\n    create an empty list named \"repeated_tuples\"\n\n    # Repeat the tuple n times\n    for i from 1 to n:\n        # Add the tuple to the list\n        add tuple to \"repeated_tuples\"\n\n    # Return the list of repeated tuples\n    return \"repeated_tuples\"",
    "368": "function find_lateral_surface_area(length, width, height):\n    # Calculate the lateral surface area of the cuboid\n    lateral_surface_area = 2 * (length + width) * height\n\n    # Return the lateral surface area\n    return lateral_surface_area",
    "369": "function sort_tuple_by_float(input_tuple):\n    # Create a new list to store the sorted tuples\n    create an empty list named \"sorted_tuples\"\n\n    # Loop through each tuple in the input tuple\n    for each tuple in input_tuple:\n        # Add the tuple to the sorted_tuples list, sorted by the float element\n        add tuple to \"sorted_tuples\" sorted by the float element\n\n    # Return the sorted list of tuples\n    return \"sorted_tuples\"",
    "370": "function find_smallest_missing_element(sorted_array):\n    # Initialize the smallest missing element as 1\n    let smallest_missing_element be 1\n\n    # Loop through each element in the sorted array\n    for each element in sorted_array:\n        # If the current element is equal to the smallest missing element\n        if element is equal to smallest_missing_element:\n            # Increment the smallest missing element\n            increment smallest_missing_element\n        # If the current element is greater than the smallest missing element\n        else if element is greater than smallest_missing_element:\n            # Return the smallest missing element\n            return smallest_missing_element\n\n    # If we've checked all elements and found no missing elements, return the next number\n    return smallest_missing_element",
    "371": "function heap_sort(input_list):\n    # Create an empty list to store the sorted elements\n    create an empty list named \"sorted_list\"\n\n    # Create a heap queue from the input list\n    create a heap queue named \"heap_queue\" from input_list\n\n    # While the heap queue is not empty\n    while heap_queue is not empty:\n        # Remove the smallest element from the heap queue and add it to the sorted list\n        remove the smallest element from heap_queue and add it to sorted_list\n\n    # Return the sorted list\n    return sorted_list",
    "372": "function find_volume_of_cuboid(length, width, height):\n    # Calculate the volume of the cuboid\n    volume = length * width * height\n\n    # Return the calculated volume\n    return volume",
    "373": "function print_permutations(input_string):\n    # Create an empty list to store all permutations\n    create an empty list named \"permutations\"\n\n    # If the input string is empty, return an empty list\n    if input_string is empty:\n        return an empty list\n\n    # If the input string has only one character, return a list with that character\n    if input_string has only one character:\n        return a list with the input string\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Create a new string that excludes the current character\n        create a new string named \"new_string\" that is input_string with character removed\n\n        # Recursively generate all permutations of the new string\n        generate all permutations of \"new_string\" and add them to \"permutations\"\n\n    # Return all permutations\n    return \"permutations\"",
    "374": "function round_to_nearest_multiple(number, multiple):\n    # Calculate the remainder when the number is divided by the multiple\n    remainder = number % multiple\n\n    # If the remainder is less than half of the multiple, round down\n    if remainder < (multiple / 2):\n        return number - remainder\n    # If the remainder is greater than half of the multiple, round up\n    else:\n        return number + multiple - remainder",
    "375": "function remove_duplicates_and_replace(tuple_input, custom_value):\n    # Create an empty dictionary to keep track of elements we've seen\n    create an empty dictionary named \"seen_elements\"\n\n    # Create an empty list to store the result\n    create an empty list named \"result\"\n\n    # Loop through each element in the tuple\n    for each element in tuple_input:\n        # Check if we've come across this element before\n        if element is already in \"seen_elements\":\n            # If we have, add the custom value to the result\n            add custom_value to \"result\"\n        else:\n            # If it's a new element, add it to our dictionary to remember it\n            add element to \"seen_elements\"\n            # Also add the element to the result\n            add element to \"result\"\n\n    # Return the result as a tuple\n    return \"result\" as a tuple",
    "376": "function remove_all_occurrences(input_string, character_to_remove):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the current character is the one we want to remove\n        if character is not equal to character_to_remove:\n            # If it's not the character we want to remove, add it to the result string\n            add character to \"result\"\n\n    # Return the result string\n    return \"result\"",
    "377": "function shift_last_to_first(input_list):\n    # Check if the list is empty\n    if input_list is empty:\n        # If it is, return an empty list\n        return an empty list\n    else:\n        # If it's not, get the last element\n        get the last element from input_list and call it \"last_element\"\n\n        # Remove the last element from the list\n        remove the last element from input_list\n\n        # Add the last element to the front of the list\n        add \"last_element\" to the front of input_list\n\n        # Return the modified list\n        return input_list",
    "378": "function find_surface_area_of_cuboid(length, width, height):\n    # Calculate the surface area of the cuboid\n    surface_area = 2 * (length * width + width * height + height * length)\n\n    # Return the calculated surface area\n    return surface_area",
    "379": "function generate_2d_array(rows, columns):\n    # Create an empty 2D array\n    create an empty 2D array named \"array\"\n\n    # Loop through each row\n    for each row in range from 1 to rows:\n        # Create an empty list for the current row\n        create an empty list named \"row_list\"\n\n        # Loop through each column\n        for each column in range from 1 to columns:\n            # Add a placeholder value to the current row\n            add a placeholder value to \"row_list\"\n\n        # Add the completed row to the 2D array\n        add \"row_list\" to \"array\"\n\n    # Return the completed 2D array\n    return \"array\"",
    "380": "function sort_list_of_lists_by_index(list_of_lists, index):\n    # Create an empty list to store the sorted list\n    create an empty list named \"sorted_list\"\n\n    # Loop through each list in the list of lists\n    for each list in list_of_lists:\n        # Add the list to the sorted list at the correct index\n        add list to \"sorted_list\" at the index of the list's element at the given index\n\n    # Return the sorted list\n    return \"sorted_list\"",
    "381": "function find_rotations(array):\n    # Initialize start and end indices\n    start = 0\n    end = array.length - 1\n\n    # While start index is less than end index\n    while start <= end:\n        # If the array is already sorted, return 0\n        if array[start] <= array[end]:\n            return 0\n\n        # Find the mid index\n        mid = (start + end) / 2\n\n        # If mid element is smaller than previous element, it is the pivot\n        if array[mid] <= array[mid - 1]:\n            return mid\n\n        # If mid element is greater than next element, it is the pivot\n        if array[mid] >= array[mid + 1]:\n            return mid + 1\n\n        # If mid element is greater than the start element, the pivot is in the right half\n        if array[mid] >= array[start]:\n            start = mid + 1\n        # If mid element is smaller than the start element, the pivot is in the left half\n        else:\n            end = mid - 1\n\n    # If the array is not circularly sorted, return -1\n    return -1",
    "382": "function toggle_odd_bits(number):\n    # Create a mask to select odd bits\n    create a variable named \"mask\" and set it to 0xAA (in hexadecimal)\n\n    # Toggle the odd bits\n    set \"number\" to \"number\" XOR \"mask\"\n\n    # Return the result\n    return \"number\"",
    "383": "function find_frequency_of_smallest_value(array):\n    # Initialize a variable to keep track of the smallest value and its frequency\n    set smallest_value to the first element of the array\n    set frequency to 1\n\n    # Loop through the array\n    for each element in array:\n        # If the current element is smaller than the smallest value found so far\n        if element is smaller than smallest_value:\n            # Update the smallest value and reset the frequency\n            set smallest_value to element\n            set frequency to 1\n        # If the current element is equal to the smallest value\n        else if element is equal to smallest_value:\n            # Increment the frequency\n            increment frequency by 1\n\n    # Return the frequency of the smallest value\n    return frequency",
    "384": "function find_nth_perrin_number(n):\n    # Base cases\n    if n == 0:\n        return 3\n    if n == 1:\n        return 0\n    if n == 2:\n        return 2\n\n    # Recursive case\n    return find_nth_perrin_number(n - 2) + find_nth_perrin_number(n - 3)",
    "385": "function find_minimum_swaps(input_string):\n    # Create a variable to keep track of the number of unmatched left brackets\n    create a variable named \"unmatched_left_brackets\" and set it to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If the character is a left bracket\n        if character is \"(\":\n            # Increment the count of unmatched left brackets\n            increment \"unmatched_left_brackets\" by 1\n        # If the character is a right bracket\n        else if character is \")\":\n            # If there are unmatched left brackets, decrement the count\n            if \"unmatched_left_brackets\" is greater than 0:\n                decrement \"unmatched_left_brackets\" by 1\n            # If there are no unmatched left brackets, this is an extra right bracket\n            else:\n                # Increment the count of swaps needed to balance the brackets\n                increment \"swaps_needed\" by 1\n\n    # Return the number of swaps needed to balance the brackets\n    return \"swaps_needed\"",
    "386": "function check_hexadecimal_even_odd(hexadecimal_number):\n    # Convert the hexadecimal number to decimal\n    convert hexadecimal_number to decimal\n\n    # Check if the decimal number is even or odd\n    if decimal_number modulo 2 equals 0:\n        # If it's even, return \"even\"\n        return \"even\"\n    else:\n        # If it's odd, return \"odd\"\n        return \"odd\"",
    "387": "function find_highest_power_of_2(n):\n    # Initialize a variable to keep track of the highest power of 2 found\n    set highest_power_of_2 to 1\n\n    # While the highest power of 2 is less than or equal to n\n    while highest_power_of_2 is less than or equal to n:\n        # If the highest power of 2 is less than n, double it\n        if highest_power_of_2 is less than n:\n            highest_power_of_2 = highest_power_of_2 * 2\n\n    # Return the highest power of 2 that is less than or equal to n\n    return highest_power_of_2 / 2",
    "388": "function find_nth_lucas_number(n):\n    # If n is 0, return 2\n    if n is 0:\n        return 2\n\n    # If n is 1, return 1\n    if n is 1:\n        return 1\n\n    # Initialize two variables to hold the first two lucas numbers\n    lucas_n_minus_2 = 2\n    lucas_n_minus_1 = 1\n\n    # Loop from 2 to n\n    for i from 2 to n:\n        # Calculate the next lucas number\n        lucas_n = lucas_n_minus_2 + lucas_n_minus_1\n\n        # Update the variables for the next iteration\n        lucas_n_minus_2 = lucas_n_minus_1\n        lucas_n_minus_1 = lucas_n\n\n    # Return the n'th lucas number\n    return lucas_n",
    "389": "function insert_string_at_beginning_of_list(input_list, input_string):\n    # Create an empty list to store the modified items\n    create an empty list named \"modified_list\"\n\n    # Loop through each item in the input list\n    for each item in input_list:\n        # Concatenate the input string and the item, and add it to the modified list\n        add input_string + item to \"modified_list\"\n\n    # Return the modified list\n    return modified_list",
    "390": "function convert_to_nested_dictionary(list_of_lists):\n    # Create an empty dictionary to store the nested dictionary\n    create an empty dictionary named \"nested_dictionary\"\n\n    # Loop through each list in the list of lists\n    for each list in list_of_lists:\n        # Create a temporary dictionary to store the current list\n        create an empty dictionary named \"temp_dictionary\"\n\n        # Loop through each item in the current list\n        for each item in list:\n            # Add the item to the temporary dictionary\n            add item to \"temp_dictionary\"\n\n        # Add the temporary dictionary to the nested dictionary\n        add \"temp_dictionary\" to \"nested_dictionary\"\n\n    # Return the nested dictionary\n    return \"nested_dictionary\"",
    "391": "function max_sum(n):\n    # Base case: if n is less than or equal to 1, return n\n    if n <= 1:\n        return n\n\n    # Calculate the maximum sum using the given equation\n    max_sum = max(max_sum(n/2) + max_sum(n/3) + max_sum(n/4) + max_sum(n/5), n)\n\n    # Return the maximum sum\n    return max_sum",
    "392": "function find_list_with_max_length(list_of_lists):\n    # Sort the list of lists by length in descending order\n    sort list_of_lists by length in descending order\n\n    # Return the first list in the sorted list, which will be the list with the maximum length\n    return the first list in list_of_lists",
    "393": "function is_tuple_distinct(input_tuple):\n    # Create an empty collection to keep track of elements we've seen\n    create an empty collection named \"seen_elements\"\n\n    # Loop through each element in the input tuple\n    for each element in input_tuple:\n        # Check if we've come across this element before\n        if element is already in \"seen_elements\":\n            # If we have, this is not a distinct tuple, so return False\n            return False\n        else:\n            # If it's a new element, add it to our collection to remember it\n            add element to \"seen_elements\"\n\n    # If we've checked all elements and found no repeats, return True\n    return True",
    "394": "function find_first_non_repeated_character(input_string):\n    # Create two empty collections to keep track of characters we've seen and their counts\n    create an empty collection named \"seen_characters\"\n    create an empty collection named \"character_counts\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if we've come across this character before\n        if character is already in \"seen_characters\":\n            # If we have, increment the count for this character\n            increment the count for character in \"character_counts\"\n        else:\n            # If it's a new character, add it to our collection to remember it\n            add character to \"seen_characters\"\n            # And also add it to our count collection, with a count of 1\n            add character to \"character_counts\" with a count of 1\n\n    # Loop through each character in the input string again\n    for each character in input_string:\n        # Check if the count for this character is 1\n        if the count for character in \"character_counts\" is 1:\n            # If it is, this is the first non-repeated character, so return it\n            return character\n\n    # If we've checked all characters and found no non-repeats, return a signal (like None or a message)\n    return None",
    "395": "function check_start_end_same_character(input_string):\n    # Import the regular expression module\n    import regex\n\n    # Check if the first character of the string is the same as the last character\n    if regex.match(r'^(.)\\1*$', input_string):\n        # If it is, return True\n        return True\n    else:\n        # If it's not, return False\n        return False",
    "396": "function find_median(num1, num2, num3):\n    # Create a list of the three numbers\n    create a list named \"numbers\" with num1, num2, and num3\n\n    # Sort the list of numbers\n    sort the \"numbers\" list\n\n    # The median is the middle number in the sorted list\n    return the middle element of \"numbers\"",
    "397": "function compute_sum_of_digits(list_of_numbers):\n    # Create an empty list to store the sums\n    create an empty list named \"sums\"\n\n    # Loop through each number in the list\n    for each number in list_of_numbers:\n        # Convert the number to a string to easily access its digits\n        convert number to string\n\n        # Initialize a variable to keep track of the sum of the digits\n        set sum_of_digits to 0\n\n        # Loop through each character in the string representation of the number\n        for each character in string representation of number:\n            # Convert the character back to a digit and add it to the sum\n            convert character to digit\n            add digit to sum_of_digits\n\n        # Add the sum of the digits to the list of sums\n        add sum_of_digits to sums\n\n    # Return the list of sums\n    return sums",
    "398": "function bitwise_xor(tuple1, tuple2):\n    # Initialize an empty list to store the result\n    create an empty list named \"result\"\n\n    # Loop through each element in the tuples\n    for each element in tuple1:\n        # Perform the bitwise xor operation with the corresponding element in tuple2\n        perform the bitwise xor operation between element and the corresponding element in tuple2\n        add the result of the operation to \"result\"\n\n    # Return the result list\n    return \"result\"",
    "399": "function extract_frequency_of_unique_tuples(input_list):\n    # Create an empty dictionary to keep track of tuples and their frequencies\n    create an empty dictionary named \"tuple_frequencies\"\n\n    # Loop through each item in the input list\n    for each item in input_list:\n        # Convert the item to a tuple\n        convert item to a tuple\n\n        # Check if this tuple is already in our dictionary\n        if tuple is already in \"tuple_frequencies\":\n            # If it is, increment its frequency by 1\n            increment the frequency of tuple in \"tuple_frequencies\" by 1\n        else:\n            # If it's not, add it to our dictionary with a frequency of 1\n            add tuple to \"tuple_frequencies\" with a frequency of 1\n\n    # Return the dictionary of tuples and their frequencies\n    return \"tuple_frequencies\"",
    "400": "function index_wise_addition(tuple1, tuple2):\n    # Create an empty tuple to store the result\n    create an empty tuple named \"result\"\n\n    # Loop through each index in the tuples\n    for each index in range of length of tuple1:\n        # Add the elements at the current index in tuple1 and tuple2\n        add the sum of elements at index in tuple1 and tuple2 to \"result\"\n\n    # Return the result\n    return \"result\"",
    "401": "function compute_ncr_mod_p(n, r, p):\n    # Create a list to store factorials\n    create a list named \"fact\" with size n+1 and initialize all elements to 0\n\n    # Compute factorials\n    for i from 0 to n:\n        if i is 0:\n            set fact[i] to 1\n        else:\n            set fact[i] to (i * fact[i-1]) % p\n\n    # Compute ncr\n    compute ncr as (fact[n] / (fact[r] * fact[n-r])) % p\n\n    # Return ncr\n    return ncr",
    "402": "function is_valid_url(url):\n    # Import the re module for regular expressions\n    import re\n\n    # Define the regular expression pattern for a valid URL\n    pattern = \"^(http|https)://[a-zA-Z0-9-\\.]+\\.[a-zA-Z]{2,3}(/[a-zA-Z0-9-\\.]+)*$\"\n\n    # Use the match function to check if the url matches the pattern\n    if re.match(pattern, url):\n        # If it does, return True\n        return True\n    else:\n        # If it doesn't, return False\n        return False",
    "403": "function find_minimum(num1, num2):\n    # Check if num1 is less than num2\n    if num1 is less than num2:\n        # If it is, return num1\n        return num1\n    else:\n        # If num1 is not less than num2, return num2\n        return num2",
    "404": "function check_element_in_tuple(tuple, element):\n    # Loop through each item in the tuple\n    for each item in tuple:\n        # Check if the current item is equal to the element we're looking for\n        if item is equal to element:\n            # If it is, return True, indicating that the element exists in the tuple\n            return True\n\n    # If we've checked all items and found no matches, return False, indicating that the element does not exist in the tuple\n    return False",
    "405": "function find_parity(number):\n    # Initialize a variable to keep track of the number of 1s in the binary representation of the number\n    initialize a variable named \"ones_count\" to 0\n\n    # Convert the number to binary and loop through each bit\n    for each bit in binary representation of number:\n        # If the bit is 1, increment the ones_count\n        if bit is 1:\n            increment \"ones_count\" by 1\n\n    # If the number of 1s is even, the number is even\n    if \"ones_count\" is even:\n        return \"Even\"\n    else:\n        # If the number of 1s is odd, the number is odd\n        return \"Odd\"",
    "406": "function next_bigger_number(number):\n    # Convert the number to a list of digits\n    convert number to a list of digits named \"digits\"\n\n    # Find the first digit from the right that is smaller than the digit to its right\n    for each digit in \"digits\" from right to left:\n        if digit is smaller than the digit to its right:\n            break\n\n    # If no such digit is found, return -1\n    if no such digit is found:\n        return -1\n\n    # Find the smallest digit on the right of the found digit that is larger than it\n    for each digit in \"digits\" from right to left:\n        if digit is larger than the found digit:\n            break\n\n    # Swap the found digit with the smallest larger digit\n    swap the found digit with the smallest larger digit\n\n    # Reverse the digits to the right of the found digit\n    reverse the digits to the right of the found digit\n\n    # Convert the list of digits back to a number\n    convert the list of digits back to a number named \"next_bigger_number\"\n\n    # Return the next bigger number\n    return next_bigger_number",
    "407": "function find_k_pairs(array1, array2, k):\n    # Create an empty list to store the pairs\n    create an empty list named \"pairs\"\n\n    # Loop through the first array\n    for each element in array1:\n        # Loop through the second array\n        for each element in array2:\n            # Add the pair to the list\n            add (element from array1, element from array2) to \"pairs\"\n\n            # If we've found k pairs, return them\n            if the size of \"pairs\" is equal to k:\n                return \"pairs\"\n\n    # If we've checked all elements and found fewer than k pairs, return a signal (like None or a message)\n    return None",
    "408": "function find_min_product(list_of_tuples):\n    # Initialize the minimum product to be the product of the first two numbers in the first tuple\n    set minimum_product to be the product of the first two numbers in the first tuple in list_of_tuples\n\n    # Loop through each tuple in the list\n    for each tuple in list_of_tuples:\n        # Calculate the product of the first two numbers in the current tuple\n        set current_product to be the product of the first two numbers in the current tuple\n\n        # If the current product is less than the minimum product, update the minimum product\n        if current_product is less than minimum_product:\n            set minimum_product to be current_product\n\n    # Return the minimum product\n    return minimum_product",
    "409": "function find_minimum_value(input_list):\n    # Initialize the minimum value to be the first element of the list\n    set minimum_value to the first element of input_list\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # Check if the current element is less than the current minimum value\n        if element is less than minimum_value:\n            # If it is, update the minimum value\n            set minimum_value to element\n\n    # Return the minimum value\n    return minimum_value",
    "410": "function convert_snake_to_camel(snake_case_string):\n    # Import the required module\n    import re\n\n    # Use regex to split the string into words\n    words = re.split('_', snake_case_string)\n\n    # Capitalize the first letter of each word and join them together\n    camel_case_string = words[0] + ''.join(word.capitalize() for word in words[1:])\n\n    # Return the camel case string\n    return camel_case_string",
    "411": "function remove_odd_numbers(input_list):\n    # Create an empty list to keep track of even numbers\n    create an empty list named \"even_numbers\"\n\n    # Loop through each number in the input list\n    for each number in input_list:\n        # Check if the number is even\n        if number modulo 2 equals 0:\n            # If it's even, add it to our list of even numbers\n            add number to \"even_numbers\"\n\n    # Return the list of even numbers\n    return \"even_numbers\"",
    "412": "function extract_nth_element(list_of_tuples, n):\n    # Create an empty list to store the nth elements\n    create an empty list named \"nth_elements\"\n\n    # Loop through each tuple in the list of tuples\n    for each tuple in list_of_tuples:\n        # Check if the tuple has enough elements to extract the nth one\n        if the length of tuple is greater than or equal to n:\n            # If it does, extract the nth element and add it to the list\n            extract the nth element from tuple and add it to \"nth_elements\"\n\n    # Return the list of nth elements\n    return \"nth_elements\"",
    "413": "function check_value_exists(sequence, value):\n    # Loop through each item in the sequence\n    for each item in sequence:\n        # Check if the current item is equal to the value we're looking for\n        if item equals value:\n            # If it is, return True, because we've found the value\n            return True\n\n    # If we've checked all items and found no matches, return False, because the value doesn't exist\n    return False",
    "414": "function find_highest_product_pair(input_array):\n    # Initialize two variables to keep track of the two highest numbers\n    initialize two variables named \"highest_number\" and \"second_highest_number\" to negative infinity\n\n    # Loop through each number in the input array\n    for each number in input_array:\n        # Check if the number is higher than the highest number we've seen so far\n        if number is greater than \"highest_number\":\n            # If it is, update \"second_highest_number\" to be \"highest_number\" and \"highest_number\" to be the new number\n            set \"second_highest_number\" to be \"highest_number\" and \"highest_number\" to be the new number\n        else if number is greater than \"second_highest_number\" and number is not equal to \"highest_number\":\n            # If it's not the highest number but is higher than \"second_highest_number\", update \"second_highest_number\"\n            set \"second_highest_number\" to be the new number\n\n    # Return the pair of numbers with the highest product\n    return \"highest_number\" and \"second_highest_number\"",
    "415": "function max_sum_divide_recursively(number):\n    # Base case: if the number is less than 3, return the number itself\n    if number < 3:\n        return number\n\n    # Recursive case: divide the number into three parts and sum them up\n    part1 = max_sum_divide_recursively(number // 3)\n    part2 = max_sum_divide_recursively(number // 3)\n    part3 = max_sum_divide_recursively(number // 3)\n\n    return part1 + part2 + part3",
    "416": "function find_common_first_element(list_of_tuples):\n    # Create an empty collection to keep track of the first elements of each tuple\n    create an empty collection named \"first_elements\"\n\n    # Loop through each tuple in the list of tuples\n    for each tuple in list_of_tuples:\n        # Add the first element of the tuple to our collection\n        add the first element of the tuple to \"first_elements\"\n\n    # Find the most common element in \"first_elements\"\n    most_common_element = find the most common element in \"first_elements\"\n\n    # Return the most common element\n    return most_common_element",
    "417": "function find_max_length_sublist(input_list):\n    # Create an empty list to keep track of sublists\n    create an empty list named \"sublists\"\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # Create a new sublist starting from the current element\n        create a new sublist named \"new_sublist\" and add element to it\n\n        # Loop through the remaining elements in the input list\n        for each remaining element in input_list:\n            # If the element is greater than the last element in the new sublist\n            if element is greater than the last element in \"new_sublist\":\n                # Add the element to the new sublist\n                add element to \"new_sublist\"\n\n        # Add the new sublist to the list of sublists\n        add \"new_sublist\" to \"sublists\"\n\n    # Initialize the maximum length to 0 and the maximum sublist to None\n    initialize maximum length to 0 and maximum sublist to None\n\n    # Loop through each sublist in the list of sublists\n    for each sublist in \"sublists\":\n        # If the length of the sublist is greater than the maximum length\n        if length of sublist is greater than maximum length:\n            # Update the maximum length and the maximum sublist\n            update maximum length to length of sublist and maximum sublist to sublist\n\n    # Return the maximum sublist\n    return maximum sublist",
    "418": "function round_and_sum(list_of_numbers):\n    # Create a variable to keep track of the total sum\n    create a variable named \"total_sum\" and set it to 0\n\n    # Loop through each number in the list\n    for each number in list_of_numbers:\n        # Round the number to the nearest whole number\n        round the number to the nearest whole number\n\n        # Add the rounded number to the total sum\n        add the rounded number to \"total_sum\"\n\n    # Multiply the total sum by the length of the list\n    multiply \"total_sum\" by the length of the list\n\n    # Return the result\n    return the result",
    "419": "function cube_sum_of_even_numbers(n):\n    # Initialize sum to 0\n    initialize sum to 0\n\n    # Loop from 1 to n\n    for i from 1 to n:\n        # Check if the number is even\n        if i is even:\n            # If it is, add its cube to the sum\n            add i^3 to sum\n\n    # Return the sum\n    return sum",
    "420": "function concatenate_tuple_elements(tuple, delimiter):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each element in the tuple\n    for each element in tuple:\n        # If this is the first element, don't add the delimiter\n        if this is the first element:\n            add element to \"result\"\n        else:\n            # If it's not the first element, add the delimiter and the element to \"result\"\n            add delimiter and element to \"result\"\n\n    # Return the result\n    return \"result\"",
    "421": "function find_average_of_cubes(n):\n    # Initialize sum to 0\n    initialize sum to 0\n\n    # Loop from 1 to n\n    for i from 1 to n:\n        # Add the cube of i to the sum\n        add the cube of i (i*i*i) to sum\n\n    # Calculate the average by dividing the sum by n\n    calculate the average by dividing sum by n\n\n    # Return the average\n    return the average",
    "422": "function solve_gold_mine_problem(grid):\n    # Get the dimensions of the grid\n    rows = length of grid\n    cols = length of grid[0]\n\n    # Create a new grid to store the maximum amount of gold that can be collected\n    create a new grid with dimensions rows x cols and initialize all cells to 0\n\n    # Loop through each cell in the grid\n    for each cell in grid:\n        # If the cell is not the first column\n        if cell is not in the first column:\n            # Update the cell's value with the maximum of its own value and the cell above it plus the value of the cell to its left\n            cell's value = maximum of cell's value and cell above it plus the value of the cell to its left\n\n        # If the cell is not the first row and not the first column\n        if cell is not in the first row and cell is not in the first column:\n            # Update the cell's value with the maximum of its own value and the cell above it plus the value of the cell to its left minus the value of the cell above it\n            cell's value = maximum of cell's value and cell above it plus the value of the cell to its left minus the value of the cell above it\n\n        # If the cell is not the first row\n        if cell is not in the first row:\n            # Update the cell's value with the maximum of its own value and the cell above it plus the value of the cell to its right\n            cell's value = maximum of cell's value and cell above it plus the value of the cell to its right\n\n    # Return the value in the bottom right cell of the grid\n    return the value in the bottom right cell of the grid",
    "423": "function extract_last_element(tuple_of_strings):\n    # Create an empty list to store the last characters of each string\n    create an empty list named \"last_characters\"\n\n    # Loop through each string in the tuple\n    for each string in tuple_of_strings:\n        # Get the last character of the string\n        get the last character of string\n\n        # Add this character to our list\n        add the character to \"last_characters\"\n\n    # Return the list of last characters\n    return \"last_characters\"",
    "424": "function count_sublists_containing_element(input_list, element):\n    # Initialize a counter to keep track of the number of sublists containing the element\n    initialize a counter named \"count\" to 0\n\n    # Loop through each sublist in the input list\n    for each sublist in input_list:\n        # Check if the sublist contains the element\n        if element is in sublist:\n            # If it does, increment the counter\n            increment \"count\" by 1\n\n    # Return the final count\n    return \"count\"",
    "425": "function filter_odd_numbers(list_of_numbers):\n    # Use the filter function to apply a lambda function to each element in the list\n    # The lambda function checks if the number is odd\n    # If the number is odd, it returns True, otherwise it returns False\n    # The filter function then creates a new list of only the elements for which the lambda function returned True\n    return filter(lambda x: x % 2 != 0, list_of_numbers)",
    "426": "function convert_date_format(date_string):\n    # Import the required module\n    import re\n\n    # Define the pattern for the date\n    pattern = \"(\\d{4})-(\\d{2})-(\\d{2})\"\n\n    # Use the re.match function to check if the date string matches the pattern\n    match = re.match(pattern, date_string)\n\n    # If the date string matches the pattern\n    if match:\n        # Extract the year, month, and day from the match\n        year = match.group(1)\n        month = match.group(2)\n        day = match.group(3)\n\n        # Combine the day, month, and year into the new format\n        new_date = day + \"-\" + month + \"-\" + year\n\n        # Return the new date\n        return new_date\n\n    # If the date string does not match the pattern, return a message indicating an error\n    else:\n        return \"Invalid date format. Please provide a date in yyyy-mm-dd format.\"",
    "427": "function shell_sort(array):\n    # Initialize the gap size\n    set gap_size to the length of the array divided by 2\n\n    # Loop until the gap size is 0\n    while gap_size is greater than 0:\n        # Loop through the array starting from the gap size\n        for i from gap_size to the end of the array:\n            # Store the current element\n            store the value of the array at index i in temp\n\n            # Shift elements of the array greater than temp\n            j = i\n            while j >= gap_size and array at index j - gap_size is greater than temp:\n                # Move the element to the right\n                set the value of the array at index j to the value of the array at index j - gap_size\n                decrement j by gap_size\n\n            # Insert the stored element at its correct position\n            set the value of the array at index j to temp\n\n        # Reduce the gap size for the next iteration\n        set gap_size to gap_size divided by 2\n\n    # Return the sorted array\n    return the array",
    "428": "function extract_elementwise(tuple1, tuple2):\n    # Create an empty list to store the result\n    create an empty list named \"result\"\n\n    # Loop through each element in the tuples\n    for each element in tuple1:\n        # Add the element from tuple1 and the corresponding element from tuple2 to the result\n        add (element, tuple2[index of element in tuple1]) to \"result\"\n\n    # Return the result\n    return \"result\"",
    "429": "function find_directrix(a, b, c):\n    # Calculate the discriminant\n    discriminant = b^2 - 4ac\n\n    # If the discriminant is negative, there are no real roots, so return a signal (like None or a message)\n    if discriminant < 0:\n        return None\n\n    # If the discriminant is zero, there is one real root, so return it\n    if discriminant == 0:\n        return -b / (2a)\n\n    # If the discriminant is positive, there are two real roots, so return them\n    root1 = (-b + sqrt(discriminant)) / (2a)\n    root2 = (-b - sqrt(discriminant)) / (2a)\n    return root1, root2",
    "430": "function has_common_element(list1, list2):\n    # Loop through each element in the first list\n    for each element in list1:\n        # Check if the element is in the second list\n        if element is in list2:\n            # If it is, return True, because there is a common element\n            return True\n\n    # If we've checked all elements in the first list and found no common elements, return False\n    return False",
    "431": "function find_median_trapezium(base1, base2, height):\n    # Calculate the area of the trapezium\n    area = 0.5 * (base1 + base2) * height\n\n    # Calculate the median of the trapezium\n    median = area / 2\n\n    # Return the median\n    return median",
    "432": "function is_greater_than_elements(number, array):\n    # Loop through each element in the array\n    for each element in array:\n        # Check if the number is greater than the current element\n        if number is not greater than element:\n            # If it's not, return False\n            return False\n\n    # If we've checked all elements and found no elements that are not greater, return True\n    return True",
    "433": "function match_string(input_string):\n    # Create a regular expression pattern to match the string\n    create a regular expression pattern that matches a string with an a followed by one or more b's\n\n    # Check if the input string matches the pattern\n    if input_string matches the pattern:\n        # If it does, return True\n        return True\n    else:\n        # If it doesn't, return False\n        return False",
    "434": "function find_last_digit(number):\n    # Convert the number to a string\n    convert number to string\n\n    # Get the last character of the string (which is the last digit of the number)\n    get the last character of the string\n\n    # Convert the character back to a number\n    convert the character back to a number\n\n    # Return the last digit\n    return the number",
    "435": "function print_negative_numbers(list_of_numbers):\n    # Loop through each number in the list\n    for each number in list_of_numbers:\n        # Check if the number is negative\n        if number is less than zero:\n            # If it is, print it\n            print number\n\n    # If no negative numbers are found, print a message indicating so\n    print \"No negative numbers found in the list\"",
    "436": "function remove_odd_characters(input_string):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the index of the character is even\n        if the index of character in input_string is even:\n            # If it is, add it to the result string\n            add character to \"result\"\n\n    # Return the result string\n    return \"result\"",
    "437": "function count_bidirectional_tuple_pairs(tuple_list):\n    # Create a variable to store the count of bidirectional tuple pairs\n    create a variable named \"count\" and initialize it to 0\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Check if the tuple is bidirectional\n        if the tuple is bidirectional:\n            # If it is, increment the count\n            increment \"count\" by 1\n\n    # Return the count\n    return \"count\"\n\nIn the pseudocode above, \"tuple_list\" is a list of tuples, and \"tuple\" is a single tuple. A tuple is bidirectional if it appears in both directions in the list. For example, if the tuple list is [(1, 2), (2, 1)], the function should return 1 because (1, 2) and (2, 1) are bidirectional.",
    "438": "function convert_list_to_integer(list_of_integers):\n    # Initialize an empty string to store the final integer\n    create an empty string named \"final_integer\"\n\n    # Loop through each integer in the list\n    for each integer in list_of_integers:\n        # Convert the integer to a string and add it to the final_integer string\n        convert integer to string and add it to \"final_integer\"\n\n    # Convert the final_integer string back to an integer and return it\n    convert \"final_integer\" to integer and return it",
    "439": "function find_adverbs_and_positions(sentence):\n    # Create an empty list to store the adverbs and their positions\n    create an empty list named \"adverbs\"\n\n    # Split the sentence into words\n    split sentence into words\n\n    # Loop through each word in the sentence\n    for each word in words:\n        # Check if the word is an adverb\n        if word is an adverb:\n            # If it is, add it to the list of adverbs along with its position\n            add word and its position to \"adverbs\"\n\n    # Return the list of adverbs and their positions\n    return \"adverbs\"",
    "440": "function find_cube_surface_area(side_length):\n    # Calculate the surface area of a cube\n    # The formula for the surface area of a cube is 6 * side_length^2\n    surface_area = 6 * side_length ** 2\n\n    # Return the calculated surface area\n    return surface_area",
    "441": "function find_positive_ratio(array):\n    # Initialize a counter for positive numbers\n    create a variable named \"positive_count\" and set it to 0\n\n    # Loop through each number in the array\n    for each number in array:\n        # Check if the number is positive\n        if number is greater than 0:\n            # If it is, increment the positive count\n            increment \"positive_count\" by 1\n\n    # Calculate the ratio of positive numbers\n    calculate the ratio of \"positive_count\" divided by the length of the array\n\n    # Return the ratio\n    return the calculated ratio",
    "442": "function find_largest_negative_number(input_list):\n    # Create a variable to keep track of the largest negative number we've seen so far\n    create a variable named \"largest_negative_number\" and set it to None\n\n    # Loop through each number in the input list\n    for each number in input_list:\n        # Check if the number is negative\n        if number is less than 0:\n            # If it is, check if it's larger than the largest negative number we've seen so far\n            if number is greater than \"largest_negative_number\" or \"largest_negative_number\" is None:\n                # If it is, update \"largest_negative_number\" to be this number\n                set \"largest_negative_number\" to be number\n\n    # Return the largest negative number we've found\n    return \"largest_negative_number\"",
    "443": "function trim_tuples(tuple_list, k):\n    # Create an empty list to store the trimmed tuples\n    create an empty list named \"trimmed_tuples\"\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Check if the length of the tuple is greater than k\n        if length of tuple is greater than k:\n            # If it is, trim the tuple to the first k elements and add it to the trimmed tuples list\n            trim the tuple to the first k elements and add it to \"trimmed_tuples\"\n        else:\n            # If it's not, add the tuple as is to the trimmed tuples list\n            add tuple to \"trimmed_tuples\"\n\n    # Return the list of trimmed tuples\n    return \"trimmed_tuples\"",
    "444": "function index_wise_multiplication(tuple1, tuple2):\n    # Create an empty list to store the result\n    create an empty list named \"result\"\n\n    # Check if both tuples have the same length\n    if length of tuple1 is not equal to length of tuple2:\n        # If not, return an error message\n        return \"Error: Tuples must have the same length\"\n\n    # Loop through each index in the tuples\n    for each index in range from 0 to length of tuple1:\n        # Multiply the elements at the current index in both tuples\n        multiply the element at index in tuple1 with the element at index in tuple2\n\n        # Add the result to the list\n        add the result to \"result\"\n\n    # Return the list of results\n    return \"result\"",
    "445": "function count_occurrences(list, tuple):\n    # Create an empty dictionary to keep track of counts\n    create an empty dictionary named \"counts\"\n\n    # Loop through each element in the list\n    for each element in list:\n        # Initialize the count for this element to 0\n        set the count for element to 0\n\n    # Loop through each element in the tuple\n    for each element in tuple:\n        # If the element is in the list, increment its count\n        if element is in list:\n            increment the count for element\n\n    # Return the counts\n    return counts",
    "446": "function find_cubes(list):\n    # Create an empty list to store the cubes\n    create an empty list named \"cubes\"\n\n    # Use the map function to apply a lambda function to each element in the list\n    # The lambda function takes an element and returns its cube\n    cubes = map(lambda x: x**3, list)\n\n    # Convert the map object to a list and return it\n    return list(cubes)",
    "447": "function calculate_sum_of_perrin_numbers(n):\n    # Initialize the first three Perrin numbers\n    set P0 = 3\n    set P1 = 0\n    set P2 = 2\n\n    # If n is 0, return P0\n    if n is 0:\n        return P0\n    # If n is 1, return P1\n    if n is 1:\n        return P1\n    # If n is 2, return P2\n    if n is 2:\n        return P2\n\n    # Initialize the sum\n    set sum = P0 + P1 + P2\n\n    # Calculate the Perrin numbers up to n\n    for i from 3 to n:\n        # Calculate the next Perrin number\n        set Pn = Pn-2 + Pn-3\n        # Add it to the sum\n        add Pn to sum\n\n    # Return the sum\n    return sum",
    "448": "function is_valid_triangle(point1, point2, point3):\n    # Calculate the distance between point1 and point2\n    calculate the distance between point1 and point2 and store it in a variable named \"distance1\"\n\n    # Calculate the distance between point2 and point3\n    calculate the distance between point2 and point3 and store it in a variable named \"distance2\"\n\n    # Calculate the distance between point3 and point1\n    calculate the distance between point3 and point1 and store it in a variable named \"distance3\"\n\n    # Check if the triangle is valid\n    if distance1 + distance2 > distance3 and distance2 + distance3 > distance1 and distance3 + distance1 > distance2:\n        # If the triangle is valid, return True\n        return True\n    else:\n        # If the triangle is not valid, return False\n        return False",
    "449": "function extract_strings(list_of_strings, size):\n    # Create an empty list to store the strings of the specified size\n    create an empty list named \"strings_of_size\"\n\n    # Loop through each string in the list\n    for each string in list_of_strings:\n        # Check if the length of the string is equal to the specified size\n        if the length of string is equal to size:\n            # If it is, add it to the list of strings of the specified size\n            add string to \"strings_of_size\"\n\n    # Return the list of strings of the specified size\n    return \"strings_of_size\"",
    "450": "function remove_whitespaces_using_regex(input_string):\n    # Import the re module\n    import re\n\n    # Use the sub function from the re module to replace all whitespaces with an empty string\n    result = re.sub('\\s+', '', input_string)\n\n    # Return the result\n    return result",
    "451": "function calculate_loss(initial_amount, final_amount):\n    # Check if the final amount is less than the initial amount\n    if final_amount < initial_amount:\n        # If it is, calculate the loss amount\n        loss_amount = initial_amount - final_amount\n        # Return the loss amount\n        return loss_amount\n    else:\n        # If there is no loss, return None\n        return None",
    "452": "function sum_of_even_factors(number):\n    # Initialize a variable to keep track of the sum\n    set sum to 0\n\n    # Loop through each number from 1 to the given number\n    for each number from 1 to number:\n        # Check if the current number is a factor of the given number\n        if number is a factor of given number:\n            # Check if the factor is even\n            if factor is even:\n                # If it is, add it to the sum\n                add factor to sum\n\n    # Return the sum\n    return sum",
    "453": "function match_word_with_z(input_string):\n    # Create an empty list to keep track of words that contain 'z'\n    create an empty list named \"matching_words\"\n\n    # Split the input string into words\n    split input_string into words\n\n    # Loop through each word in the list of words\n    for each word in words:\n        # Check if the word contains 'z'\n        if 'z' is in word:\n            # If it does, add it to our list of matching words\n            add word to \"matching_words\"\n\n    # Return the list of matching words\n    return \"matching_words\"",
    "454": "function check_month_with_31_days(month_number):\n    # Create a list of months that have 31 days\n    create a list named \"months_with_31_days\" with values 1, 3, 5, 7, 8, 10, 12\n\n    # Check if the given month number is in the list of months with 31 days\n    if month_number is in \"months_with_31_days\":\n        # If it is, return True\n        return True\n    else:\n        # If it's not, return False\n        return False",
    "455": "function reverse_strings_in_list(list_of_strings):\n    # Create an empty list to store the reversed strings\n    create an empty list named \"reversed_strings\"\n\n    # Loop through each string in the list\n    for each string in list_of_strings:\n        # Reverse the string\n        reverse the string\n\n        # Add the reversed string to the list\n        add reversed string to \"reversed_strings\"\n\n    # Return the list of reversed strings\n    return \"reversed_strings\"",
    "456": "function find_minimum_length_sublist(input_list):\n    # Initialize minimum length to be the length of the input list\n    set minimum_length to the length of input_list\n\n    # Initialize the minimum length sublist to be the input list itself\n    set minimum_length_sublist to input_list\n\n    # Loop through each sublist in the input list\n    for each sublist in input_list:\n        # Check if the length of the current sublist is less than the minimum length\n        if the length of sublist is less than minimum_length:\n            # If it is, update the minimum length and the minimum length sublist\n            set minimum_length to the length of sublist\n            set minimum_length_sublist to sublist\n\n    # Return the minimum length sublist\n    return minimum_length_sublist",
    "457": "function find_area_of_rectangle(length, width):\n    # Calculate the area of the rectangle\n    area = length * width\n\n    # Return the calculated area\n    return area",
    "458": "function remove_uppercase_substrings(input_string):\n    # Import the regular expression module\n    import regular expression module\n\n    # Define the pattern for uppercase substrings\n    define the pattern as \"([A-Z]+)\"\n\n    # Use the sub() function from the regular expression module to replace uppercase substrings with an empty string\n    replace all occurrences of the pattern in the input_string with an empty string\n\n    # Return the modified string\n    return the modified string",
    "459": "function get_first_elements(list_of_sublists):\n    # Create an empty list to store the first elements\n    create an empty list named \"first_elements\"\n\n    # Loop through each sublist in the input list\n    for each sublist in list_of_sublists:\n        # Check if the sublist is not empty\n        if sublist is not empty:\n            # If it's not empty, get the first element and add it to our list\n            get the first element from sublist and add it to \"first_elements\"\n\n    # Return the list of first elements\n    return \"first_elements\"",
    "460": "function count_uppercase_characters(input_string):\n    # Create a counter to keep track of uppercase characters\n    create a variable named \"uppercase_count\" and set it to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is uppercase\n        if character is uppercase:\n            # If it is, increment the counter\n            increment \"uppercase_count\" by 1\n\n    # Return the count of uppercase characters\n    return \"uppercase_count\"",
    "461": "function find_all_combinations(input_list):\n    # Create an empty list to store all combinations\n    create an empty list named \"combinations\"\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # Loop through each combination in the current list of combinations\n        for each combination in combinations:\n            # Add the current element to each combination\n            add element to each combination\n\n        # Add the current element to each combination\n        add element to each combination\n\n    # Return the list of all combinations\n    return combinations",
    "462": "function find_max_product_subarray(array):\n    # Initialize max_product and min_product to the first element of the array\n    max_product = min_product = array[0]\n\n    # Initialize result to the first element of the array\n    result = array[0]\n\n    # Loop through the array starting from the second element\n    for i from 1 to length of array:\n        # If the current element is negative, swap max_product and min_product\n        if array[i] < 0:\n            swap max_product and min_product\n\n        # Update max_product and min_product\n        max_product = max(array[i], max_product * array[i])\n        min_product = min(array[i], min_product * array[i])\n\n        # Update result if necessary\n        result = max(result, max_product)\n\n    # Return the result\n    return result",
    "463": "function are_all_values_same(input_dictionary):\n    # If the dictionary is empty, return True\n    if input_dictionary is empty:\n        return True\n\n    # Get the first value from the dictionary\n    first_value = get the first value from input_dictionary\n\n    # Loop through each value in the dictionary\n    for each value in input_dictionary:\n        # If the value is not equal to the first value, return False\n        if value is not equal to first_value:\n            return False\n\n    # If we've checked all values and found they're all the same, return True\n    return True",
    "464": "function drop_empty_items(input_dictionary):\n    # Create a new dictionary to store the non-empty items\n    create an empty dictionary named \"non_empty_items\"\n\n    # Loop through each item in the input dictionary\n    for each item in input_dictionary:\n        # Check if the value of the item is not empty\n        if value of item is not empty:\n            # If it's not empty, add it to our new dictionary\n            add item to \"non_empty_items\"\n\n    # Return the new dictionary with no empty items\n    return \"non_empty_items\"",
    "465": "function find_peak_element(input_array):\n    # Check if the array is empty\n    if input_array is empty:\n        # If it is, return a signal (like None or a message)\n        return None\n\n    # Loop through each element in the array\n    for each element in input_array:\n        # Check if the element is greater than its neighbors\n        if element is greater than both of its neighbors:\n            # If it is, this is the peak element, so return it\n            return element\n\n    # If we've checked all elements and found no peaks, return a signal (like None or a message)\n    return None",
    "466": "function convert_decimal_to_octal(decimal_number):\n    # Create an empty string to store the octal number\n    create an empty string named \"octal_number\"\n\n    # While the decimal number is greater than 0\n    while decimal_number is greater than 0:\n        # Find the remainder when the decimal number is divided by 8\n        find the remainder when decimal_number is divided by 8 and store it in a variable named \"remainder\"\n\n        # Add the remainder to the front of the octal number\n        add the remainder to the front of the octal_number\n\n        # Divide the decimal number by 8 and round down to the nearest whole number\n        divide the decimal_number by 8 and round down to the nearest whole number and store it in the decimal_number\n\n    # Return the octal number\n    return octal_number",
    "467": "function max_product_increasing_subsequence(input_array):\n    # Initialize the maximum product to be the smallest possible value\n    initialize maximum_product to be negative infinity\n\n    # Loop through each number in the input array\n    for each number in input_array:\n        # Initialize the current product to be the number itself\n        initialize current_product to be number\n\n        # Loop through each subsequent number in the array\n        for each subsequent number in input_array:\n            # If the subsequent number is greater than the current number\n            if subsequent number is greater than number:\n                # Multiply the current product by the subsequent number\n                multiply current_product by subsequent number\n\n                # If the current product is greater than the maximum product\n                if current_product is greater than maximum_product:\n                    # Update the maximum product\n                    update maximum_product to be current_product\n\n    # Return the maximum product\n    return maximum_product",
    "468": "function max_profit(prices, k):\n    # Create a variable to store the maximum profit\n    max_profit = 0\n\n    # Loop through the prices array\n    for i in range(len(prices)):\n        # Loop through the prices array again\n        for j in range(i+1, len(prices)):\n            # If the price at j is greater than the price at i, calculate the profit\n            if prices[j] > prices[i]:\n                # Calculate the profit\n                profit = prices[j] - prices[i]\n                # If the profit is greater than the current max profit, update the max profit\n                if profit > max_profit:\n                    max_profit = profit\n\n    # Return the maximum profit\n    return max_profit",
    "469": "function pairwise_addition(tuple1, tuple2):\n    # Check if both tuples have the same length\n    if length of tuple1 is not equal to length of tuple2:\n        # If not, return an error message\n        return \"Error: Tuples must have the same length\"\n\n    # Create an empty list to store the results\n    create an empty list named \"results\"\n\n    # Loop through each element in the tuples\n    for each index from 0 to length of tuple1 - 1:\n        # Add the elements at the current index in both tuples and append the result to the results list\n        append the sum of tuple1[index] and tuple2[index] to \"results\"\n\n    # Return the results list\n    return \"results\"",
    "470": "function find_remainder_of_array_multiplication(array, n):\n    # Initialize the result to 1\n    set result to 1\n\n    # Loop through each number in the array\n    for each number in array:\n        # Multiply the result by the number\n        multiply result by number\n\n    # Return the remainder of the result divided by n\n    return result mod n",
    "471": "function check_consecutive_numbers(input_list):\n    # Convert the list to a set to remove duplicates\n    create a set named \"unique_numbers\" from input_list\n\n    # If the length of the list is not equal to the length of the set,\n    # it means there were duplicates in the list, so it's not consecutive\n    if the length of \"unique_numbers\" is not equal to the length of input_list:\n        return False\n\n    # Sort the list\n    sort input_list in ascending order\n\n    # Check if the difference between each pair of consecutive numbers is 1\n    for each index from 0 to the length of input_list - 2:\n        if the difference between input_list[index] and input_list[index + 1] is not equal to 1:\n            return False\n\n    # If we've checked all pairs and found no non-consecutive pairs, return True\n    return True",
    "472": "function find_tuple_intersection(tuple_list):\n    # Create an empty dictionary to keep track of the elements in the first tuple\n    create an empty dictionary named \"first_tuple_elements\"\n\n    # Loop through each element in the first tuple\n    for each element in the first tuple in tuple_list:\n        # Add the element to the dictionary\n        add element to \"first_tuple_elements\"\n\n    # Create an empty list to store the intersection elements\n    create an empty list named \"intersection_elements\"\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Create a copy of the dictionary of first tuple elements\n        create a copy of \"first_tuple_elements\" named \"current_tuple_elements\"\n\n        # Loop through each element in the current tuple\n        for each element in tuple:\n            # If the element is in the current tuple elements dictionary\n            if element is in \"current_tuple_elements\":\n                # Add the element to the intersection elements list\n                add element to \"intersection_elements\"\n\n                # Remove the element from the current tuple elements dictionary\n                remove element from \"current_tuple_elements\"\n\n    # Return the intersection elements list\n    return \"intersection_elements\"",
    "473": "function replace_characters(input_string, old_characters, new_characters):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is in the list of characters to replace\n        if character is in old_characters:\n            # If it is, find its index in the old_characters list\n            find the index of character in old_characters\n\n            # Replace the character with the corresponding new character\n            replace character with new_characters[index]\n\n        # Add the replaced or unchanged character to the result string\n        add the replaced or unchanged character to \"result\"\n\n    # Return the result string\n    return result",
    "474": "function sort_counter_by_value(counter):\n    # Create an empty list to store the sorted items\n    create an empty list named \"sorted_items\"\n\n    # Loop through each item in the counter\n    for each item in counter:\n        # Add the item to the sorted_items list, sorted by the item's value\n        add item to \"sorted_items\" sorted by the item's value\n\n    # Return the sorted list\n    return \"sorted_items\"",
    "475": "function find_sum_of_largest_and_smallest(array):\n    # Check if the array is empty\n    if array is empty:\n        # If it is, return a message indicating that the array is empty\n        return \"The array is empty\"\n\n    # Initialize the smallest and largest values to the first element of the array\n    smallest = array[0]\n    largest = array[0]\n\n    # Loop through the array\n    for each element in array:\n        # Check if the current element is smaller than the smallest value\n        if element < smallest:\n            # If it is, update the smallest value\n            smallest = element\n\n        # Check if the current element is larger than the largest value\n        if element > largest:\n            # If it is, update the largest value\n            largest = element\n\n    # Return the sum of the smallest and largest values\n    return smallest + largest",
    "476": "function convert_to_lower_case(input_string):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If the character is an uppercase letter, convert it to lowercase\n        if character is an uppercase letter:\n            convert character to lowercase\n        else:\n            # If the character is not an uppercase letter, just add it to the result string as is\n            add character to \"result\"\n\n    # Return the result string\n    return \"result\"",
    "477": "function remove_lowercase_substrings(input_string):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is lowercase\n        if character is lowercase:\n            # If it is, add the previous characters to the result\n            add the previous characters to \"result\"\n        else:\n            # If it's not lowercase, add the character to the result\n            add character to \"result\"\n\n    # Return the result\n    return \"result\"",
    "478": "function find_first_digit(input_number):\n    # Convert the input number to a string\n    convert input_number to a string named \"number_string\"\n\n    # Loop through each character in the string\n    for each character in number_string:\n        # Check if the character is a digit\n        if character is a digit:\n            # If it is, return the digit\n            return character\n\n    # If we've checked all characters and found no digits, return a signal (like None or a message)\n    return None",
    "479": "function find_max_occurring_character(input_string):\n    # Create an empty dictionary to keep track of character counts\n    create an empty dictionary named \"character_counts\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If the character is already in our dictionary, increment its count\n        if character is already in \"character_counts\":\n            increment the count for character in \"character_counts\"\n        else:\n            # If the character is not in our dictionary, add it with a count of 1\n            add character to \"character_counts\" with a count of 1\n\n    # Initialize variables to keep track of the character with the maximum count and its count\n    set the maximum_count to 0\n    set the max_character to None\n\n    # Loop through each character and its count in the dictionary\n    for each character, count in \"character_counts\":\n        # If this character's count is greater than our current maximum, update our maximum\n        if count is greater than maximum_count:\n            set maximum_count to count\n            set max_character to character\n\n    # Return the character with the maximum count\n    return max_character",
    "480": "function is_subset_with_sum(set, sum):\n    # Create a list to store all possible sums\n    create a list named \"possible_sums\" and initialize it with 0\n\n    # Loop through each number in the set\n    for each number in set:\n        # Create a new list to store the new possible sums\n        create a new list named \"new_possible_sums\" and initialize it with the values in \"possible_sums\"\n\n        # Loop through each possible sum\n        for each possible_sum in \"possible_sums\":\n            # Add the current number to the possible sum\n            add number to possible_sum\n\n            # If the new possible sum is equal to the given sum, return True\n            if new_possible_sum equals sum:\n                return True\n\n            # Add the new possible sum to the new_possible_sums list\n            add new_possible_sum to \"new_possible_sums\"\n\n        # Update the possible_sums list with the new_possible_sums list\n        update \"possible_sums\" with \"new_possible_sums\"\n\n    # If no subset with the given sum is found, return False\n    return False",
    "481": "function find_sequences_using_regex(input_string):\n    # Import the regex module\n    import regex\n\n    # Define the pattern for the sequences\n    pattern = '[A-Z][a-z]*'\n\n    # Use the findall function to find all matches of the pattern in the input string\n    matches = regex.findall(pattern, input_string)\n\n    # Return the matches\n    return matches",
    "482": "function find_first_divisible_factorial(x):\n    # Initialize a variable to keep track of the current number\n    set a variable named \"current_number\" to 1\n\n    # Initialize a variable to keep track of the current factorial\n    set a variable named \"current_factorial\" to 1\n\n    # Loop until we find a number whose factorial is divisible by x\n    while True:\n        # Check if the current factorial is divisible by x\n        if current_factorial modulo x equals 0:\n            # If it is, return the current number\n            return current_number\n\n        # If it's not, increment the current number and update the current factorial\n        increment current_number by 1\n        update current_factorial to be the product of current_factorial and current_number",
    "483": "function remove_matching_tuples(tuple1, tuple2):\n    # Create an empty collection to keep track of matching tuples\n    create an empty collection named \"matching_tuples\"\n\n    # Loop through each tuple in the first tuple\n    for each tuple in tuple1:\n        # Check if this tuple is in the second tuple\n        if tuple is in tuple2:\n            # If it is, add it to our collection of matching tuples\n            add tuple to \"matching_tuples\"\n\n    # Create a new tuple that is the first tuple minus the matching tuples\n    create a new tuple named \"new_tuple1\" that is tuple1 minus \"matching_tuples\"\n\n    # Create a new tuple that is the second tuple minus the matching tuples\n    create a new tuple named \"new_tuple2\" that is tuple2 minus \"matching_tuples\"\n\n    # Return the new tuples\n    return new_tuple1, new_tuple2",
    "484": "function find_largest_palindrome(array):\n    # Initialize a variable to keep track of the largest palindrome\n    set largest_palindrome to None\n\n    # Loop through each number in the array\n    for each number in array:\n        # Convert the number to a string\n        convert number to string\n\n        # Check if the string is a palindrome\n        if string is a palindrome:\n            # If it is, check if it's larger than the current largest palindrome\n            if number is larger than largest_palindrome:\n                # If it is, update the largest palindrome\n                set largest_palindrome to number\n\n    # Return the largest palindrome\n    return largest_palindrome\n\nNote: The pseudocode for checking if a string is a palindrome is not provided as it's a common problem and there are many ways to solve it.",
    "485": "function compute_binomial_probability(n, k, p):\n    # Calculate the factorial of n\n    create a variable named \"factorial_n\" and set it to 1\n    for each number from 1 to n:\n        multiply \"factorial_n\" by the current number\n\n    # Calculate the factorial of k\n    create a variable named \"factorial_k\" and set it to 1\n    for each number from 1 to k:\n        multiply \"factorial_k\" by the current number\n\n    # Calculate the factorial of (n - k)\n    create a variable named \"factorial_n_minus_k\" and set it to 1\n    for each number from 1 to (n - k):\n        multiply \"factorial_n_minus_k\" by the current number\n\n    # Calculate the binomial coefficient (n choose k)\n    create a variable named \"binomial_coefficient\" and set it to \"factorial_n\" divided by (\"factorial_k\" times \"factorial_n_minus_k\")\n\n    # Calculate the probability\n    create a variable named \"probability\" and set it to \"binomial_coefficient\" times (p raised to the power k) times ((1 - p) raised to the power (n - k))\n\n    # Return the probability\n    return \"probability\"",
    "486": "function sort_tuples(list_of_tuples):\n    # Use the built-in sort function with a custom key function\n    list_of_tuples.sort(key=lambda x: x[-1])\n\n    # Return the sorted list of tuples\n    return list_of_tuples",
    "487": "function find_pentagon_area(side_length):\n    # Calculate the area of a pentagon using the formula: (5/2) * side_length^2 * sqrt(5*(5+2*sqrt(5)))\n    area = (5/2) * side_length^2 * sqrt(5*(5+2*sqrt(5)))\n\n    # Return the calculated area\n    return area",
    "488": "function find_frequency_of_largest_value(input_array):\n    # Initialize a variable to keep track of the largest value and its frequency\n    set largest_value to the first element of input_array\n    set frequency_of_largest_value to 1\n\n    # Loop through the rest of the array\n    for each element in input_array starting from the second element:\n        # If the current element is larger than the largest value we've seen so far\n        if element is larger than largest_value:\n            # Update the largest value and reset the frequency\n            set largest_value to element\n            set frequency_of_largest_value to 1\n        else if element is equal to largest_value:\n            # If the current element is equal to the largest value, increment the frequency\n            increment frequency_of_largest_value by 1\n\n    # Return the frequency of the largest value\n    return frequency_of_largest_value",
    "489": "function extract_symmetric_pairs(tuple_list):\n    # Create an empty list to store the symmetric pairs\n    create an empty list named \"symmetric_pairs\"\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Check if the tuple is symmetric\n        if the reverse of tuple is in tuple_list:\n            # If it is, add it to the list of symmetric pairs\n            add tuple to \"symmetric_pairs\"\n\n    # Return the list of symmetric pairs\n    return \"symmetric_pairs\"",
    "490": "function sum_geometric_progression(first_term, common_ratio, number_of_terms):\n    # Calculate the sum of a geometric progression series\n    # The formula for the sum of a geometric progression series is:\n    # sum = first_term * (1 - common_ratio^number_of_terms) / (1 - common_ratio)\n\n    # Calculate the sum\n    sum = first_term * (1 - pow(common_ratio, number_of_terms)) / (1 - common_ratio)\n\n    # Return the sum\n    return sum",
    "491": "function binary_search(array, target):\n    # Initialize the left and right pointers\n    let left = 0\n    let right = array.length - 1\n\n    # While the left pointer is less than or equal to the right pointer\n    while left <= right:\n        # Calculate the middle index\n        let mid = left + (right - left) / 2\n\n        # If the target is found at the middle index\n        if array[mid] == target:\n            # Return the middle index\n            return mid\n\n        # If the target is less than the middle element\n        if array[mid] < target:\n            # Move the left pointer to the right of the middle\n            left = mid + 1\n        else:\n            # Move the right pointer to the left of the middle\n            right = mid - 1\n\n    # If the target is not found, return -1\n    return -1",
    "492": "function calculate_hexagon_coordinates(grid_size):\n    # Create an empty list to store the hexagon coordinates\n    create an empty list named \"hexagon_coordinates\"\n\n    # Calculate the size of the grid\n    calculate the size of the grid based on the grid_size\n\n    # Loop through each row in the grid\n    for each row in the grid:\n        # Create an empty list to store the coordinates for this row\n        create an empty list named \"row_coordinates\"\n\n        # Loop through each column in the row\n        for each column in the row:\n            # Calculate the x and y coordinates for this hexagon\n            calculate the x and y coordinates for this hexagon\n\n            # Add the coordinates to the row_coordinates list\n            add the coordinates to the row_coordinates list\n\n        # Add the row_coordinates list to the hexagon_coordinates list\n        add the row_coordinates list to the hexagon_coordinates list\n\n    # Return the hexagon_coordinates list\n    return the hexagon_coordinates list",
    "493": "function convert_binary_to_integer(binary_tuple):\n    # Initialize an empty string to store the binary representation\n    create an empty string named \"binary_string\"\n\n    # Loop through each element in the binary tuple\n    for each element in binary_tuple:\n        # Convert the element to a string and add it to the binary string\n        add string representation of element to \"binary_string\"\n\n    # Convert the binary string to an integer and return it\n    return integer representation of \"binary_string\"",
    "494": "function remove_lowercase_substrings(input_string):\n    # Import the regular expression module\n    import regex\n\n    # Define the pattern for lowercase substrings\n    pattern = \"[a-z]+\"\n\n    # Use the regex.sub function to replace all lowercase substrings with an empty string\n    output_string = regex.sub(pattern, \"\", input_string)\n\n    # Return the modified string\n    return output_string",
    "495": "function find_smallest_integers(list_of_numbers):\n    # Create an empty heap queue\n    create an empty heap queue named \"heap\"\n\n    # Loop through each number in the list\n    for each number in list_of_numbers:\n        # Add the number to the heap queue\n        add number to \"heap\"\n\n    # Create an empty list to store the smallest integers\n    create an empty list named \"smallest_integers\"\n\n    # While the heap queue is not empty\n    while \"heap\" is not empty:\n        # Remove the smallest number from the heap queue and add it to the list of smallest integers\n        remove smallest number from \"heap\" and add it to \"smallest_integers\"\n\n    # Return the list of smallest integers\n    return \"smallest_integers\"",
    "496": "function find_surface_area_of_cone(radius, height):\n    # Calculate the slant height of the cone\n    slant_height = sqrt(radius^2 + height^2)\n\n    # Calculate the base area of the cone\n    base_area = pi * radius^2\n\n    # Calculate the lateral surface area of the cone\n    lateral_surface_area = pi * radius * slant_height\n\n    # Calculate the total surface area of the cone\n    total_surface_area = base_area + lateral_surface_area\n\n    # Return the total surface area of the cone\n    return total_surface_area",
    "497": "function find_gcd(num1, num2):\n    # Check if both numbers are positive\n    if num1 and num2 are both positive:\n        # If num1 is greater than num2, replace num1 with the difference between num1 and num2\n        while num1 is greater than num2:\n            num1 = num1 - num2\n        # If num2 is greater than num1, replace num2 with the difference between num2 and num1\n        while num2 is greater than num1:\n            num2 = num2 - num1\n        # The final value of num1 or num2 is the gcd\n        return num1 or num2\n    else:\n        # If either number is not positive, return an error message\n        return \"Error: Both numbers must be positive.\"",
    "498": "function find_diameter_of_circle(radius):\n    # Calculate the diameter of the circle\n    diameter = 2 * radius\n\n    # Return the calculated diameter\n    return diameter",
    "499": "function concatenate_elements_into_string(input_list):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # Convert the element to a string and add it to the result\n        convert element to string\n        add string to \"result\"\n\n    # Return the result\n    return \"result\"",
    "500": "function find_common_divisor(num1, num2):\n    # Create a variable to store the common divisor\n    create a variable named \"common_divisor\" and set it to 1\n\n    # Loop from 2 to the smaller of the two numbers\n    for each number from 2 to the smaller of num1 and num2:\n        # Check if both numbers are divisible by the current number\n        if num1 is divisible by number and num2 is divisible by number:\n            # If they are, update the common divisor\n            set \"common_divisor\" to number\n\n    # Return the common divisor\n    return common_divisor",
    "501": "function find_remainder(num1, num2):\n    # Check if num2 is zero, because division by zero is undefined\n    if num2 is equal to zero:\n        # If num2 is zero, return an error message\n        return \"Error: Division by zero is undefined\"\n    else:\n        # If num2 is not zero, calculate the remainder of num1 divided by num2\n        remainder = num1 mod num2\n        # Return the remainder\n        return remainder",
    "502": "function add_consecutive_numbers(input_list):\n    # Create an empty list to store the sum of consecutive numbers\n    create an empty list named \"sum_list\"\n\n    # Loop through each number in the input list\n    for each number in input_list:\n        # If the next number exists in the list\n        if the next number exists in the list:\n            # Add the current number and the next number\n            add the sum of the current number and the next number to \"sum_list\"\n\n    # Return the \"sum_list\"\n    return sum_list",
    "503": "function cube_sum(n):\n    # Initialize sum to 0\n    initialize sum to 0\n\n    # Loop from 1 to n\n    for i from 1 to n:\n        # Add the cube of i to the sum\n        add the cube of i to sum\n\n    # Return the sum\n    return sum",
    "504": "function move_zeroes_to_end(input_array):\n    # Create a variable to keep track of the position where we should put the next non-zero number\n    create a variable named \"next_non_zero_position\" and set it to 0\n\n    # Loop through each number in the input array\n    for each number in input_array:\n        # If the number is not zero, move it to the position indicated by \"next_non_zero_position\"\n        if number is not zero:\n            move number to the position indicated by \"next_non_zero_position\"\n            increment \"next_non_zero_position\" by 1\n\n    # After we've processed all numbers, fill the rest of the array with zeros\n    for each remaining position from \"next_non_zero_position\" to the end of the array:\n        fill the position with a zero\n\n    # Return the modified array\n    return input_array",
    "505": "function permutation_coefficient(n, k):\n    # Check if n is less than k\n    if n < k:\n        # If true, return an error message\n        return \"Error: n should be greater than or equal to k\"\n\n    # Initialize the result as 1\n    let result be 1\n\n    # Calculate the factorial of n\n    for i from 1 to n do\n        result = result * i\n\n    # Calculate the factorial of k\n    for i from 1 to k do\n        result = result / i\n\n    # Calculate the factorial of n-k\n    for i from 1 to n-k do\n        result = result / i\n\n    # Return the result\n    return result",
    "506": "function remove_specific_words(word_list, words_to_remove):\n    # Create an empty list to store the words that are not to be removed\n    create an empty list named \"filtered_list\"\n\n    # Loop through each word in the word list\n    for each word in word_list:\n        # Check if the word is in the list of words to remove\n        if word is not in words_to_remove:\n            # If it's not in the list of words to remove, add it to the filtered list\n            add word to \"filtered_list\"\n\n    # Return the filtered list\n    return \"filtered_list\"",
    "507": "function check_common_elements_order(list1, list2):\n    # Create an empty list to store the common elements\n    create an empty list named \"common_elements\"\n\n    # Loop through each element in the first list\n    for each element in list1:\n        # Check if the element is in the second list\n        if element is in list2:\n            # If it is, add it to the common_elements list\n            add element to \"common_elements\"\n\n    # Compare the two lists\n    if \"common_elements\" is equal to \"common_elements\" in the order:\n        # If they are the same, return True\n        return True\n    else:\n        # If they are not the same, return False\n        return False",
    "508": "function find_average_of_odd_numbers(given_odd_number):\n    # Initialize a variable to keep track of the sum of odd numbers\n    initialize a variable named \"sum_of_odd_numbers\" to 0\n\n    # Initialize a variable to keep track of the count of odd numbers\n    initialize a variable named \"count_of_odd_numbers\" to 0\n\n    # Loop through each number from 1 to the given odd number\n    for each number from 1 to given_odd_number:\n        # Check if the number is odd\n        if number is odd:\n            # If it is, add it to the sum of odd numbers and increment the count\n            add number to \"sum_of_odd_numbers\"\n            increment \"count_of_odd_numbers\" by 1\n\n    # Calculate the average by dividing the sum by the count\n    calculate the average by dividing \"sum_of_odd_numbers\" by \"count_of_odd_numbers\"\n\n    # Return the average\n    return the calculated average",
    "509": "function find_subsequences(array, k):\n    # Initialize count to 0\n    count = 0\n\n    # Loop through each element in the array\n    for each element in array:\n        # If the element is less than k, increment count\n        if element < k:\n            count = count + 1\n\n    # Return the count\n    return count",
    "510": "function find_minimum_sum_of_factors(number):\n    # Create a variable to keep track of the sum of factors\n    create a variable named \"sum_of_factors\" and set it to 0\n\n    # Loop from 1 to the number\n    for each integer i from 1 to number:\n        # Check if i is a factor of the number\n        if number modulo i equals 0:\n            # If it is, add it to the sum of factors\n            add i to \"sum_of_factors\"\n\n    # Return the sum of factors\n    return sum_of_factors",
    "511": "function count_element_frequency(tuple, element):\n    # Initialize a counter to keep track of the frequency of the element\n    initialize a variable named \"frequency\" to 0\n\n    # Loop through each item in the tuple\n    for each item in tuple:\n        # If the item is the element we're looking for, increment the frequency counter\n        if item is equal to element:\n            increment \"frequency\" by 1\n        # If the item is a tuple, recursively count the frequency of the element in it\n        else if item is a tuple:\n            increment \"frequency\" by count_element_frequency(item, element)\n\n    # Return the final frequency count\n    return frequency",
    "512": "function convert_tuple_to_list(input_tuple, string_to_add):\n    # Create an empty list to store the result\n    create an empty list named \"result\"\n\n    # Loop through each element in the input tuple\n    for each element in input_tuple:\n        # Add the element and the string to the result list\n        add element to \"result\"\n        add string_to_add to \"result\"\n\n    # Return the result list\n    return \"result\"",
    "513": "function sum_tuple_elements(tuple_list):\n    # Create a variable to keep track of the sum\n    create a variable named \"sum\" and set it to 0\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Add each element in the tuple to the sum\n        for each element in tuple:\n            add element to \"sum\"\n\n    # Return the sum\n    return \"sum\"",
    "514": "function check_subset_sum_divisible_by_m(input_list, m):\n    # Calculate the sum of all elements in the list\n    calculate the sum of all elements in \"input_list\" and store it in \"total_sum\"\n\n    # If the total sum is divisible by m, return True\n    if total_sum is divisible by m:\n        return True\n\n    # If the total sum is not divisible by m, return False\n    return False",
    "515": "function radix_sort(input_list):\n    # Find the maximum number in the list\n    max_number = find_max_number(input_list)\n\n    # Start with a place value of 1 (ones place)\n    place_value = 1\n\n    # Loop until we've sorted all the digits in the number\n    while max_number / place_value > 0:\n        # Use counting sort to sort the list based on the current place value\n        input_list = counting_sort(input_list, place_value)\n\n        # Move to the next place value\n        place_value *= 10\n\n    # Return the sorted list\n    return input_list\n\nfunction find_max_number(input_list):\n    # Initialize max_number to the smallest possible number\n    max_number = -infinity\n\n    # Loop through each number in the list\n    for each number in input_list:\n        # If this number is larger than max_number, update max_number\n        if number > max_number:\n            max_number = number\n\n    # Return the maximum number\n    return max_number\n\nfunction counting_sort(input_list, place_value):\n    # Create an array to store the count of each digit\n    count_array = [0] * 10\n\n    # Create an array to store the sorted list\n    sorted_list = [0] * len(input_list)\n\n    # Count the occurrences of each digit\n    for each number in input_list:\n        index = (number / place_value) % 10\n        count_array[index] += 1\n\n    # Modify the count array to hold the actual position of each digit in the sorted list\n    for i in range(1, 10):\n        count_array[i] += count_array[i - 1]\n\n    # Build the sorted list\n    for i in range(len(input_list) - 1, -1, -1):\n        index = (input_list[i] / place_value) % 10\n        sorted_list[count_array[index] - 1] = input_list[i]\n        count_array[index] -= 1\n\n    # Return the sorted list\n    return sorted_list",
    "516": "function find_largest_positive_number(input_list):\n    # Create a variable to keep track of the largest positive number we've seen so far\n    create a variable named \"largest_positive_number\" and set it to None\n\n    # Loop through each number in the input list\n    for each number in input_list:\n        # Check if the number is positive\n        if number is greater than 0:\n            # If it is, check if it's larger than our current largest positive number\n            if number is greater than \"largest_positive_number\" or \"largest_positive_number\" is None:\n                # If it is, update our largest positive number\n                set \"largest_positive_number\" to number\n\n    # Return the largest positive number we've found\n    return \"largest_positive_number\"",
    "517": "function find_square_root(number):\n    # Check if the number is a perfect square\n    if number is not a perfect square:\n        # If it's not, return a message indicating it's not a perfect square\n        return \"The number is not a perfect square\"\n    else:\n        # If it is, calculate the square root\n        calculate the square root of the number\n        # Return the square root\n        return the square root",
    "518": "function calculate_tetrahedron_volume(edge_length):\n    # Calculate the volume of a tetrahedron using the formula:\n    # volume = sqrt(2) * edge_length^3 / 12\n    volume = sqrt(2) * edge_length^3 / 12\n\n    # Return the calculated volume\n    return volume",
    "519": "function find_lcm(array):\n    # Initialize the result as the first element of the array\n    let result = array[0]\n\n    # Loop through the array from the second element to the end\n    for each element in array starting from the second element:\n        # Find the gcd of the current result and the current element\n        let gcd = find_gcd(result, element)\n\n        # Calculate the lcm of the current result and the current element\n        let lcm = (result * element) / gcd\n\n        # Update the result with the new lcm\n        result = lcm\n\n    # Return the final result\n    return result\n\nfunction find_gcd(a, b):\n    # Base case\n    if b == 0:\n        return a\n    else:\n        # Recursive call\n        return find_gcd(b, a % b)",
    "520": "function is_scalene_triangle(side1, side2, side3):\n    # Check if the triangle is valid\n    if side1 + side2 <= side3 or side1 + side3 <= side2 or side2 + side3 <= side1:\n        return \"Invalid triangle\"\n\n    # Check if all sides are different\n    if side1 != side2 and side1 != side3 and side2 != side3:\n        return \"Scalene triangle\"\n    else:\n        return \"Not a scalene triangle\"",
    "521": "function find_longest_bitonic_subsequence(input_array):\n    # Create an empty collection to keep track of longest bitonic subsequences\n    create an empty collection named \"longest_bitonic_subsequences\"\n\n    # Loop through each element in the input array\n    for each element in input_array:\n        # Check if the current element is greater than the previous element\n        if element is greater than the previous element:\n            # If it is, add it to the current bitonic subsequence\n            add element to \"current_bitonic_subsequence\"\n        else:\n            # If it's not, start a new bitonic subsequence with the current element\n            create a new collection named \"current_bitonic_subsequence\"\n            add element to \"current_bitonic_subsequence\"\n\n        # Check if the current bitonic subsequence is longer than the longest bitonic subsequence found so far\n        if length of \"current_bitonic_subsequence\" is greater than length of \"longest_bitonic_subsequence\":\n            # If it is, replace the longest bitonic subsequence with the current bitonic subsequence\n            replace \"longest_bitonic_subsequence\" with \"current_bitonic_subsequence\"\n\n    # Return the longest bitonic subsequence\n    return \"longest_bitonic_subsequence\"",
    "522": "function check_string(input_string, length):\n    # Check if the length of the string is equal to the specified length\n    if length of input_string is not equal to length:\n        return False\n\n    # Check if the string has a capital letter\n    if there is no match for a capital letter in input_string:\n        return False\n\n    # Check if the string has a lower case letter\n    if there is no match for a lower case letter in input_string:\n        return False\n\n    # Check if the string has a number\n    if there is no match for a number in input_string:\n        return False\n\n    # If all checks pass, return True\n    return True",
    "523": "function find_sum_of_max_increasing_subsequence(array):\n    # Initialize variables\n    set max_sum to 0\n    set current_sum to 0\n    set max_element to the smallest possible integer\n\n    # Loop through the array\n    for each element in array:\n        # If the current element is greater than the previous one\n        if element is greater than max_element:\n            # Add the current element to the current sum\n            add element to current_sum\n            # Update the max_element\n            set max_element to element\n        else:\n            # If the current element is not greater than the previous one\n            # Reset the current sum and the max_element\n            set current_sum to 0\n            set max_element to the smallest possible integer\n\n        # Update the max_sum if the current sum is greater\n        if current_sum is greater than max_sum:\n            set max_sum to current_sum\n\n    # Return the max_sum\n    return max_sum",
    "524": "function check_parallel(line1, line2):\n    # Calculate the slope of the first line\n    calculate the slope of line1\n\n    # Calculate the slope of the second line\n    calculate the slope of line2\n\n    # Check if the slopes are equal\n    if slope of line1 is equal to slope of line2:\n        # If they are, the lines are parallel\n        return True\n    else:\n        # If they aren't, the lines are not parallel\n        return False",
    "525": "function capitalize_first_and_last_letters(input_string):\n    # Split the input string into words\n    split input_string into words\n\n    # Create an empty list to store the modified words\n    create an empty list named \"modified_words\"\n\n    # Loop through each word in the list of words\n    for each word in words:\n        # If the word is not empty\n        if word is not empty:\n            # Capitalize the first and last letters of the word\n            capitalize the first letter of the word\n            capitalize the last letter of the word\n            # Add the modified word to the list of modified words\n            add the modified word to \"modified_words\"\n\n    # Join the list of modified words into a single string\n    join \"modified_words\" into a single string\n\n    # Return the modified string\n    return the modified string",
    "526": "function find_pairs_with_sum(input_array, target_sum):\n    # Create an empty collection to keep track of numbers we've seen\n    create an empty collection named \"seen_numbers\"\n\n    # Create an empty collection to keep track of pairs\n    create an empty collection named \"pairs\"\n\n    # Loop through each number in the input array\n    for each number in input_array:\n        # Calculate the difference between the target sum and the current number\n        calculate the difference between target_sum and number\n\n        # Check if we've come across this difference before\n        if difference is already in \"seen_numbers\":\n            # If we have, this is a pair whose sum equals the target sum, so add it to the pairs collection\n            add a pair containing the difference and the current number to \"pairs\"\n\n        else:\n            # If it's a new number, add it to our collection to remember it\n            add number to \"seen_numbers\"\n\n    # Return the pairs collection\n    return pairs",
    "527": "function find_min_length_lists(list_of_lists):\n    # Initialize a variable to keep track of the minimum length\n    set minimum_length to infinity\n\n    # Initialize a list to keep track of the lists with minimum length\n    create an empty list named \"min_length_lists\"\n\n    # Loop through each list in the list of lists\n    for each list in list_of_lists:\n        # Check if the length of the current list is less than the minimum length\n        if length of list is less than minimum_length:\n            # If it is, update the minimum length and clear the list of minimum length lists\n            set minimum_length to length of list\n            clear min_length_lists\n            add list to min_length_lists\n        else if length of list is equal to minimum_length:\n            # If it is equal to the minimum length, add it to the list of minimum length lists\n            add list to min_length_lists\n\n    # Return the list of lists with minimum length\n    return min_length_lists",
    "528": "function find_nth_jacobsthal_lucas_number(n):\n    # If n is 0, return 2\n    if n is 0:\n        return 2\n\n    # If n is 1, return 1\n    if n is 1:\n        return 1\n\n    # Initialize variables for the two previous numbers\n    previous_number_1 = 2\n    previous_number_2 = 1\n\n    # Loop from 2 to n\n    for i from 2 to n:\n        # Calculate the next number as the sum of the two previous numbers\n        next_number = previous_number_1 + 2 * previous_number_2\n\n        # Update the previous numbers for the next iteration\n        previous_number_2 = previous_number_1\n        previous_number_1 = next_number\n\n    # Return the nth number\n    return next_number",
    "529": "function find_negative_ratio(array):\n    # Initialize a counter for negative numbers\n    set a variable named \"negative_count\" to 0\n\n    # Initialize a counter for total numbers\n    set a variable named \"total_count\" to 0\n\n    # Loop through each number in the array\n    for each number in array:\n        # Increment the total count\n        increment \"total_count\" by 1\n\n        # Check if the number is negative\n        if number is less than 0:\n            # If it is, increment the negative count\n            increment \"negative_count\" by 1\n\n    # Calculate the ratio of negative numbers\n    set a variable named \"ratio\" to \"negative_count\" divided by \"total_count\"\n\n    # Return the ratio\n    return ratio",
    "530": "function find_minimum_coins(value, coin_values):\n    # Create a variable to keep track of the minimum number of coins\n    create a variable named \"min_coins\" and set it to infinity\n\n    # Loop through each coin value\n    for each coin in coin_values:\n        # If the coin value is less than or equal to the value, calculate the minimum number of coins\n        if coin is less than or equal to value:\n            # Calculate the minimum number of coins for the remaining value\n            calculate the minimum number of coins for the remaining value (value - coin)\n\n            # If the calculated number of coins is less than the current minimum, update the minimum\n            if the calculated number of coins is less than min_coins:\n                update min_coins to the calculated number of coins\n\n    # If no coin value is less than or equal to the value, return a signal (like None or a message)\n    if min_coins is still infinity:\n        return None\n    else:\n        return min_coins",
    "531": "function are_permutations(string1, string2):\n    # If the lengths of the strings are different, they can't be permutations of each other\n    if length of string1 is not equal to length of string2:\n        return False\n\n    # Create a dictionary to keep track of character counts in string1\n    create an empty dictionary named \"char_counts\"\n\n    # Loop through each character in string1\n    for each character in string1:\n        # If the character is already in the dictionary, increment its count\n        if character is already in \"char_counts\":\n            increment the count of character in \"char_counts\"\n        else:\n            # If the character is not in the dictionary, add it with a count of 1\n            add character to \"char_counts\" with a count of 1\n\n    # Loop through each character in string2\n    for each character in string2:\n        # If the character is not in the dictionary, or its count is 0, the strings are not permutations of each other\n        if character is not in \"char_counts\" or count of character in \"char_counts\" is 0:\n            return False\n        else:\n            # If the character is in the dictionary, decrement its count\n            decrement the count of character in \"char_counts\"\n\n    # If we've checked all characters and found no discrepancies, the strings are permutations of each other\n    return True",
    "532": "function remove_elements_from_tuple(input_tuple, data_type):\n    # Create an empty list to store the elements that are not of the specified data type\n    create an empty list named \"filtered_elements\"\n\n    # Loop through each element in the input tuple\n    for each element in input_tuple:\n        # Check if the element is not of the specified data type\n        if type of element is not equal to data_type:\n            # If it's not of the specified data type, add it to our list\n            add element to \"filtered_elements\"\n\n    # Convert the list back into a tuple and return it\n    return convert \"filtered_elements\" to a tuple",
    "533": "function find_pattern_in_string(original_string, pattern):\n    # Create an empty list to store the locations of the pattern\n    create an empty list named \"pattern_locations\"\n\n    # Loop through the original string\n    for each character in original_string:\n        # Check if the current character and the next few characters form the pattern\n        if the next few characters in original_string form the pattern:\n            # If they do, add the location of the pattern to the list\n            add the location of the pattern to \"pattern_locations\"\n\n    # Return the list of pattern locations\n    return \"pattern_locations\"",
    "534": "function find_top_or_bottom_surface_area_of_cylinder(radius, height):\n    # Calculate the area of the top and bottom surfaces of the cylinder\n    top_surface_area = calculate_area_of_circle(radius)\n    bottom_surface_area = calculate_area_of_circle(radius)\n\n    # Add the top and bottom surface areas together to get the total surface area\n    total_surface_area = top_surface_area + bottom_surface_area\n\n    # Return the total surface area\n    return total_surface_area\n\nfunction calculate_area_of_circle(radius):\n    # Calculate the area of a circle using the formula: \u03c0r\u00b2\n    area = \u03c0 * radius * radius\n\n    # Return the calculated area\n    return area",
    "535": "function select_nth_items(input_list, n):\n    # Create an empty list to store the nth items\n    create an empty list named \"nth_items\"\n\n    # Loop through each item in the input list\n    for each item in input_list:\n        # Check if the index of the item is a multiple of n\n        if index of item modulo n equals 0:\n            # If it is, add the item to our list of nth items\n            add item to \"nth_items\"\n\n    # Return the list of nth items\n    return \"nth_items\"",
    "536": "function find_first_repeated_word(input_string):\n    # Create an empty collection to keep track of words we've seen\n    create an empty collection named \"seen_words\"\n\n    # Split the input string into words\n    split input_string into words\n\n    # Loop through each word in the list of words\n    for each word in words:\n        # Check if we've come across this word before\n        if word is already in \"seen_words\":\n            # If we have, this is the first repeated word, so return it\n            return word\n        else:\n            # If it's a new word, add it to our collection to remember it\n            add word to \"seen_words\"\n\n    # If we've checked all words and found no repeats, return a signal (like None or a message)\n    return None",
    "537": "function convert_string_list_to_tuple(input_list):\n    # Create an empty tuple to store the converted elements\n    create an empty tuple named \"converted_tuple\"\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # Convert the element to a tuple\n        convert element to a tuple\n\n        # Add the converted tuple to the \"converted_tuple\"\n        add the converted tuple to \"converted_tuple\"\n\n    # Return the \"converted_tuple\"\n    return \"converted_tuple\"",
    "538": "function power_in_bases(number, bases):\n    # Create an empty list to store the powers\n    create an empty list named \"powers\"\n\n    # Loop through each base in the bases list\n    for each base in bases:\n        # Calculate the power of the number in the base\n        power = number raised to the power of base\n\n        # Add the power to the powers list\n        add power to \"powers\"\n\n    # Return the powers list\n    return \"powers\"",
    "539": "function find_frequency_difference(input_array):\n    # Create a dictionary to keep track of frequencies\n    create an empty dictionary named \"frequency_dict\"\n\n    # Loop through each element in the input array\n    for each element in input_array:\n        # If the element is already in the dictionary, increment its count\n        if element is already in \"frequency_dict\":\n            increment the count for element in \"frequency_dict\"\n        else:\n            # If it's a new element, add it to the dictionary with a count of 1\n            add element to \"frequency_dict\" with a count of 1\n\n    # Find the highest and lowest frequencies\n    highest_frequency = the highest value in \"frequency_dict\"\n    lowest_frequency = the lowest value in \"frequency_dict\"\n\n    # Return the difference between the highest and lowest frequencies\n    return highest_frequency - lowest_frequency",
    "540": "function is_abundant(number):\n    # Initialize sum to 0\n    sum = 0\n\n    # Loop from 1 to number\n    for i from 1 to number:\n        # If i is a divisor of number, add it to sum\n        if i is a divisor of number:\n            sum = sum + i\n\n    # If sum is greater than number, return True\n    if sum > number:\n        return True\n    else:\n        # If sum is less than or equal to number, return False\n        return False",
    "541": "function replace_spaces_commas_dots_with_colon(input_string):\n    # Import the re module for regular expressions\n    import re\n\n    # Use the sub function from the re module to replace all spaces, commas, and dots with a colon\n    output_string = re.sub('[ ,.]', ':', input_string)\n\n    # Return the modified string\n    return output_string",
    "542": "function add_two_numbers_and_print_digits(num1, num2):\n    # Add the two numbers\n    sum = num1 + num2\n\n    # Convert the sum to a string to find the number of digits\n    sum_as_string = convert sum to string\n\n    # Find the number of digits in the sum\n    number_of_digits = length of sum_as_string\n\n    # Print the number of digits\n    print number_of_digits",
    "543": "function flatten_tuple_list_to_string(tuple_list):\n    # Create an empty string to store the flattened result\n    create an empty string named \"flattened_string\"\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Loop through each item in the tuple\n        for each item in tuple:\n            # Convert the item to a string and add it to the flattened string\n            convert item to a string\n            add string to \"flattened_string\"\n\n    # Return the flattened string\n    return \"flattened_string\"",
    "544": "function toggle_first_and_last_bits(number):\n    # Check if the number is 0, in which case there are no bits to toggle\n    if number is 0:\n        return number\n\n    # Find the position of the first bit\n    find the position of the first set bit in number\n    let first_bit_position be the result\n\n    # Find the position of the last bit\n    find the position of the last set bit in number\n    let last_bit_position be the result\n\n    # Toggle the first bit\n    toggle the bit at position first_bit_position in number\n\n    # Toggle the last bit\n    toggle the bit at position last_bit_position in number\n\n    # Return the modified number\n    return number",
    "545": "function find_last_occurrence(input_string, target_character):\n    # Initialize a variable to store the last occurrence of the target character\n    last_occurrence = None\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the current character is the target character\n        if character is equal to target_character:\n            # If it is, update the last occurrence\n            last_occurrence = character\n\n    # Return the last occurrence of the target character\n    return last_occurrence",
    "546": "function hamming_distance(n):\n    # Initialize sum to 0\n    sum = 0\n\n    # Loop from 1 to n\n    for i from 1 to n:\n        # Calculate hamming distance between i and i+1\n        hamming_distance = count_set_bits(i ^ (i + 1))\n\n        # Add hamming distance to sum\n        sum = sum + hamming_distance\n\n    # Return sum\n    return sum\n\nfunction count_set_bits(n):\n    # Initialize count to 0\n    count = 0\n\n    # Loop while n is greater than 0\n    while n > 0:\n        # If last bit is set, increment count\n        if n & 1:\n            count = count + 1\n\n        # Right shift n by 1\n        n = n >> 1\n\n    # Return count\n    return count",
    "547": "function find_length_of_longest_increasing_subsequence(sequence):\n    # Create a variable to keep track of the length of the longest increasing subsequence\n    create a variable named \"max_length\" and set it to 0\n\n    # Loop through each number in the sequence\n    for each number in sequence:\n        # Create a variable to keep track of the current length of the increasing subsequence\n        create a variable named \"current_length\" and set it to 1\n\n        # Loop through each subsequent number in the sequence\n        for each subsequent number in sequence:\n            # Check if the current number is less than the subsequent number\n            if number is less than subsequent number:\n                # If it is, increment the current length\n                increment \"current_length\" by 1\n            else:\n                # If it's not, break out of the loop\n                break\n\n        # Check if the current length is greater than the max length\n        if \"current_length\" is greater than \"max_length\":\n            # If it is, update the max length\n            set \"max_length\" to \"current_length\"\n\n    # Return the max length\n    return \"max_length\"",
    "548": "function sum_of_fifth_power_of_first_n_odd_numbers(n):\n    # Initialize sum to 0\n    initialize sum to 0\n\n    # Initialize count to 0\n    initialize count to 0\n\n    # Initialize number to 1\n    initialize number to 1\n\n    # Loop until count is equal to n\n    while count is not equal to n:\n        # Check if the number is odd\n        if number modulo 2 is not equal to 0:\n            # Increment count by 1\n            increment count by 1\n\n            # Add the fifth power of the number to the sum\n            add number to the power of 5 to the sum\n\n        # Increment number by 2\n        increment number by 2\n\n    # Return the sum\n    return sum",
    "549": "function find_max_in_rotated_array(input_array):\n    # Initialize start and end pointers\n    set start to 0\n    set end to length of input_array - 1\n\n    # Continue until start and end pointers meet\n    while start <= end:\n        # Calculate mid point\n        set mid to (start + end) / 2\n\n        # If mid element is greater than next and previous elements, return mid element\n        if mid is greater than previous and next elements:\n            return input_array[mid]\n\n        # If mid element is greater than the last element, then the maximum element lies in the left half\n        if input_array[mid] > input_array[end]:\n            set start to mid + 1\n        # If mid element is less than the last element, then the maximum element lies in the right half\n        else:\n            set end to mid - 1\n\n    # If no such element is found, return -1\n    return -1",
    "550": "function extract_column(nested_list, column_index):\n    # Create an empty list to store the extracted column\n    create an empty list named \"extracted_column\"\n\n    # Loop through each sublist in the nested list\n    for each sublist in nested_list:\n        # Check if the sublist has enough elements to extract the column\n        if the length of sublist is greater than or equal to column_index:\n            # If it does, add the element at the specified column index to the extracted column\n            add the element at index column_index in sublist to \"extracted_column\"\n\n    # Return the extracted column\n    return \"extracted_column\"",
    "551": "function is_sequence_linear(sequence):\n    # Create a variable to keep track of the previous item\n    create a variable named \"previous_item\" and set it to None\n\n    # Loop through each item in the sequence\n    for each item in sequence:\n        # If the previous item is not None and it's not equal to the current item\n        if previous_item is not None and previous_item is not equal to item:\n            # The sequence is not linear, so return False\n            return False\n        else:\n            # The sequence is linear, so set the previous item to the current item\n            set previous_item to item\n\n    # If we've checked all items and found no non-linearities, return True\n    return True",
    "552": "function convert_tuple_to_float(input_tuple):\n    # Create an empty string to store the converted number\n    create an empty string named \"converted_number\"\n\n    # Loop through each item in the input tuple\n    for each item in input_tuple:\n        # Convert the item to a string and add it to our number string\n        convert item to a string and add it to \"converted_number\"\n\n    # Convert the number string to a floating-point number and return it\n    convert \"converted_number\" to a floating-point number and return it",
    "553": "function find_odd_numbers(input_list):\n    # Create an empty list to store the odd numbers\n    create an empty list named \"odd_numbers\"\n\n    # Loop through each item in the input list\n    for each item in input_list:\n        # Check if the item is an odd number\n        if item is an odd number:\n            # If it is, add it to the list of odd numbers\n            add item to \"odd_numbers\"\n\n    # Return the list of odd numbers\n    return \"odd_numbers\"",
    "554": "function find_difference(n):\n    # Initialize variables to store the sums\n    create a variable named \"cubes_sum\" and set it to 0\n    create a variable named \"sum_n\" and set it to 0\n\n    # Loop from 1 to n\n    for i from 1 to n:\n        # Add the cube of i to the cubes_sum\n        add i cubed to cubes_sum\n        # Add i to the sum_n\n        add i to sum_n\n\n    # Calculate the difference between the cubes_sum and sum_n\n    create a variable named \"difference\" and set it to cubes_sum minus sum_n\n\n    # Return the difference\n    return difference",
    "555": "function count_pairs_with_odd_xor(input_list):\n    # Initialize a counter to keep track of the number of pairs with odd XOR\n    initialize a counter named \"odd_xor_pairs_count\" to 0\n\n    # Loop through each pair in the input list\n    for each pair in input_list:\n        # Calculate the XOR of the pair\n        calculate the XOR of the pair\n\n        # Check if the XOR is odd\n        if the XOR is odd:\n            # If it is, increment the counter\n            increment \"odd_xor_pairs_count\" by 1\n\n    # Return the count of pairs with odd XOR\n    return \"odd_xor_pairs_count\"",
    "556": "function toggle_case(input_string):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is uppercase\n        if character is uppercase:\n            # If it is, convert it to lowercase and add it to the result\n            add lowercase version of character to \"result\"\n        else:\n            # If it's not uppercase, convert it to uppercase and add it to the result\n            add uppercase version of character to \"result\"\n\n    # Return the result string\n    return \"result\"",
    "557": "function digit_distance(num1, num2):\n    # Convert the numbers to strings\n    convert num1 to a string and assign it to \"str_num1\"\n    convert num2 to a string and assign it to \"str_num2\"\n\n    # Initialize a variable to keep track of the total distance\n    create a variable named \"total_distance\" and set it to 0\n\n    # Loop through each digit in the shorter number\n    for each digit in the shorter string:\n        # Find the difference between the digits\n        find the difference between the corresponding digits in \"str_num1\" and \"str_num2\"\n        and assign it to \"distance\"\n\n        # Add the absolute value of the difference to the total distance\n        add the absolute value of \"distance\" to \"total_distance\"\n\n    # If the numbers have different lengths, add the remaining digits from the longer number\n    if \"str_num1\" and \"str_num2\" have different lengths:\n        # Find the difference in lengths\n        find the difference in lengths between \"str_num1\" and \"str_num2\"\n        and assign it to \"difference\"\n\n        # Add the remaining digits from the longer number to the total distance\n        add \"difference\" to \"total_distance\"\n\n    # Return the total distance\n    return \"total_distance\"",
    "558": "function find_largest_sum_subarray(input_array):\n    # Initialize the maximum sum and the current sum to the first element of the array\n    set maximum_sum to the first element of input_array\n    set current_sum to the first element of input_array\n\n    # Loop through the rest of the array\n    for each element in input_array starting from the second element:\n        # Update the current sum to be the maximum of the current element and the sum of the current element and the previous current sum\n        set current_sum to the maximum of current_sum and current_sum + element\n\n        # Update the maximum sum to be the maximum of the current sum and the maximum sum\n        set maximum_sum to the maximum of maximum_sum and current_sum\n\n    # Return the maximum sum\n    return maximum_sum",
    "559": "function find_union_of_tuples(tuple1, tuple2):\n    # Create an empty collection to keep track of elements we've seen\n    create an empty collection named \"union_elements\"\n\n    # Loop through each element in the first tuple\n    for each element in tuple1:\n        # Add the element to the collection\n        add element to \"union_elements\"\n\n    # Loop through each element in the second tuple\n    for each element in tuple2:\n        # Check if we've come across this element before\n        if element is already in \"union_elements\":\n            # If it's a new element, add it to our collection to remember it\n            add element to \"union_elements\"\n\n    # Return the collection of union elements\n    return \"union_elements\"",
    "560": "function assign_pairs(tuple_of_pairs):\n    # Create an empty dictionary to keep track of pairs\n    create an empty dictionary named \"pair_dict\"\n\n    # Loop through each pair in the tuple\n    for each pair in tuple_of_pairs:\n        # Check if we've come across this pair before\n        if pair is already in \"pair_dict\":\n            # If we have, this is the first repeated pair, so return it\n            return pair\n        else:\n            # If it's a new pair, add it to our dictionary to remember it\n            add pair to \"pair_dict\"\n\n    # If we've checked all pairs and found no repeats, return a signal (like None or a message)\n    return None",
    "561": "function find_max_length_sublist(input_list):\n    # Initialize max_length to 0\n    max_length = 0\n\n    # Initialize current_length to 0\n    current_length = 0\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # If the element is a list\n        if element is a list:\n            # Increase current_length by the length of the sublist\n            current_length += length of element\n        else:\n            # If the element is not a list, reset current_length to 0\n            current_length = 0\n\n        # If current_length is greater than max_length, update max_length\n        if current_length > max_length:\n            max_length = current_length\n\n    # Return max_length\n    return max_length",
    "562": "function extract_values_between_quotation_marks(input_string):\n    # Create an empty list to store the values\n    create an empty list named \"values\"\n\n    # Initialize a variable to keep track of whether we're currently inside a quotation mark\n    set a boolean variable named \"inside_quotation_mark\" to False\n\n    # Initialize an empty string to store the current value\n    set an empty string named \"current_value\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If we're currently inside a quotation mark\n        if \"inside_quotation_mark\" is True:\n            # If the character is a quotation mark, we're done with this value\n            if character is a quotation mark:\n                # Add the current value to the list of values\n                add \"current_value\" to \"values\"\n\n                # Reset the current value and the quotation mark status\n                set \"current_value\" to an empty string\n                set \"inside_quotation_mark\" to False\n            else:\n                # Otherwise, add the character to the current value\n                add character to \"current_value\"\n        else:\n            # If we're not inside a quotation mark, check if the character is a quotation mark\n            if character is a quotation mark:\n                # If it is, we're now inside a quotation mark\n                set \"inside_quotation_mark\" to True\n\n    # Return the list of values\n    return \"values\"",
    "563": "function count_unequal_element_pairs(input_array):\n    # Initialize a counter for unequal element pairs\n    set counter to 0\n\n    # Loop through each element in the array\n    for each element in input_array:\n        # Loop through each other element in the array\n        for each other_element in input_array:\n            # Check if the elements are unequal\n            if element is not equal to other_element:\n                # If they are, increment the counter\n                increment counter by 1\n\n    # Return the final count of unequal element pairs\n    return counter",
    "564": "function split_string_into_characters(input_string):\n    # Create an empty list to store the characters\n    create an empty list named \"characters\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Add the character to the list\n        add character to \"characters\"\n\n    # Return the list of characters\n    return \"characters\"",
    "565": "function get_sum_of_digits(number):\n    # Initialize a variable to store the sum\n    set sum to 0\n\n    # Convert the number to a string to make it iterable\n    convert number to string and store it in a variable named \"number_string\"\n\n    # Loop through each digit in the number\n    for each digit in number_string:\n        # Add the digit to the sum\n        add digit to sum\n\n    # Return the sum\n    return sum",
    "566": "function is_sorted(list):\n    # Loop through each element in the list\n    for each element in list:\n        # Check if the current element is less than the previous one\n        if element is less than the previous element:\n            # If it is, the list is not sorted, so return False\n            return False\n\n    # If we've checked all elements and found no unsorted pairs, return True\n    return True",
    "567": "function create_list_of_empty_dictionaries(number_of_dictionaries):\n    # Create an empty list to store the dictionaries\n    create an empty list named \"dictionaries\"\n\n    # Loop through the number of dictionaries we want to create\n    for each number in range from 1 to number_of_dictionaries:\n        # Create an empty dictionary\n        create an empty dictionary named \"new_dictionary\"\n\n        # Add the new dictionary to the list\n        add \"new_dictionary\" to \"dictionaries\"\n\n    # Return the list of dictionaries\n    return \"dictionaries\"",
    "568": "function sort_sublists(list_of_lists):\n    # Loop through each sublist in the list of lists\n    for each sublist in list_of_lists:\n        # Sort the sublist\n        sort sublist\n\n    # Return the sorted list of lists\n    return list_of_lists",
    "569": "function remove_words_containing_character(list_of_strings, character):\n    # Create an empty list to keep track of words that don't contain the character\n    create an empty list named \"words_without_character\"\n\n    # Loop through each string in the list of strings\n    for each string in list_of_strings:\n        # Check if the string contains the character\n        if character is not in string:\n            # If it doesn't, add the string to our list\n            add string to \"words_without_character\"\n\n    # Return the list of words that don't contain the character\n    return \"words_without_character\"",
    "570": "function find_max_sum_disjoint_pairs(input_array, k):\n    # Sort the input array in ascending order\n    sort input_array in ascending order\n\n    # Initialize a variable to keep track of the maximum sum\n    set max_sum to 0\n\n    # Loop through the array in pairs\n    for i from 0 to length of input_array - 1 by 2:\n        # If the sum of the current pair is less than or equal to k, add it to max_sum\n        if input_array[i] + input_array[i + 1] <= k:\n            max_sum = max_sum + input_array[i] + input_array[i + 1]\n\n    # Return the maximum sum\n    return max_sum",
    "571": "function remove_duplicates(list_of_lists):\n    # Create an empty collection to keep track of numbers we've seen\n    create an empty collection named \"seen_numbers\"\n\n    # Loop through each list in the list of lists\n    for each list in list_of_lists:\n        # Create an empty list to store the unique numbers from the current list\n        create an empty list named \"unique_numbers\"\n\n        # Loop through each number in the current list\n        for each number in list:\n            # Check if we've come across this number before\n            if number is already in \"seen_numbers\":\n                # If we have, this is a duplicate number, so skip it\n                continue\n            else:\n                # If it's a new number, add it to our collection to remember it\n                add number to \"seen_numbers\"\n                # And also add it to the \"unique_numbers\" list\n                add number to \"unique_numbers\"\n\n        # Replace the current list with the \"unique_numbers\" list\n        replace the current list with \"unique_numbers\"\n\n    # Return the modified list of lists\n    return list_of_lists",
    "572": "function calculate_product_of_unique_numbers(input_list):\n    # Create an empty collection to keep track of unique numbers\n    create an empty collection named \"unique_numbers\"\n\n    # Create a variable to keep track of the product of unique numbers\n    create a variable named \"product\" and set it to 1\n\n    # Loop through each number in the input list\n    for each number in input_list:\n        # Check if we've come across this number before\n        if number is already in \"unique_numbers\":\n            # If it's a duplicate, remove it from \"unique_numbers\" and from the product\n            remove number from \"unique_numbers\"\n            divide product by number\n        else:\n            # If it's a new number, add it to \"unique_numbers\" and multiply the product by it\n            add number to \"unique_numbers\"\n            multiply product by number\n\n    # Return the final product\n    return product",
    "573": "function find_surface_area_of_cylinder(radius, height):\n    # Calculate the base area of the cylinder\n    base_area = calculate the area of a circle with the given radius\n\n    # Calculate the lateral surface area of the cylinder\n    lateral_surface_area = calculate the area of a rectangle with the given radius and height\n\n    # Calculate the total surface area of the cylinder\n    total_surface_area = add the base_area and lateral_surface_area together\n\n    # Return the total surface area of the cylinder\n    return total_surface_area",
    "574": "function find_nth_not_multiple(n, number):\n    # Create a variable to keep track of the current number of non-multiples we've found\n    create a variable named \"count\" and set it to 0\n\n    # Create a variable to keep track of the current number we're checking\n    create a variable named \"current_number\" and set it to 1\n\n    # Loop until we've found n non-multiples\n    while count < n:\n        # Check if the current number is not a multiple of the given number\n        if current_number mod number is not equal to 0:\n            # If it's not a multiple, increment the count of non-multiples we've found\n            increment count by 1\n\n        # Increment the current number we're checking\n        increment current_number by 1\n\n    # Once we've found n non-multiples, return the number before that\n    return current_number - 1",
    "575": "function is_subarray(main_array, sub_array):\n    # Check if the length of the subarray is greater than the main array\n    if length of sub_array is greater than main_array:\n        # If it is, then the main array cannot be a subarray of the subarray\n        return False\n\n    # Initialize a variable to keep track of the current index in the main array\n    initialize a variable named \"main_index\" to 0\n\n    # Loop through each element in the subarray\n    for each element in sub_array:\n        # Check if the current element is in the main array starting from the current index\n        if element is in main_array starting from main_index:\n            # If it is, then increment the main index by 1\n            increment main_index by 1\n        else:\n            # If it's not, then the main array is not a subarray of the subarray\n            return False\n\n    # If we've checked all elements in the subarray and found no discrepancies, the main array is a subarray of the subarray\n    return True",
    "576": "function find_last_digit_in_factorial(number):\n    # Initialize the result as 1\n    initialize result as 1\n\n    # Loop from 1 to the given number\n    for i from 1 to number:\n        # Multiply the result by the current number\n        result = result * i\n\n    # Convert the result to a string to easily access the last digit\n    convert result to a string named \"result_string\"\n\n    # Return the last digit of the result\n    return the last character of \"result_string\"",
    "577": "function interleave_lists(list1, list2):\n    # Create an empty list to store the interleaved elements\n    create an empty list named \"interleaved_list\"\n\n    # Loop through each index in the lists\n    for each index in the range of the length of list1:\n        # Add the element from list1 at this index to the interleaved list\n        add list1[index] to \"interleaved_list\"\n\n        # Add the element from list2 at this index to the interleaved list\n        add list2[index] to \"interleaved_list\"\n\n    # Return the interleaved list\n    return \"interleaved_list\"",
    "578": "function find_dissimilar_elements(tuple1, tuple2):\n    # Create an empty list to store the dissimilar elements\n    create an empty list named \"dissimilar_elements\"\n\n    # Loop through each element in the first tuple\n    for each element in tuple1:\n        # Check if the element is not in the second tuple\n        if element is not in tuple2:\n            # If it's not in the second tuple, add it to the list of dissimilar elements\n            add element to \"dissimilar_elements\"\n\n    # Loop through each element in the second tuple\n    for each element in tuple2:\n        # Check if the element is not in the first tuple\n        if element is not in tuple1:\n            # If it's not in the first tuple, add it to the list of dissimilar elements\n            add element to \"dissimilar_elements\"\n\n    # Return the list of dissimilar elements\n    return \"dissimilar_elements\"",
    "579": "function extract_even_elements(nested_tuple):\n    # Create an empty list to store the even elements\n    create an empty list named \"even_elements\"\n\n    # Loop through each element in the nested tuple\n    for each element in nested_tuple:\n        # If the element is a tuple, recursively call this function on it\n        if element is a tuple:\n            add the result of extract_even_elements(element) to \"even_elements\"\n        # If the element is an integer, check if it's even\n        else if element is an integer:\n            if element modulo 2 equals 0:\n                # If it's even, add it to our list\n                add element to \"even_elements\"\n\n    # Return the list of even elements\n    return \"even_elements\"",
    "580": "function find_surface_area_of_square_pyramid(base_length, height):\n    # Calculate the area of the base of the pyramid\n    base_area = base_length * base_length\n\n    # Calculate the lateral surface area of the pyramid\n    lateral_surface_area = 4 * base_length * height\n\n    # Calculate the total surface area of the pyramid\n    total_surface_area = base_area + lateral_surface_area\n\n    # Return the total surface area of the pyramid\n    return total_surface_area",
    "581": "function is_dictionary_empty(input_dictionary):\n    # Check if the input is a dictionary\n    if type of input_dictionary is not dictionary:\n        # If it's not a dictionary, return a message indicating it's not a dictionary\n        return \"Input is not a dictionary\"\n\n    # Check if the dictionary is empty\n    if length of input_dictionary is 0:\n        # If it's empty, return True\n        return True\n    else:\n        # If it's not empty, return False\n        return False",
    "582": "function catalan_number(n):\n    # If n is less than 0, return 0\n    if n is less than 0:\n        return 0\n\n    # If n is 0 or 1, return 1\n    if n is 0 or n is 1:\n        return 1\n\n    # Initialize result\n    create a variable named \"result\" and set it to 0\n\n    # Calculate value using above recursive formula\n    for i from 0 to n:\n        result = result + catalan_number(i) * catalan_number(n-i-1)\n\n    # Return result\n    return result",
    "583": "function find_adverbs_and_positions(sentence):\n    # Import the regular expression module\n    import regex\n\n    # Define the pattern for adverbs\n    pattern = \"\\\\b(?:very|just|really|quite|fairly|kindly|slowly|tightly|carefully|clearly|deeply|doubtfully|eagerly|fervently|frantically|generously|greedily|hastily|hurriedly|impatiently|jovially|kindly|lazily|merrily|nervously|obediently|painfully|quickly|rapidly|sadly|scarcely|shyly|sickly|slowly|tightly|triumphantly|unbearably|uncomfortably|unexpectedly|unfortunately|ungraciously|unusually|warmly|warily|wickedly|wildly|wonderfully|wrongfully)\\\\b\"\n\n    # Use the regex module to find all matches of the pattern in the sentence\n    matches = regex.finditer(pattern, sentence)\n\n    # Create an empty list to store the results\n    results = []\n\n    # Loop through each match\n    for match in matches:\n        # Add the adverb and its position to the results list\n        results.append((match.group(), match.start()))\n\n    # Return the results\n    return results",
    "584": "function find_n_expensive_items(dataset, n):\n    # Create an empty heap queue\n    create an empty heap queue named \"heap\"\n\n    # Loop through each item in the dataset\n    for each item in dataset:\n        # If the heap is not full or the item is more expensive than the cheapest item in the heap\n        if heap is not full or item is more expensive than the root of heap:\n            # If the heap is full, remove the cheapest item from the heap\n            if heap is full:\n                remove the root of heap\n\n            # Add the item to the heap\n            add item to heap\n\n    # Return the n most expensive items\n    return the n items from heap",
    "585": "function split_and_add(array, split_index):\n    # Check if the split_index is valid\n    if split_index is not a valid index in array:\n        # If not, raise an error\n        raise an error \"Invalid split index\"\n\n    # Split the array at the given index\n    split_array = array[split_index:] + array[:split_index]\n\n    # Return the split array\n    return split_array",
    "586": "function convert_list_to_tuple(input_list):\n    # Create an empty tuple to store the converted list\n    create an empty tuple named \"converted_tuple\"\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # Add the element to the converted tuple\n        add element to \"converted_tuple\"\n\n    # Return the converted tuple\n    return \"converted_tuple\"",
    "587": "function find_difference(array):\n    # Initialize the smallest and largest values to the first element of the array\n    smallest = array[0]\n    largest = array[0]\n\n    # Loop through the array\n    for each number in array:\n        # If the current number is smaller than the smallest, update the smallest\n        if number < smallest:\n            smallest = number\n        # If the current number is larger than the largest, update the largest\n        if number > largest:\n            largest = number\n\n    # Return the difference between the largest and smallest\n    return largest - smallest",
    "588": "function find_perfect_squares(start, end):\n    # Create an empty list to store the perfect squares\n    create an empty list named \"perfect_squares\"\n\n    # Loop through each number from start to end\n    for each number from start to end:\n        # Calculate the square root of the number\n        calculate the square root of number\n\n        # Check if the square root is an integer\n        if the square root is an integer:\n            # If it is, the number is a perfect square\n            add number to \"perfect_squares\"\n\n    # Return the list of perfect squares\n    return perfect_squares",
    "589": "function convert_polar_to_rectangular(r, theta):\n    # Calculate the x-coordinate\n    x = r * cos(theta)\n\n    # Calculate the y-coordinate\n    y = r * sin(theta)\n\n    # Return the x and y coordinates as a tuple\n    return (x, y)",
    "590": "function interchange_first_and_last(input_list):\n    # Check if the list is empty\n    if input_list is empty:\n        # If it is, return the list as it is\n        return input_list\n    else:\n        # If it's not, get the first and last elements\n        first_element = get the first element from input_list\n        last_element = get the last element from input_list\n\n        # Remove the first and last elements from the list\n        remove the first element from input_list\n        remove the last element from input_list\n\n        # Add the first and last elements to the list in reverse order\n        add the last_element to the start of input_list\n        add the first_element to the end of input_list\n\n        # Return the modified list\n        return input_list",
    "591": "function find_sum_of_binomial_coefficients(n, r):\n    # Initialize sum to 0\n    initialize sum to 0\n\n    # Loop from 0 to r\n    for i from 0 to r:\n        # Calculate binomial coefficient using formula (n choose i)\n        calculate binomial coefficient using formula (n choose i)\n\n        # Add binomial coefficient to sum\n        add binomial coefficient to sum\n\n    # Return sum\n    return sum\n\nIn the pseudocode, \"n choose i\" is the binomial coefficient formula, which is (n! / (i! * (n-i)!))\n\nThe function find_sum_of_binomial_coefficients takes two parameters: n and r. It calculates the sum of the product of binomial coefficients for i from 0 to r. The binomial coefficient is calculated using the formula (n! / (i! * (n-i)!)) and added to the sum. Finally, the function returns the sum.",
    "592": "function remove_leading_zeroes(ip_address):\n    # Split the ip address into its components\n    split ip_address into components at \".\"\n\n    # Loop through each component\n    for each component in components:\n        # Remove leading zeroes from each component\n        remove leading zeroes from component\n\n    # Join the components back together with \".\"\n    join components with \".\"\n\n    # Return the modified ip address\n    return modified ip address",
    "593": "function find_difference_of_first_even_and_odd(input_list):\n    # Initialize variables to store the first even and odd numbers\n    first_even = None\n    first_odd = None\n\n    # Loop through each number in the input list\n    for each number in input_list:\n        # Check if the number is even\n        if number is even:\n            # If it's the first even number we've found, store it\n            if first_even is None:\n                first_even = number\n        else:\n            # If it's the first odd number we've found, store it\n            if first_odd is None:\n                first_odd = number\n\n        # If we've found both the first even and odd numbers, we can stop looking\n        if first_even is not None and first_odd is not None:\n            break\n\n    # If we didn't find any even or odd numbers, return a signal (like None or a message)\n    if first_even is None or first_odd is None:\n        return None\n\n    # Return the difference between the first even and odd numbers\n    return first_even - first_odd",
    "594": "function count_minimum_swaps(binary_string1, binary_string2):\n    # Check if the lengths of the binary strings are equal\n    if length of binary_string1 is not equal to length of binary_string2:\n        # If not, return an error message\n        return \"Error: The binary strings must be of equal length\"\n\n    # Initialize a counter for the number of swaps\n    initialize a variable named \"swaps\" to 0\n\n    # Loop through each character in the binary strings\n    for each character in binary_string1:\n        # If the characters are not equal\n        if character in binary_string1 is not equal to character in binary_string2:\n            # Increment the number of swaps\n            increment \"swaps\" by 1\n\n    # Return the number of swaps\n    return swaps",
    "595": "function find_tuple_size(input_tuple):\n    # Initialize a counter to keep track of the size of the tuple\n    initialize a variable named \"size\" to 0\n\n    # Loop through each item in the input tuple\n    for each item in input_tuple:\n        # Increment the size counter\n        increment \"size\" by 1\n\n    # Return the final size of the tuple\n    return size",
    "596": "function find_kth_element(array1, array2, k):\n    # Initialize two pointers, one for each array\n    set pointer1 to 0\n    set pointer2 to 0\n\n    # Initialize a counter to keep track of the current element\n    set counter to 0\n\n    # Loop until we've found the kth element\n    while counter < k:\n        # If pointer1 is out of bounds, we've exhausted array1, so return the kth element from array2\n        if pointer1 is out of bounds for array1:\n            return array2[pointer2 + k - counter]\n\n        # If pointer2 is out of bounds, we've exhausted array2, so return the kth element from array1\n        if pointer2 is out of bounds for array2:\n            return array1[pointer1 + k - counter]\n\n        # If the current element in array1 is smaller, increment pointer1 and increment counter\n        if array1[pointer1] is smaller than array2[pointer2]:\n            increment pointer1\n            increment counter\n        else:\n            # Otherwise, increment pointer2 and increment counter\n            increment pointer2\n            increment counter\n\n    # If we've found the kth element, return it\n    return array1[pointer1] or array2[pointer2]",
    "597": "function is_armstrong(number):\n    # Convert the number to a string to easily access each digit\n    convert number to string and store it in \"number_string\"\n\n    # Calculate the length of the number\n    calculate the length of \"number_string\" and store it in \"number_length\"\n\n    # Initialize a variable to store the sum of the digits raised to the power of the number of digits\n    set sum to 0\n\n    # Loop through each digit in the number\n    for each digit in \"number_string\":\n        # Raise the digit to the power of the number of digits and add it to the sum\n        convert digit to integer and raise it to the power of \"number_length\" and add it to sum\n\n    # Check if the sum is equal to the original number\n    if sum is equal to number:\n        # If it is, return True, indicating that the number is an Armstrong number\n        return True\n    else:\n        # If it's not, return False, indicating that the number is not an Armstrong number\n        return False",
    "598": "function find_sum_and_average(n):\n    # Initialize sum and count variables\n    set sum to 0\n    set count to 0\n\n    # Loop from 1 to n\n    for i from 1 to n:\n        # Add the current number to the sum\n        add i to sum\n        # Increment the count\n        increment count by 1\n\n    # Calculate the average\n    set average to sum divided by count\n\n    # Return the sum and average\n    return sum, average",
    "599": "function is_even(number):\n    # Use the bitwise AND operator to check if the least significant bit is set\n    if number AND 1 equals 0:\n        # If the result is 0, the number is even\n        return True\n    else:\n        # If the result is not 0, the number is odd\n        return False",
    "600": "function find_longest_chain(pairs):\n    # Create a dictionary to store the chains\n    create an empty dictionary named \"chains\"\n\n    # Loop through each pair in the pairs list\n    for each pair in pairs:\n        # If the first element of the pair is not in the chains dictionary, add it\n        if first element of pair is not in chains:\n            add pair to chains\n        else:\n            # If the second element of the pair is not in the chains dictionary, add it\n            if second element of pair is not in chains:\n                add pair to chains\n            else:\n                # If both elements are in the chains dictionary, check if the chain is longer\n                if length of chains[first element of pair] + length of chains[second element of pair] > length of chains[pair]:\n                    update chains[pair] with chains[first element of pair] + chains[second element of pair]\n\n    # Find the longest chain\n    longest_chain = empty list\n    for each chain in chains:\n        if length of chain > length of longest_chain:\n            longest_chain = chain\n\n    # Return the longest chain\n    return longest_chain",
    "601": "function find_first_repeated_character(input_string):\n    # Create an empty collection to keep track of characters we've seen\n    create an empty collection named \"seen_characters\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if we've come across this character before\n        if character is already in \"seen_characters\":\n            # If we have, this is the first repeated character, so return it\n            return character\n        else:\n            # If it's a new character, add it to our collection to remember it\n            add character to \"seen_characters\"\n\n    # If we've checked all characters and found no repeats, return a signal (like None or a message)\n    return None",
    "602": "function get_lucid_number(n):\n    # Create a variable to store the largest lucid number found\n    create a variable named \"largest_lucid_number\" and set it to 0\n\n    # Loop through each number from 1 to n\n    for each number from 1 to n:\n        # Check if the number is lucid\n        if number is lucid:\n            # If it is, update the largest lucid number found\n            set \"largest_lucid_number\" to number\n\n    # Return the largest lucid number found\n    return \"largest_lucid_number\"\n\nfunction is_lucid(number):\n    # Create a variable to store the sum of the digits of the number\n    create a variable named \"digit_sum\" and set it to 0\n\n    # Loop through each digit in the number\n    for each digit in number:\n        # Add the digit to the sum\n        add digit to \"digit_sum\"\n\n    # Check if the sum is a perfect square\n    if \"digit_sum\" is a perfect square:\n        # If it is, return True\n        return True\n    else:\n        # If it's not, return False\n        return False",
    "603": "function reverse_words_in_string(input_string):\n    # Split the input string into a list of words\n    split input_string into words\n\n    # Reverse the order of the words\n    reverse the order of words\n\n    # Join the words back into a string\n    join words into a string\n\n    # Return the reversed string\n    return the string",
    "604": "function is_prime(number):\n    # If the number is less than 2, it's not a prime number\n    if number is less than 2:\n        return False\n\n    # Check if the number is divisible by any number up to its square root\n    for each number from 2 to the square root of number:\n        if number is divisible by the current number:\n            return False\n\n    # If we've checked all numbers and found no divisors, it's a prime number\n    return True",
    "605": "function convert_degrees_to_radians(degrees):\n    # Define the constant pi\n    define pi as 3.141592653589793\n\n    # Convert degrees to radians by multiplying by pi/180\n    radians = degrees * (pi / 180)\n\n    # Return the result\n    return radians",
    "606": "function find_pattern_in_string(input_string, pattern):\n    # Import the regular expression module\n    import re\n\n    # Use the finditer function to find all occurrences of the pattern in the string\n    matches = re.finditer(pattern, input_string)\n\n    # Create an empty list to store the locations of the matches\n    locations = []\n\n    # Loop through each match\n    for match in matches:\n        # Add the start and end indices of the match to the locations list\n        locations.append((match.start(), match.end()))\n\n    # Return the locations list\n    return locations",
    "607": "function find_nth_bell_number(n):\n    # Create a 2D array to store the Bell numbers\n    create a 2D array named \"bell_numbers\" with n rows and n columns, initialized with 0\n\n    # The first Bell number is 1\n    set the value at bell_numbers[0][0] to 1\n\n    # Fill the array using the Bell triangle formula\n    for i from 1 to n:\n        for j from 0 to i:\n            if j is 0:\n                set the value at bell_numbers[i][j] to the value at bell_numbers[i-1][i-1]\n            else:\n                set the value at bell_numbers[i][j] to the sum of the value at bell_numbers[i-1][j-1] and the value at bell_numbers[i][j-1]\n\n    # The nth Bell number is the last number in the nth row\n    return the value at bell_numbers[n-1][n-1]",
    "608": "function find_minimum_value(function, start, end):\n    # Initialize minimum value to be the maximum possible value\n    minimum_value = maximum possible value for function\n\n    # Loop through each value in the given range\n    for each value in range from start to end:\n        # Calculate the value of the function at this point\n        function_value = function(value)\n\n        # If this function value is less than our current minimum, update the minimum\n        if function_value < minimum_value:\n            minimum_value = function_value\n\n    # Return the minimum value we found\n    return minimum_value",
    "609": "function remove_kth_element(input_list, k):\n    # Check if the k is within the range of the list\n    if k is not within the range of the length of input_list:\n        # If not, raise an error\n        raise an error stating that the k is out of range\n\n    # Remove the k'th element from the list\n    remove the k'th element from input_list\n\n    # Return the modified list\n    return input_list",
    "610": "function find_max_nth_column(tuple_list, n):\n    # Check if the nth column exists\n    if n is greater than the number of columns in the tuple_list:\n        # If not, return an error message\n        return \"Error: n is out of range\"\n\n    # Create a variable to keep track of the maximum value\n    set max_value to the first element of the nth column in tuple_list\n\n    # Loop through each tuple in the tuple_list\n    for each tuple in tuple_list:\n        # Check if the nth element in the tuple is greater than max_value\n        if the nth element in tuple is greater than max_value:\n            # If it is, update max_value\n            set max_value to the nth element in tuple\n\n    # Return the maximum value\n    return max_value",
    "611": "function merge_first_and_last(list_of_lists):\n    # Create an empty list to store the merged elements\n    create an empty list named \"merged_elements\"\n\n    # Loop through each list in the list of lists\n    for each list in list_of_lists:\n        # Check if the list is not empty\n        if list is not empty:\n            # If the list is not empty, add the first and last elements to the merged_elements list\n            add the first element of the list to \"merged_elements\"\n            add the last element of the list to \"merged_elements\"\n\n    # Return the merged_elements list\n    return merged_elements",
    "612": "function find_max_value(tuple_list):\n    # Initialize max_value to be the smallest possible value\n    set max_value to be the smallest possible value\n\n    # Loop through each tuple in the tuple_list\n    for each tuple in tuple_list:\n        # Loop through each attribute in the tuple\n        for each attribute in tuple:\n            # If the attribute is a record, check if it's larger than max_value\n            if attribute is a record:\n                if attribute's value is larger than max_value:\n                    # If it is, update max_value\n                    set max_value to be attribute's value\n\n    # If max_value is still the smallest possible value, there were no records in the tuple_list\n    if max_value is still the smallest possible value:\n        return None\n    else:\n        # Otherwise, return max_value\n        return max_value",
    "613": "function cumulative_sum(tuple_list):\n    # Create a variable to keep track of the cumulative sum\n    create a variable named \"cumulative_sum\" and set it to 0\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Loop through each value in the tuple\n        for each value in tuple:\n            # Add the value to the cumulative sum\n            add value to \"cumulative_sum\"\n\n    # Return the cumulative sum\n    return cumulative_sum",
    "614": "function find_average_value(tuple_of_tuples):\n    # Create a variable to keep track of the total sum of all numbers\n    create a variable named \"total_sum\" and set it to 0\n\n    # Create a variable to keep track of the total count of all numbers\n    create a variable named \"total_count\" and set it to 0\n\n    # Loop through each tuple in the tuple of tuples\n    for each tuple in tuple_of_tuples:\n        # Loop through each number in the tuple\n        for each number in tuple:\n            # Add the number to the total sum\n            add number to \"total_sum\"\n\n            # Increment the total count by 1\n            increment \"total_count\" by 1\n\n    # Calculate the average by dividing the total sum by the total count\n    calculate the average by dividing \"total_sum\" by \"total_count\"\n\n    # Return the average\n    return the average",
    "615": "function modulo_tuple_elements(tuple1, tuple2):\n    # Create an empty list to store the results\n    create an empty list named \"results\"\n\n    # Loop through each element in the first tuple\n    for each element in tuple1:\n        # Loop through each element in the second tuple\n        for each element in tuple2:\n            # Calculate the modulo of the two elements and add it to the results list\n            add the modulo of element from tuple1 and element from tuple2 to \"results\"\n\n    # Return the results list\n    return \"results\"",
    "616": "function check_jumps(d):\n    # Initialize the number of jumps to 0\n    set jumps to 0\n\n    # While the distance is greater than 0\n    while d > 0:\n        # If the distance is greater than or equal to the jump length\n        if d >= jump_length:\n            # Subtract the jump length from the distance\n            subtract jump_length from d\n            # Increment the number of jumps\n            increment jumps by 1\n        else:\n            # If the distance is less than the jump length\n            # The remaining distance is the jump length\n            set d to jump_length\n            # Increment the number of jumps\n            increment jumps by 1\n\n    # Return the number of jumps\n    return jumps",
    "617": "function divide_lists(list1, list2):\n    # Check if both lists have the same length\n    if length of list1 is not equal to length of list2:\n        # If not, return an error message\n        return \"Error: Both lists must have the same length\"\n\n    # Use the map function to apply a lambda function to each pair of corresponding elements in the two lists\n    result = map(lambda x, y: x / y, list1, list2)\n\n    # Convert the result to a list and return it\n    return list(result)",
    "618": "function move_numbers_to_string(input_string):\n    # Create an empty string to hold the characters that are not numbers\n    create an empty string named \"non_number_characters\"\n\n    # Create an empty string to hold the numbers\n    create an empty string named \"numbers\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is a number\n        if character is a number:\n            # If it is, add it to the \"numbers\" string\n            add character to \"numbers\"\n        else:\n            # If it's not a number, add it to the \"non_number_characters\" string\n            add character to \"non_number_characters\"\n\n    # Combine the \"non_number_characters\" and \"numbers\" strings and return the result\n    return \"non_number_characters\" + \"numbers\"",
    "619": "function find_largest_subset(input_list):\n    # Create an empty list to store the largest subset\n    create an empty list named \"largest_subset\"\n\n    # Loop through each pair in the input list\n    for each pair in input_list:\n        # Check if the pair is divisible\n        if pair[0] is divisible by pair[1] and pair[1] is divisible by pair[0]:\n            # If it is, add it to the largest subset\n            add pair to \"largest_subset\"\n\n    # Return the largest subset\n    return largest_subset",
    "620": "function increment_numeric_values(input_string, k):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is a digit\n        if character is a digit:\n            # If it is, increment it by k and add it to the result string\n            increment character by k\n            add character to \"result\"\n        else:\n            # If it's not a digit, just add it to the result string as is\n            add character to \"result\"\n\n    # Return the result string\n    return \"result\"",
    "621": "function find_median_of_two_sorted_arrays(array1, array2):\n    # Combine the two arrays into one sorted array\n    combine array1 and array2 into a new array named \"combined_array\"\n\n    # Sort the combined array\n    sort \"combined_array\"\n\n    # Find the length of the combined array\n    find the length of \"combined_array\" and store it in a variable named \"length\"\n\n    # If the length of the combined array is even\n    if length is even:\n        # The median is the average of the two middle numbers\n        find the number at index length/2 - 1 in \"combined_array\" and store it in a variable named \"first_middle\"\n        find the number at index length/2 in \"combined_array\" and store it in a variable named \"second_middle\"\n        calculate the average of first_middle and second_middle and return it\n    else:\n        # The median is the middle number\n        find the number at index length/2 in \"combined_array\" and return it",
    "622": "function find_nth_power(list, n):\n    # Create an empty list to store the results\n    create an empty list named \"results\"\n\n    # Loop through each element in the input list\n    for each element in list:\n        # Calculate the n-th power of the element using a lambda function\n        calculate the n-th power of the element using a lambda function and add it to \"results\"\n\n    # Return the list of results\n    return \"results\"",
    "623": "function convert_to_uppercase(input_string):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Convert the character to uppercase\n        convert character to uppercase\n\n        # Add the uppercase character to the result string\n        add uppercase character to \"result\"\n\n    # Return the result string\n    return \"result\"",
    "624": "function interchange_first_and_last(input_list):\n    # Check if the list is empty\n    if input_list is empty:\n        # If it is, return the empty list\n        return input_list\n    else:\n        # If it's not, get the first and last elements\n        first_element = get the first element from input_list\n        last_element = get the last element from input_list\n\n        # Remove the first and last elements from the list\n        remove the first element from input_list\n        remove the last element from input_list\n\n        # Add the first and last elements to the list in reverse order\n        add last_element to the start of input_list\n        add first_element to the end of input_list\n\n        # Return the modified list\n        return input_list",
    "625": "function find_largest_triangle(radius):\n    # Calculate the area of the semicircle\n    area_of_semicircle = pi * radius^2\n\n    # Calculate the area of the largest possible triangle\n    # The largest triangle can be inscribed in the semicircle if it is a right triangle\n    # The height of the triangle is the radius, and the base is the diameter of the semicircle\n    # The area of the triangle is therefore 1/2 * base * height\n    area_of_triangle = 1/2 * radius * radius\n\n    # If the area of the triangle is less than the area of the semicircle,\n    # the largest triangle that can be inscribed in the semicircle is a right triangle\n    if area_of_triangle < area_of_semicircle:\n        return \"The largest triangle that can be inscribed in the semicircle is a right triangle\"\n    else:\n        # If the area of the triangle is equal to the area of the semicircle,\n        # the largest triangle that can be inscribed in the semicircle is a right triangle\n        return \"The largest triangle that can be inscribed in the semicircle is a right triangle\"\n\n    # If the area of the triangle is greater than the area of the semicircle,\n    # the largest triangle that can be inscribed in the semicircle is a right triangle\n    return \"The largest triangle that can be inscribed in the semicircle is a right triangle\"",
    "626": "function find_smallest_missing_number(input_array):\n    # Create a variable to keep track of the smallest missing number\n    create a variable named \"smallest_missing_number\" and set it to 1\n\n    # Sort the input array\n    sort the input_array\n\n    # Loop through each number in the sorted array\n    for each number in input_array:\n        # Check if the current number is equal to the smallest missing number\n        if number is equal to \"smallest_missing_number\":\n            # If it is, increment the smallest missing number\n            increment \"smallest_missing_number\"\n        # Check if the current number is greater than the smallest missing number\n        else if number is greater than \"smallest_missing_number\":\n            # If it is, return the smallest missing number\n            return \"smallest_missing_number\"\n\n    # If we've checked all numbers and found no missing numbers, return the next number\n    return \"smallest_missing_number\"",
    "627": "function replace_spaces_with_url_encoding(input_string):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If the character is a space, append '%20' to the result string\n        if character is a space:\n            append '%20' to \"result\"\n        else:\n            # Otherwise, append the character to the result string\n            append character to \"result\"\n\n    # Return the result string\n    return \"result\"",
    "628": "function find_even_numbers(input_list):\n    # Create an empty list to store the even numbers\n    create an empty list named \"even_numbers\"\n\n    # Loop through each item in the input list\n    for each item in input_list:\n        # Check if the item is an integer\n        if item is an integer:\n            # Check if the item is even\n            if item modulo 2 equals 0:\n                # If it's even, add it to the list of even numbers\n                add item to \"even_numbers\"\n\n    # Return the list of even numbers\n    return \"even_numbers\"",
    "629": "function extract_adjacent_coordinates(coordinate_tuple):\n    # Create a list to store the adjacent coordinates\n    create an empty list named \"adjacent_coordinates\"\n\n    # Extract the x and y coordinates from the tuple\n    x = coordinate_tuple[0]\n    y = coordinate_tuple[1]\n\n    # Define the possible adjacent coordinates\n    possible_adjacent_coordinates = [(x-1, y), (x+1, y), (x, y-1), (x, y+1)]\n\n    # Loop through each possible adjacent coordinate\n    for coordinate in possible_adjacent_coordinates:\n        # Check if the coordinate is within the bounds of the grid\n        if coordinate is within the bounds of the grid:\n            # If it is, add it to the list of adjacent coordinates\n            add coordinate to \"adjacent_coordinates\"\n\n    # Return the list of adjacent coordinates\n    return \"adjacent_coordinates\"",
    "630": "function replace_whitespace_with_underscore(input_string):\n    # Import the regex module\n    import regex\n\n    # Define the pattern for whitespace\n    pattern = \"\\s\"\n\n    # Define the replacement string\n    replacement = \"_\"\n\n    # Use the regex.sub function to replace all whitespace with underscores\n    output_string = regex.sub(pattern, replacement, input_string)\n\n    # Return the modified string\n    return output_string\n\nfunction replace_underscore_with_whitespace(input_string):\n    # Import the regex module\n    import regex\n\n    # Define the pattern for underscore\n    pattern = \"_\"\n\n    # Define the replacement string\n    replacement = \" \"\n\n    # Use the regex.sub function to replace all underscores with whitespaces\n    output_string = regex.sub(pattern, replacement, input_string)\n\n    # Return the modified string\n    return output_string",
    "631": "function move_zeroes_to_end(input_list):\n    # Create a variable to keep track of the position of the last non-zero element\n    create a variable named \"last_non_zero_position\" and set it to 0\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # If the element is not zero, move it to the position of the last non-zero element\n        if element is not zero:\n            # Move the element to the position of the last non-zero element\n            move element to position \"last_non_zero_position\"\n            # Increment the position of the last non-zero element\n            increment \"last_non_zero_position\"\n\n    # Loop through each position in the input list from the position of the last non-zero element to the end\n    for each position from \"last_non_zero_position\" to the end of the list:\n        # Set the element at this position to zero\n        set the element at position \"position\" to zero\n\n    # Return the modified list\n    return input_list",
    "632": "function find_sum_of_xor_pairs(array):\n    # Initialize sum to 0\n    set sum to 0\n\n    # Loop through each number in the array\n    for each number in array:\n        # Loop through each other number in the array\n        for each other_number in array:\n            # Calculate the xor of the current number and the other number\n            set xor to number xor other_number\n\n            # Add the xor to the sum\n            add xor to sum\n\n    # Return the sum\n    return sum",
    "633": "function sum_of_fourth_power_of_first_n_even_numbers(n):\n    # Initialize sum to 0\n    initialize sum to 0\n\n    # Loop from 1 to n\n    for i from 1 to n:\n        # Calculate the fourth power of the current even number\n        calculate the fourth power of 2*i\n\n        # Add the result to the sum\n        add the result to sum\n\n    # Return the sum\n    return sum",
    "634": "function push_and_pop_heap(values):\n    # Create an empty heap\n    create an empty heap named \"heap\"\n\n    # Loop through each value in the input list\n    for each value in values:\n        # Push the value into the heap\n        push value into \"heap\"\n\n    # Create an empty list to store the popped values\n    create an empty list named \"popped_values\"\n\n    # While the heap is not empty\n    while \"heap\" is not empty:\n        # Pop the smallest value from the heap and add it to the list of popped values\n        pop the smallest value from \"heap\" and add it to \"popped_values\"\n\n    # Return the list of popped values\n    return \"popped_values\"",
    "635": "function check_reciprocal_roots(a, b, c):\n    # Calculate the discriminant\n    calculate the discriminant as b^2 - 4ac\n\n    # If the discriminant is less than 0, the roots are not real\n    if discriminant is less than 0:\n        return False\n\n    # Calculate the roots\n    calculate the roots as (-b \u00b1 sqrt(discriminant)) / (2a)\n\n    # Check if the roots are reciprocal of each other\n    if roots are equal:\n        return True\n    else:\n        return False",
    "636": "function check_profit_loss(amount):\n    # Check if the amount is greater than 0\n    if amount is greater than 0:\n        # If it is, then it has no loss\n        return \"No loss\"\n    # Check if the amount is less than 0\n    else if amount is less than 0:\n        # If it is, then it has no profit\n        return \"No profit\"\n    # If the amount is 0, then it has neither profit nor loss\n    else:\n        return \"No profit, no loss\"",
    "637": "function calculate_wind_chill_index(temperature, wind_speed):\n    # Check if the temperature is below 50 degrees Fahrenheit\n    if temperature is less than 50:\n        # Check if the wind speed is above 3 miles per hour\n        if wind_speed is greater than 3:\n            # Calculate the wind chill index using the formula\n            wind_chill_index = 35.74 + 0.6215 * temperature - 35.75 * wind_speed^0.16 + 0.4275 * temperature * wind_speed^0.16\n            # Return the calculated wind chill index\n            return wind_chill_index\n        else:\n            # If wind speed is less than 3, return a message indicating invalid input\n            return \"Invalid input: Wind speed must be above 3 miles per hour\"\n    else:\n        # If temperature is above 50, return a message indicating invalid input\n        return \"Invalid input: Temperature must be below 50 degrees Fahrenheit\"",
    "638": "function sum_length_of_names(list_of_names):\n    # Create a variable to keep track of the sum of the lengths\n    create a variable named \"sum_of_lengths\" and set it to 0\n\n    # Loop through each name in the list\n    for each name in list_of_names:\n        # Check if the name starts with a lowercase letter\n        if the first character of name is not an uppercase letter:\n            # If it does, skip this name\n            continue\n        else:\n            # If it doesn't, add the length of the name to our sum\n            add the length of name to \"sum_of_lengths\"\n\n    # Return the sum of the lengths\n    return sum_of_lengths",
    "639": "function remove_parenthesis_area(input_string):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If the character is not a parenthesis, add it to the result string\n        if character is not \"(\" or character is not \")\":\n            add character to \"result\"\n\n    # Return the result string\n    return \"result\"",
    "640": "function find_nth_nonagonal_number(n):\n    # Calculate the nth nonagonal number using the formula n*(7n-5)/2\n    nonagonal_number = n*(7*n-5)/2\n\n    # Return the nth nonagonal number\n    return nonagonal_number",
    "641": "function remove_similar_rows(matrix):\n    # Create an empty list to store the unique rows\n    create an empty list named \"unique_rows\"\n\n    # Loop through each row in the matrix\n    for each row in matrix:\n        # Convert the row to a tuple to make it hashable\n        convert row to a tuple named \"row_tuple\"\n\n        # Check if this row is already in \"unique_rows\"\n        if row_tuple is not in \"unique_rows\":\n            # If it's not, add it to \"unique_rows\"\n            add row_tuple to \"unique_rows\"\n\n    # Convert \"unique_rows\" back to a list of lists\n    convert \"unique_rows\" to a list of lists named \"unique_rows_list\"\n\n    # Return the list of unique rows\n    return unique_rows_list",
    "642": "function find_word_with_z(input_string):\n    # Split the input string into words\n    split input_string into words\n\n    # Create an empty list to store words with 'z'\n    create an empty list named \"words_with_z\"\n\n    # Loop through each word in the list of words\n    for each word in words:\n        # Check if the word contains 'z' and is not at the start or end\n        if 'z' is in word and word is not at the start or end of the string:\n            # If it does, add it to our list\n            add word to \"words_with_z\"\n\n    # Return the list of words with 'z'\n    return \"words_with_z\"",
    "643": "function reverse_array_upto_position(array, position):\n    # Check if the position is valid\n    if position is less than 0 or greater than the length of the array:\n        # If not, return an error message\n        return \"Invalid position\"\n\n    # Reverse the array up to the given position\n    for i from 0 to position:\n        # Swap the i-th element with the (length - i - 1)-th element\n        swap array[i] with array[length of array - i - 1]\n\n    # Return the modified array\n    return array",
    "644": "function find_product_of_kth_index(tuples, k):\n    # Initialize a variable to store the product\n    set product to 1\n\n    # Loop through each tuple in the input list\n    for each tuple in tuples:\n        # Check if the tuple has at least k elements\n        if the length of tuple is greater than or equal to k:\n            # If it does, multiply the product by the kth element\n            multiply product by the kth element of tuple\n\n    # Return the final product\n    return product",
    "645": "function count_cubes(n, k):\n    # Initialize count to 0\n    initialize count to 0\n\n    # Loop through each dimension of the cube\n    for each dimension in cube of size n:\n        # If the dimension is less than k, add the dimension to count\n        if dimension is less than k:\n            add dimension to count\n\n    # Return the count\n    return count",
    "646": "function split_string_at_uppercase(input_string):\n    # Create an empty list to store the split strings\n    create an empty list named \"split_strings\"\n\n    # Create a variable to store the current split string\n    create a variable named \"current_string\" and set it to an empty string\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is uppercase\n        if character is uppercase:\n            # If it is, add the current string to the list of split strings\n            add current_string to split_strings\n            # And start a new current string\n            set current_string to an empty string\n        else:\n            # If it's not uppercase, add the character to the current string\n            add character to current_string\n\n    # After the loop, add the last current string to the list of split strings\n    add current_string to split_strings\n\n    # Return the list of split strings\n    return split_strings",
    "647": "function exchange_positions(input_list, n):\n    # Loop through the list, but only go up to the second last element\n    for i from 0 to length of input_list - 2 in steps of n:\n        # Exchange the current element with the next one\n        swap input_list[i] and input_list[i+1]\n\n    # Return the modified list\n    return input_list",
    "648": "function calculate_sum_in_range(list_of_numbers, start_index, end_index):\n    # Initialize a variable to keep track of the sum\n    set sum_of_numbers to 0\n\n    # Loop through each number in the list from the start index to the end index\n    for each number in list_of_numbers from start_index to end_index:\n        # Add the current number to the sum\n        add number to sum_of_numbers\n\n    # Return the sum\n    return sum_of_numbers",
    "649": "function are_arrays_equal(array1, array2):\n    # Check if the lengths of the arrays are equal\n    if the length of array1 is not equal to the length of array2:\n        # If they are not, the arrays are not equal, so return False\n        return False\n\n    # Loop through each element in array1\n    for each element in array1:\n        # Check if the element is in array2\n        if element is not in array2:\n            # If it's not, the arrays are not equal, so return False\n            return False\n\n    # If we've checked all elements and found no differences, the arrays are equal, so return True\n    return True",
    "650": "function is_subset(tuple1, tuple2):\n    # Loop through each element in the first tuple\n    for each element in tuple1:\n        # Check if the element is in the second tuple\n        if element is not in tuple2:\n            # If it's not, then tuple1 is not a subset of tuple2, so return False\n            return False\n\n    # If we've checked all elements in tuple1 and found no elements that are not in tuple2,\n    # then tuple1 is a subset of tuple2, so return True\n    return True",
    "651": "function flatten_tuple_matrix(tuple_matrix):\n    # Create an empty list to store the flattened matrix\n    create an empty list named \"flattened_matrix\"\n\n    # Loop through each tuple in the tuple matrix\n    for each tuple in tuple_matrix:\n        # Loop through each element in the tuple\n        for each element in tuple:\n            # Add the element to the flattened matrix\n            add element to \"flattened_matrix\"\n\n    # Return the flattened matrix\n    return flattened_matrix",
    "652": "function group_key_value_pairs(sequence_of_pairs):\n    # Create an empty dictionary\n    create an empty dictionary named \"grouped_dict\"\n\n    # Loop through each pair in the sequence\n    for each pair in sequence_of_pairs:\n        # Split the pair into key and value\n        split pair into key and value\n\n        # If the key is already in the dictionary, append the value to the list of values for that key\n        if key is already in \"grouped_dict\":\n            append value to \"grouped_dict\"[key]\n        else:\n            # If the key is not in the dictionary, create a new list with the value, and add it to the dictionary\n            create a new list with value and add it to \"grouped_dict\" with key\n\n    # Return the grouped dictionary\n    return \"grouped_dict\"",
    "653": "function find_rectangle_perimeter(length, width):\n    # Calculate the perimeter of the rectangle\n    perimeter = 2 * (length + width)\n\n    # Return the calculated perimeter\n    return perimeter",
    "654": "function sum_of_fifth_power(n):\n    # Initialize sum to 0\n    initialize sum to 0\n\n    # Loop from 1 to n\n    for i from 1 to n:\n        # Add the fifth power of i to the sum\n        add i^5 to sum\n\n    # Return the sum\n    return sum",
    "655": "function find_minimum_sum_of_absolute_differences(array1, array2):\n    # Sort both arrays in ascending order\n    sort array1 in ascending order\n    sort array2 in ascending order\n\n    # Initialize a variable to keep track of the sum of absolute differences\n    set a variable named \"sum_of_absolute_differences\" to 0\n\n    # Loop through each element in both arrays\n    for each element in array1:\n        for each element in array2:\n            # Calculate the absolute difference between the current elements\n            calculate the absolute difference between element in array1 and element in array2\n\n            # Add this difference to the sum\n            add the absolute difference to \"sum_of_absolute_differences\"\n\n    # Return the sum of absolute differences\n    return \"sum_of_absolute_differences\"",
    "656": "function find_first_digit_in_factorial(number):\n    # Calculate the factorial of the given number\n    factorial = calculate_factorial(number)\n\n    # Convert the factorial to a string so we can easily iterate over its digits\n    factorial_string = convert factorial to string\n\n    # Loop through each digit in the factorial string\n    for each digit in factorial_string:\n        # If the digit is not zero, return it\n        if digit is not zero:\n            return digit\n\n    # If we've checked all digits and found no non-zero digits, return a signal (like None or a message)\n    return None\n\nfunction calculate_factorial(number):\n    # Initialize the result to 1\n    result = 1\n\n    # Loop from 1 to the given number\n    for i from 1 to number:\n        # Multiply the result by the current number\n        result = result * i\n\n    # Return the result\n    return result",
    "657": "function find_max_occurrences(input_list):\n    # Create an empty dictionary to keep track of the occurrences of each item\n    create an empty dictionary named \"occurrences\"\n\n    # Loop through each item in the input list\n    for each item in input_list:\n        # If the item is already in the dictionary, increment its count\n        if item is already in \"occurrences\":\n            increment the count of item in \"occurrences\"\n        else:\n            # If it's a new item, add it to the dictionary with a count of 1\n            add item to \"occurrences\" with a count of 1\n\n    # Find the item with the maximum count\n    set the maximum count to 0\n    set the item with maximum count to None\n    for each item in \"occurrences\":\n        if the count of item in \"occurrences\" is greater than maximum count:\n            set maximum count to the count of item in \"occurrences\"\n            set the item with maximum count to item\n\n    # Return the item with maximum count\n    return the item with maximum count",
    "658": "function print_duplicants(list_of_integers):\n    # Create an empty dictionary to keep track of integers we've seen\n    create an empty dictionary named \"seen_integers\"\n\n    # Loop through each integer in the list\n    for each integer in list_of_integers:\n        # Check if we've come across this integer before\n        if integer is already in \"seen_integers\":\n            # If we have, this is a duplicant, so print it\n            print integer\n        else:\n            # If it's a new integer, add it to our dictionary to remember it\n            add integer to \"seen_integers\"\n\n    # If we've checked all integers and found no duplicants, print a signal (like None or a message)\n    print None",
    "659": "function choose_points(range1_start, range1_end, range2_start, range2_end):\n    # Create an empty list to store the chosen points\n    create an empty list named \"chosen_points\"\n\n    # Loop through each point in the first range\n    for each point in range(range1_start, range1_end + 1):\n        # Check if the point is not in the second range\n        if point is not in range(range2_start, range2_end + 1):\n            # If it's not, add it to the list of chosen points\n            add point to \"chosen_points\"\n\n    # Loop through each point in the second range\n    for each point in range(range2_start, range2_end + 1):\n        # Check if the point is not in the first range\n        if point is not in range(range1_start, range1_end + 1):\n            # If it's not, add it to the list of chosen points\n            add point to \"chosen_points\"\n\n    # Return the list of chosen points\n    return \"chosen_points\"",
    "660": "function max_sum_no_consecutive(input_list):\n    # Create a list to keep track of the maximum sum at each index\n    create a list named \"max_sum\" with length equal to the length of input_list\n\n    # Initialize the first two elements of max_sum\n    max_sum[0] = input_list[0]\n    max_sum[1] = input_list[1]\n\n    # Loop through the rest of the list\n    for i from 2 to the length of input_list:\n        # Calculate the maximum sum at this index\n        max_sum[i] = max(max_sum[i-1], max_sum[i-2] + input_list[i])\n\n    # Return the last element of max_sum, which is the maximum sum\n    return max_sum[length of input_list]",
    "661": "function sort_list_in_dictionary(input_dictionary):\n    # Loop through each key-value pair in the input dictionary\n    for each key-value pair in input_dictionary:\n        # Sort the list associated with the current key\n        sort the list associated with the current key\n\n    # Return the sorted dictionary\n    return input_dictionary",
    "662": "function find_largest_k(x, y):\n    # Initialize the largest possible k\n    set k to 0\n\n    # Loop until we find a k that satisfies the condition\n    while k modulo x is not equal to y:\n        # Increment k by 1\n        increment k by 1\n\n    # Return the largest possible k\n    return k",
    "663": "function find_average_of_even_numbers(given_even_number):\n    # Initialize a variable to keep track of the sum of even numbers\n    create a variable named \"sum_of_even_numbers\" and set it to 0\n\n    # Initialize a variable to keep track of the count of even numbers\n    create a variable named \"count_of_even_numbers\" and set it to 0\n\n    # Loop from 2 to the given even number (inclusive)\n    for each number from 2 to given_even_number:\n        # Check if the number is even\n        if number is divisible by 2:\n            # If it is, add it to the sum and increment the count\n            add number to \"sum_of_even_numbers\"\n            increment \"count_of_even_numbers\" by 1\n\n    # Calculate the average by dividing the sum by the count\n    calculate the average as \"sum_of_even_numbers\" divided by \"count_of_even_numbers\"\n\n    # Return the average\n    return the calculated average",
    "664": "function shift_first_to_end(input_list):\n    # Check if the list is empty\n    if input_list is empty:\n        # If it is, return an empty list\n        return an empty list\n\n    # Get the first element of the list\n    first_element = get the first element from input_list\n\n    # Remove the first element from the list\n    remove the first element from input_list\n\n    # Add the first element to the end of the list\n    add first_element to the end of input_list\n\n    # Return the modified list\n    return input_list",
    "665": "function count_occurrences(input_string, target_character):\n    # Initialize a counter to keep track of the number of times the target character appears\n    initialize a counter named \"occurrences\" to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the current character is the target character\n        if character is equal to target_character:\n            # If it is, increment the counter\n            increment \"occurrences\" by 1\n\n    # After checking all characters, return the counter\n    return occurrences",
    "666": "function count_vowels(input_string):\n    # Create a collection of vowels\n    create a collection named \"vowels\" containing 'a', 'e', 'i', 'o', 'u'\n\n    # Initialize a counter for vowels\n    set a variable named \"vowel_count\" to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is a vowel\n        if character is in \"vowels\":\n            # If it is, increment the vowel count\n            increment \"vowel_count\" by 1\n\n    # Return the total count of vowels\n    return \"vowel_count\"",
    "667": "function replace_multiple_occurrences(input_string, character_to_replace):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the current character is the one we want to replace\n        if character is equal to character_to_replace:\n            # If it is, add it to the result string only if the previous character was not the one we want to replace\n            if the previous character is not equal to character_to_replace:\n                add character to \"result\"\n        else:\n            # If the current character is not the one we want to replace, add it to the result string\n            add character to \"result\"\n\n    # Return the result string\n    return result",
    "668": "function is_valid_ip_address(ip_address):\n    # Import the necessary module for regular expressions\n    import re\n\n    # Define the regular expression pattern for a valid IP address\n    pattern = \"^(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\\.(25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$\"\n\n    # Check if the provided IP address matches the pattern\n    if re.match(pattern, ip_address):\n        # If it does, return True\n        return True\n    else:\n        # If it doesn't, return False\n        return False",
    "669": "function check_decreasing_trend(sequence):\n    # Initialize a variable to keep track of the previous number\n    set previous_number to the first number in the sequence\n\n    # Loop through each number in the sequence\n    for each number in sequence:\n        # Check if the current number is less than the previous number\n        if number is less than previous_number:\n            # If it is, continue to the next number\n            set previous_number to number\n        else:\n            # If it's not, the sequence does not have a decreasing trend, so return False\n            return False\n\n    # If we've checked all numbers and found no decreasing trend, return True\n    return True",
    "670": "function set_right_most_unset_bit(number):\n    # Initialize a variable to keep track of the position of the rightmost unset bit\n    let position = 0\n\n    # Loop until we find the rightmost unset bit\n    while number is not 0:\n        # If the least significant bit is 1, shift the number to the right\n        if number is odd:\n            number = number / 2\n        # If the least significant bit is 0, we've found the rightmost unset bit\n        else:\n            # Set the rightmost unset bit\n            number = number / 2\n            number = number * 2\n            # Return the number with the rightmost unset bit set\n            return number\n\n        # Increment the position\n        position = position + 1\n\n    # If we've checked all bits and found no unset bits, return a signal (like None or a message)\n    return None",
    "671": "function find_maximum_of_three_numbers(num1, num2, num3):\n    # Check if num1 is greater than num2\n    if num1 > num2:\n        # If num1 is greater than num2, check if num1 is greater than num3\n        if num1 > num3:\n            # If num1 is greater than both num2 and num3, return num1\n            return num1\n        else:\n            # If num3 is greater than num1 but less than num2, return num3\n            return num3\n    else:\n        # If num2 is greater than num1, check if num2 is greater than num3\n        if num2 > num3:\n            # If num2 is greater than both num1 and num3, return num2\n            return num2\n        else:\n            # If num3 is greater than num2 but less than num1, return num3\n            return num3",
    "672": "function convert_list_to_integer(list_of_integers):\n    # Create an empty string to store the final integer\n    create an empty string named \"final_integer\"\n\n    # Loop through each integer in the list\n    for each integer in list_of_integers:\n        # Convert the integer to a string and add it to the final integer\n        convert integer to string and add it to \"final_integer\"\n\n    # Convert the final integer to an integer and return it\n    convert \"final_integer\" to an integer and return it",
    "673": "function remove_duplicate_words(input_string):\n    # Import the collections module\n    import collections\n\n    # Split the input string into a list of words\n    split the input_string into a list of words named \"words\"\n\n    # Use a dictionary to keep track of the words we've seen\n    create an empty dictionary named \"word_count\"\n\n    # Loop through each word in the list of words\n    for each word in \"words\":\n        # If the word is already in the dictionary, increment its count\n        if word is already in \"word_count\":\n            increment the count for word in \"word_count\"\n        else:\n            # If the word is not in the dictionary, add it with a count of 1\n            add word to \"word_count\" with a count of 1\n\n    # Create a new list to hold the words without duplicates\n    create an empty list named \"no_duplicates\"\n\n    # Loop through each word in the list of words\n    for each word in \"words\":\n        # If the count for the word in the dictionary is 1, add it to the new list\n        if the count for word in \"word_count\" is 1:\n            add word to \"no_duplicates\"\n\n    # Join the words in the new list into a string and return it\n    join the words in \"no_duplicates\" into a string named \"result\"\n    return \"result\"",
    "674": "function add_two_integers(num1, num2, range_start, range_end):\n    # Add the two numbers together\n    sum = num1 + num2\n\n    # Check if the sum is within the given range\n    if range_start <= sum <= range_end:\n        # If it is, return 20\n        return 20\n    else:\n        # If it's not, return the sum\n        return sum",
    "675": "function remove_non_alphanumeric_characters(input_string):\n    # Import the regular expression module\n    import regular expression module\n\n    # Use a regular expression to replace all non-alphanumeric characters with nothing\n    new_string = regular expression module's sub function to replace all non-alphanumeric characters with nothing in input_string\n\n    # Return the new string\n    return new_string",
    "676": "function is_valid_triangle(side1, side2, side3):\n    # Check if the triangle is valid\n    if side1 + side2 > side3 and side2 + side3 > side1 and side1 + side3 > side2:\n        # If the triangle is valid, return True\n        return True\n    else:\n        # If the triangle is not valid, return False\n        return False",
    "677": "function remove_spaces(input_string):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If the character is not a space, add it to the result string\n        if character is not a space:\n            add character to \"result\"\n\n    # Return the result string\n    return \"result\"",
    "678": "function access_dict_element_by_index(dictionary, index):\n    # Create a list of keys from the dictionary\n    create a list named \"keys\" and add all keys from dictionary to it\n\n    # Check if the index is valid\n    if index is less than 0 or index is greater than or equal to the length of \"keys\":\n        # If not, return an error message\n        return \"Index out of range\"\n\n    # If it is, return the element at the given index in the list of keys\n    return dictionary[keys[index]]",
    "679": "function check_increasing_trend(sequence):\n    # Initialize a variable to keep track of the previous number\n    set previous_number to the first number in the sequence\n\n    # Loop through each number in the sequence\n    for each number in sequence:\n        # Check if the current number is less than the previous number\n        if number is less than previous_number:\n            # If it is, the sequence is not increasing, so return False\n            return False\n        else:\n            # If it's not, update the previous number to the current number\n            set previous_number to number\n\n    # If we've checked all numbers and found no decreasing trends, return True\n    return True",
    "680": "function find_smallest_prime_divisor(number):\n    # Check if the number is less than 2, if so, return None as it's not a prime number\n    if number is less than 2:\n        return None\n\n    # Check if the number is 2, if so, return 2 as it's the smallest prime number\n    if number is 2:\n        return 2\n\n    # Check if the number is divisible by 2, if so, return 2 as it's the smallest prime divisor\n    if number is divisible by 2:\n        return 2\n\n    # Loop through odd numbers starting from 3 up to the square root of the number\n    for each odd number from 3 to the square root of number:\n        # Check if the number is divisible by the current odd number\n        if number is divisible by the current odd number:\n            # If it is, return the current odd number as it's the smallest prime divisor\n            return the current odd number\n\n    # If no prime divisor is found, return the number itself\n    return number",
    "681": "function multiply_lists(list1, list2):\n    # Check if both lists have the same length\n    if length of list1 is not equal to length of list2:\n        # If not, return an error message\n        return \"Error: Lists must have the same length\"\n\n    # Use the map function to apply a lambda function to each pair of elements in the two lists\n    result = map(lambda x, y: x * y, list1, list2)\n\n    # Convert the result to a list and return it\n    return list(result)",
    "682": "function check_sum_of_squares(number):\n    # Loop through all possible values for i from 0 to sqrt(number)\n    for i from 0 to sqrt(number):\n        # Calculate the square of i\n        square_i = i * i\n\n        # If square_i is greater than number, we can stop the loop\n        if square_i > number:\n            break\n\n        # Calculate the square root of the remaining part of the number\n        square_root_remainder = sqrt(number - square_i)\n\n        # If square_root_remainder is an integer, we've found a pair of squares that sum to the number\n        if square_root_remainder is an integer:\n            return True\n\n    # If we've checked all possible pairs and found no matches, return False\n    return False",
    "683": "function count_character_occurrences(input_string, character):\n    # Initialize a counter to keep track of the number of times the character appears\n    set a counter to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the current character is the one we're looking for\n        if character is equal to the character we're looking for:\n            # If it is, increment the counter\n            increment the counter by 1\n\n    # After checking all characters, return the counter\n    return the counter",
    "684": "function sum_of_primes(n):\n    # Initialize sum to 0\n    initialize sum to 0\n\n    # Loop through each number from 2 to n\n    for each number from 2 to n:\n        # Check if the number is prime\n        if is_prime(number):\n            # If it is, add it to the sum\n            add number to sum\n\n    # Return the sum\n    return sum\n\nfunction is_prime(number):\n    # Check if the number is less than 2\n    if number is less than 2:\n        # If it is, it's not prime, so return False\n        return False\n\n    # Loop through each number from 2 to the square root of the number\n    for each number from 2 to the square root of number:\n        # Check if the number is divisible by the current number\n        if number is divisible by current number:\n            # If it is, it's not prime, so return False\n            return False\n\n    # If we've checked all numbers and found no divisors, it's prime, so return True\n    return True",
    "685": "function find_frequency(input_list):\n    # Create an empty dictionary to keep track of frequencies\n    create an empty dictionary named \"frequency_dict\"\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # Check if the element is already in our dictionary\n        if element is already in \"frequency_dict\":\n            # If it is, increment its count\n            increment the count for element in \"frequency_dict\"\n        else:\n            # If it's not, add it to our dictionary with a count of 1\n            add element to \"frequency_dict\" with a count of 1\n\n    # Return the dictionary of frequencies\n    return \"frequency_dict\"",
    "686": "function gcd(a, b):\n    # If b is 0, a is the gcd\n    if b is 0:\n        return a\n    # Otherwise, call gcd again with b and the remainder of a divided by b\n    else:\n        return gcd(b, a mod b)",
    "687": "function get_length_of_complex_number(complex_number):\n    # Split the complex number into its real and imaginary parts\n    split complex_number into real_part and imaginary_part\n\n    # Calculate the length of the real part\n    calculate the length of real_part and store it in real_length\n\n    # Calculate the length of the imaginary part\n    calculate the length of imaginary_part and store it in imaginary_length\n\n    # Calculate the length of the complex number as the square root of the sum of the squares of the real and imaginary parts\n    calculate the square root of (real_length^2 + imaginary_length^2) and store it in complex_length\n\n    # Return the length of the complex number\n    return complex_length",
    "688": "function find_minimum_jumps(array):\n    # Initialize the number of jumps to 0\n    set jumps to 0\n\n    # Initialize the maximum reachable position to 0\n    set max_reachable to 0\n\n    # Initialize the current position to 0\n    set current_position to 0\n\n    # Loop through the array\n    while current_position < length of array:\n        # If the current position is the last index, return the number of jumps\n        if current_position is the last index of array:\n            return jumps\n\n        # Update the maximum reachable position\n        max_reachable = max(max_reachable, current_position + array[current_position])\n\n        # If we can't move forward, return -1\n        if max_reachable <= current_position:\n            return -1\n\n        # If we can move forward, update the current position and increment the number of jumps\n        current_position = max_reachable\n        increment jumps by 1\n\n    # If we've checked all elements and found no repeats, return a signal (like None or a message)\n    return None",
    "689": "function multiply_consecutive_numbers(input_list):\n    # Create an empty list to store the results\n    create an empty list named \"results\"\n\n    # Loop through each pair of consecutive numbers in the input list\n    for each pair of consecutive numbers in input_list:\n        # Multiply the numbers together and add the result to the results list\n        multiply the first number in the pair with the second number in the pair\n        add the result to \"results\"\n\n    # Return the results list\n    return \"results\"",
    "690": "function group_by_second_element(tuple_list):\n    # Create an empty dictionary to store the groups\n    create an empty dictionary named \"grouped_elements\"\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Get the second element of the tuple\n        get the second element of the tuple and store it in a variable named \"second_element\"\n\n        # If the second element is not already a key in the dictionary\n        if second_element is not a key in \"grouped_elements\":\n            # Create a new list and add the first element of the tuple to it\n            create a new list and add the first element of the tuple to it\n            add the list to \"grouped_elements\" using the second_element as the key\n        else:\n            # If the second element is already a key in the dictionary, add the first element to the corresponding list\n            add the first element of the tuple to the list in \"grouped_elements\" that corresponds to the second_element\n\n    # Return the grouped elements\n    return \"grouped_elements\"",
    "691": "function find_last_two_digits_in_factorial(number):\n    # Initialize the result to 1\n    initialize result to 1\n\n    # Loop from 1 to the given number\n    for i from 1 to number:\n        # Multiply the result by the current number\n        multiply result by i\n\n    # Convert the result to a string to easily get the last two digits\n    convert result to a string and store it in a variable named \"result_string\"\n\n    # Return the last two digits of the result\n    return the last two characters of \"result_string\"",
    "692": "function remove_multiple_spaces(input_string):\n    # Import the regex module\n    import regex\n\n    # Use the regex sub function to replace multiple spaces with a single space\n    output_string = regex.sub(r'\\s+', ' ', input_string)\n\n    # Return the string with multiple spaces removed\n    return output_string",
    "693": "function extract_unique_values(input_dictionary):\n    # Create an empty collection to keep track of unique values\n    create an empty collection named \"unique_values\"\n\n    # Loop through each value in the input dictionary\n    for each value in input_dictionary.values():\n        # Check if we've come across this value before\n        if value is already in \"unique_values\":\n            # If it's a new value, add it to our collection to remember it\n            add value to \"unique_values\"\n\n    # Return the collection of unique values\n    return unique_values",
    "694": "function check_tuples(tuple1, tuple2):\n    # Check if the tuples are of equal length\n    if length of tuple1 is not equal to length of tuple2:\n        return False\n\n    # Loop through each index in the tuples\n    for each index in range of length of tuple1:\n        # Check if the element at the current index in tuple2 is greater than the element at the current index in tuple1\n        if tuple2[index] is not greater than tuple1[index]:\n            return False\n\n    # If we've checked all elements and found no discrepancies, return True\n    return True",
    "695": "function zip_lists(list1, list2):\n    # Create an empty list to store the zipped lists\n    create an empty list named \"zipped_list\"\n\n    # Loop through each list in list1 and list2\n    for each list in list1:\n        # If the current list is not empty, add it to the zipped list\n        if list is not empty:\n            add list to \"zipped_list\"\n\n    # Loop through each list in list2 and list1\n    for each list in list2:\n        # If the current list is not empty, add it to the zipped list\n        if list is not empty:\n            add list to \"zipped_list\"\n\n    # Return the zipped list\n    return \"zipped_list\"",
    "696": "function find_even_elements(input_list):\n    # Use the lambda function to filter out the even elements\n    even_elements = filter(lambda x: x % 2 == 0, input_list)\n\n    # Return the count of even elements\n    return count of even_elements",
    "697": "function sort_dict_items_by_tuple_product(input_dict):\n    # Create an empty list to store the sorted items\n    create an empty list named \"sorted_items\"\n\n    # Loop through each item in the input dictionary\n    for each item in input_dict:\n        # Calculate the product of the keys in the item\n        calculate the product of the keys in the item\n\n        # Add the item and its product to the sorted_items list\n        add the item and its product to \"sorted_items\"\n\n    # Sort the sorted_items list by the product of the keys\n    sort \"sorted_items\" by the product of the keys\n\n    # Return the sorted list of items\n    return \"sorted_items\"",
    "698": "function min_swaps_to_convert_binary_strings(str1, str2):\n    # Check if the strings are of same length\n    if length of str1 is not equal to length of str2:\n        return \"Strings are not of same length\"\n\n    # Initialize count of different characters\n    count = 0\n\n    # Traverse through the strings\n    for i from 0 to length of str1:\n        # If current characters are not same, increment count\n        if str1[i] is not equal to str2[i]:\n            count = count + 1\n\n    # Return minimum number of swaps required equal to count/2\n    return count/2",
    "699": "function count_elements_in_range(list, range_start, range_end):\n    # Initialize a counter to keep track of the number of elements in the range\n    set counter to 0\n\n    # Loop through each element in the list\n    for each element in list:\n        # Check if the element is within the specified range\n        if element is greater than or equal to range_start and element is less than or equal to range_end:\n            # If it is, increment the counter\n            increment counter by 1\n\n    # After checking all elements, return the counter\n    return counter",
    "700": "function find_equilibrium_index(array):\n    # Calculate the total sum of the array\n    create a variable named \"total_sum\" and set it to the sum of all elements in the array\n\n    # Initialize left sum to 0\n    create a variable named \"left_sum\" and set it to 0\n\n    # Iterate through the array from start to end\n    for each index in array:\n        # Subtract the current element from the total sum\n        subtract the current element from \"total_sum\"\n\n        # If left sum is equal to total sum, return the current index\n        if \"left_sum\" is equal to \"total_sum\":\n            return the current index\n\n        # Add the current element to the left sum\n        add the current element to \"left_sum\"\n\n    # If no equilibrium index is found, return -1\n    return -1",
    "701": "function find_minimum_elements_to_remove(input_list, k):\n    # Sort the input list in ascending order\n    sort input_list in ascending order\n\n    # Initialize variables to keep track of the minimum and maximum elements\n    set min_element to the first element in input_list\n    set max_element to the last element in input_list\n\n    # Initialize a variable to keep track of the minimum number of elements to remove\n    set minimum_elements to 0\n\n    # Loop until max_element - min_element <= k\n    while max_element - min_element > k:\n        # Increment minimum_elements by 1\n        increment minimum_elements by 1\n\n        # Increment min_element by 1\n        increment min_element by 1\n\n        # Decrement max_element by 1\n        decrement max_element by 1\n\n    # Return the minimum number of elements to remove\n    return minimum_elements",
    "702": "function check_key_in_dictionary(dictionary, key):\n    # Check if the key is in the dictionary\n    if key is in dictionary:\n        # If it is, return True\n        return True\n    else:\n        # If it's not, return False\n        return False",
    "703": "function calculate_harmonic_sum(n):\n    # Initialize the sum to 0\n    initialize a variable named \"sum\" to 0\n\n    # Loop from 1 to n\n    for i from 1 to n:\n        # Add the reciprocal of i to the sum\n        add 1 divided by i to \"sum\"\n\n    # Return the sum\n    return \"sum\"",
    "704": "function sort_list_of_lists(list_of_lists):\n    # Create an empty list to store the sorted list of lists\n    create an empty list named \"sorted_list\"\n\n    # Loop through each list in the input list of lists\n    for each list in list_of_lists:\n        # Add the list to the sorted list if it's not already in the sorted list\n        if list is not already in \"sorted_list\":\n            add list to \"sorted_list\"\n\n    # Sort the sorted list of lists by length and value\n    sort \"sorted_list\" by length and value\n\n    # Return the sorted list of lists\n    return \"sorted_list\"",
    "705": "function is_subset(array1, array2):\n    # Loop through each element in the first array\n    for each element in array1:\n        # Check if the element is in the second array\n        if element is not in array2:\n            # If it's not, then array1 is not a subset of array2, so return False\n            return False\n\n    # If we've checked all elements of array1 and found no elements not in array2, then array1 is a subset of array2, so return True\n    return True",
    "706": "function count_set_bits(n):\n    # Initialize result\n    let result = 0\n\n    # Traverse through all numbers from 1 to n\n    for i from 1 to n:\n        # Count set bits in current number\n        let count = count_set_bits_in_number(i)\n\n        # Add count to result\n        result = result + count\n\n    # Return result\n    return result\n\nfunction count_set_bits_in_number(number):\n    # Initialize count\n    let count = 0\n\n    # Loop through each bit in the number\n    for each bit in number:\n        # If the bit is set, increment count\n        if bit is set:\n            count = count + 1\n\n    # Return count\n    return count",
    "707": "function convert_string_to_list(input_string):\n    # Create an empty list to store the characters\n    create an empty list named \"output_list\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Add the character to the list\n        add character to \"output_list\"\n\n    # Return the list\n    return \"output_list\"",
    "708": "function count_unique_keys(input_tuple):\n    # Create an empty dictionary to keep track of unique keys for each value\n    create an empty dictionary named \"unique_keys\"\n\n    # Loop through each item in the input tuple\n    for each item in input_tuple:\n        # Check if the item is already in the dictionary\n        if item is already in \"unique_keys\":\n            # If it is, increment the count for that item\n            increment the count for item in \"unique_keys\"\n        else:\n            # If it's a new item, add it to the dictionary with a count of 1\n            add item to \"unique_keys\" with a count of 1\n\n    # Return the dictionary of unique keys for each value\n    return \"unique_keys\"",
    "709": "function access_initial_and_last_data(tuple_record):\n    # Check if the tuple is empty\n    if tuple_record is empty:\n        # If it is, return a message indicating that the tuple is empty\n        return \"The tuple is empty\"\n    else:\n        # If it's not, access the initial and last data of the tuple\n        initial_data = first item in tuple_record\n        last_data = last item in tuple_record\n\n        # Return the initial and last data\n        return initial_data, last_data",
    "710": "function check_product_of_digits(number):\n    # Convert the number to a string to easily access its digits\n    convert number to string and assign it to \"number_string\"\n\n    # Initialize variables to keep track of the product of digits at even and odd places\n    initialize \"product_even\" to 1\n    initialize \"product_odd\" to 1\n\n    # Loop through each digit in the number\n    for each digit in number_string:\n        # Convert the digit back to an integer\n        convert digit back to integer and assign it to \"digit\"\n\n        # Check if the digit's place is even or odd\n        if digit's place is even:\n            # Multiply the product_even by the digit\n            multiply product_even by digit\n        else:\n            # Multiply the product_odd by the digit\n            multiply product_odd by digit\n\n    # Check if the products are equal\n    if product_even is equal to product_odd:\n        # If they are, return True\n        return True\n    else:\n        # If they aren't, return False\n        return False",
    "711": "function remove_duplicates(list_of_lists):\n    # Create an empty collection to keep track of unique lists\n    create an empty collection named \"unique_lists\"\n\n    # Loop through each list in the input list of lists\n    for each list in list_of_lists:\n        # Check if we've come across this list before\n        if list is already in \"unique_lists\":\n            # If we have, this is a duplicate list, so skip it\n            continue\n        else:\n            # If it's a new list, add it to our collection to remember it\n            add list to \"unique_lists\"\n\n    # Return the collection of unique lists\n    return unique_lists",
    "712": "function check_tuple_values(input_tuple, valid_values):\n    # Loop through each value in the input tuple\n    for each value in input_tuple:\n        # Check if the value is not in the valid values\n        if value is not in valid_values:\n            # If it's not valid, return False\n            return False\n\n    # If we've checked all values and found no invalid values, return True\n    return True",
    "713": "function count_distinct_prime_factors(number):\n    # Create a set to keep track of distinct prime factors\n    create an empty set named \"prime_factors\"\n\n    # Loop through each number from 2 to the given number\n    for each number from 2 to the given number:\n        # Check if the given number is divisible by the current number\n        if the given number is divisible by the current number:\n            # If it is, add the current number to the set of prime factors\n            add the current number to \"prime_factors\"\n\n    # Return the size of the set of prime factors\n    return the size of \"prime_factors\"",
    "714": "function convert_string_to_tuple(input_string):\n    # Create an empty list to store the integers\n    create an empty list named \"integer_list\"\n\n    # Split the input string into a list of strings, using the space as a delimiter\n    split input_string into a list of strings named \"string_list\" using the space as a delimiter\n\n    # Loop through each string in the list\n    for each string in \"string_list\":\n        # Convert the string to an integer and add it to the list\n        convert string to an integer and add it to \"integer_list\"\n\n    # Convert the list to a tuple and return it\n    convert \"integer_list\" to a tuple and return it",
    "715": "function find_rombus_perimeter(diagonal1, diagonal2):\n    # Calculate the perimeter of the rombus\n    perimeter = 2 * sqrt(square(diagonal1) + square(diagonal2))\n\n    # Return the calculated perimeter\n    return perimeter",
    "716": "function calculate_standard_deviation(list_of_numbers):\n    # Calculate the mean of the list of numbers\n    mean = calculate_mean(list_of_numbers)\n\n    # Create a variable to store the sum of squared differences from the mean\n    sum_of_squared_differences = 0\n\n    # Loop through each number in the list\n    for each number in list_of_numbers:\n        # Calculate the difference between the number and the mean\n        difference = number - mean\n\n        # Square the difference\n        squared_difference = difference * difference\n\n        # Add the squared difference to the sum\n        sum_of_squared_differences = sum_of_squared_differences + squared_difference\n\n    # Calculate the variance by dividing the sum by the number of elements in the list\n    variance = sum_of_squared_differences / list_of_numbers.length\n\n    # Calculate the standard deviation by taking the square root of the variance\n    standard_deviation = sqrt(variance)\n\n    # Return the standard deviation\n    return standard_deviation\n\nfunction calculate_mean(list_of_numbers):\n    # Create a variable to store the sum of all numbers\n    sum_of_numbers = 0\n\n    # Loop through each number in the list\n    for each number in list_of_numbers:\n        # Add the number to the sum\n        sum_of_numbers = sum_of_numbers + number\n\n    # Calculate the mean by dividing the sum by the number of elements in the list\n    mean = sum_of_numbers / list_of_numbers.length\n\n    # Return the mean\n    return mean",
    "717": "function create_alternate_list(input_list):\n    # Create an empty list to store the alternate elements\n    create an empty list named \"alternate_list\"\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # Add the element to the alternate_list\n        add element to \"alternate_list\"\n\n    # Return the alternate_list\n    return alternate_list",
    "718": "function match_string(input_string):\n    # Create a regular expression pattern to match the string\n    create a pattern that matches a string that starts with an 'a' and is followed by zero or more 'b's\n\n    # Check if the input string matches the pattern\n    if input_string matches the pattern:\n        # If it does, return True\n        return True\n    else:\n        # If it doesn't, return False\n        return False",
    "719": "function add_dictionary_to_tuple(tuple, dictionary):\n    # Check if the first argument is a tuple\n    if type of first argument is not tuple:\n        # If not, raise an error\n        raise TypeError(\"The first argument must be a tuple\")\n\n    # Check if the second argument is a dictionary\n    if type of second argument is not dictionary:\n        # If not, raise an error\n        raise TypeError(\"The second argument must be a dictionary\")\n\n    # Convert the tuple to a list\n    convert the first argument to a list\n\n    # Add the dictionary to the list\n    add the second argument to the list\n\n    # Convert the list back to a tuple\n    convert the list back to a tuple\n\n    # Return the new tuple\n    return the new tuple",
    "720": "function find_max_average_path(matrix):\n    # Initialize variables to store the maximum average and the path\n    max_average = -infinity\n    max_path = []\n\n    # Loop through each cell in the matrix\n    for each cell in matrix:\n        # Initialize variables to store the current path and its average\n        current_path = [cell]\n        current_average = cell.value\n\n        # Loop through each neighbor of the current cell\n        for each neighbor in cell.neighbors:\n            # Add the neighbor to the current path and update the average\n            current_path.append(neighbor)\n            current_average += neighbor.value\n\n            # If the current path is longer than the max_path, update max_path and max_average\n            if len(current_path) > len(max_path):\n                max_path = current_path\n                max_average = current_average / len(max_path)\n\n            # If the current path is the same length as the max_path, but has a higher average, update max_path and max_average\n            elif len(current_path) == len(max_path) and current_average / len(current_path) > max_average:\n                max_path = current_path\n                max_average = current_average / len(max_path)\n\n    # Return the maximum average and the path\n    return max_average, max_path",
    "721": "function filter_student_dimensions(student_dict, min_height, min_width):\n    # Create an empty dictionary to store the filtered students\n    create an empty dictionary named \"filtered_students\"\n\n    # Loop through each student in the student dictionary\n    for each student in student_dict:\n        # Check if the student's height and width are greater than the minimum values\n        if student's height is greater than or equal to min_height and student's width is greater than or equal to min_width:\n            # If they are, add the student to the filtered_students dictionary\n            add student to \"filtered_students\"\n\n    # Return the filtered_students dictionary\n    return filtered_students",
    "722": "function count_same_pairs(list1, list2):\n    # Create an empty dictionary to keep track of pairs we've seen\n    create an empty dictionary named \"pair_counts\"\n\n    # Loop through each pair in the first list\n    for each pair in list1:\n        # Check if we've come across this pair before\n        if pair is already in \"pair_counts\":\n            # If we have, increment the count\n            increment the count for pair in \"pair_counts\"\n        else:\n            # If it's a new pair, add it to our dictionary with a count of 1\n            add pair to \"pair_counts\" with a count of 1\n\n    # Loop through each pair in the second list\n    for each pair in list2:\n        # Check if we've come across this pair before\n        if pair is already in \"pair_counts\":\n            # If we have, increment the count\n            increment the count for pair in \"pair_counts\"\n        else:\n            # If it's a new pair, add it to our dictionary with a count of 1\n            add pair to \"pair_counts\" with a count of 1\n\n    # Return the dictionary of pair counts\n    return pair_counts",
    "723": "function calculate_sum_of_digits(base, power):\n    # Calculate the result of the base to the power\n    result = base ** power\n\n    # Convert the result to a string to easily iterate over its digits\n    result_string = convert result to string\n\n    # Initialize a variable to keep track of the sum of the digits\n    sum_of_digits = 0\n\n    # Loop through each digit in the result string\n    for each digit in result_string:\n        # Convert the digit back to an integer and add it to the sum\n        sum_of_digits = sum_of_digits + convert digit to integer\n\n    # Return the sum of the digits\n    return sum_of_digits",
    "724": "function extract_values_between_quotation_marks(input_string):\n    # Import the 're' module for regular expressions\n    import re\n\n    # Use the 'findall' function from the 're' module to find all matches of the pattern\n    # The pattern is a string that contains quotation marks\n    matches = re.findall(r'\"(.*?)\"', input_string)\n\n    # Return the matches\n    return matches",
    "725": "function multiply_adjacent_elements(input_tuple):\n    # Create an empty list to store the results\n    create an empty list named \"results\"\n\n    # Loop through each pair of adjacent elements in the input tuple\n    for each pair of adjacent elements in input_tuple:\n        # Multiply the elements in the pair and add the result to the results list\n        multiply the elements in the pair and add the result to \"results\"\n\n    # Return the results list\n    return \"results\"",
    "726": "function remove_non_alphanumeric_characters(input_string):\n    # Import the regular expression module\n    import regular_expression_module\n\n    # Use the regular expression to find and replace all non-alphanumeric characters with nothing\n    new_string = regular_expression_module.sub('[^a-zA-Z0-9]', '', input_string)\n\n    # Return the new string\n    return new_string",
    "727": "function sum_elements_in_lists(list1, list2):\n    # Create an empty list to store the sum of elements\n    create an empty list named \"sum_list\"\n\n    # Loop through each element in the first list\n    for each element in list1:\n        # Add the element to the sum_list\n        add element to sum_list\n\n    # Loop through each element in the second list\n    for each element in list2:\n        # Add the element to the sum_list\n        add element to sum_list\n\n    # Return the sum_list\n    return sum_list",
    "728": "function add_lists(list1, list2):\n    # Check if both lists have the same length\n    if length of list1 is not equal to length of list2:\n        # If not, return an error message\n        return \"Error: Lists must have the same length\"\n\n    # Use the map function to apply a lambda function to each pair of elements in list1 and list2\n    result = map(lambda x, y: x + y, list1, list2)\n\n    # Convert the result to a list and return it\n    return list(result)",
    "729": "function remove_consecutive_duplicates(input_list):\n    # Create an empty list to store the result\n    create an empty list named \"result\"\n\n    # Loop through each item in the input list\n    for each item in input_list:\n        # Check if the last item in the result list is the same as the current item\n        if the last item in \"result\" is the same as item:\n            # If they are the same, skip this item\n            continue\n        else:\n            # If they are different, add the current item to the result list\n            add item to \"result\"\n\n    # Return the result list\n    return \"result\"",
    "730": "function lateral_surface_area_of_cone(radius, height):\n    # Calculate the slant height of the cone\n    slant_height = sqrt(radius^2 + height^2)\n\n    # Calculate the lateral surface area of the cone\n    lateral_surface_area = pi * radius * slant_height\n\n    # Return the lateral surface area of the cone\n    return lateral_surface_area",
    "731": "function replace_spaces_commas_dots_with_colon(input_string):\n    # Create a new string where we'll store the result\n    create a new string named \"result\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is a space, comma, or dot\n        if character is a space, comma, or dot:\n            # If it is, replace it with a colon\n            add a colon to \"result\"\n        else:\n            # If it's not a special character, just add the character to \"result\"\n            add character to \"result\"\n\n    # Return the new string\n    return \"result\"",
    "732": "function find_first_occurrence(sorted_array, target_number):\n    # Initialize the start and end indices of the search space\n    set start_index to 0\n    set end_index to the length of sorted_array - 1\n\n    # While the search space is not empty\n    while start_index <= end_index:\n        # Find the middle index of the search space\n        set mid_index to (start_index + end_index) / 2\n\n        # If the target number is at the middle index or to the left of it\n        if sorted_array[mid_index] >= target_number:\n            # If the target number is at the middle index and it's not the first occurrence\n            if sorted_array[mid_index] > target_number and sorted_array[mid_index - 1] == target_number:\n                # Return the index of the first occurrence\n                return mid_index\n            # If the target number is at the middle index and it's the first occurrence\n            if sorted_array[mid_index] == target_number and mid_index == 0:\n                # Return the index of the first occurrence\n                return mid_index\n            # If the target number is not at the middle index and it's not the first occurrence\n            if sorted_array[mid_index] == target_number and sorted_array[mid_index - 1] != target_number:\n                # Return the index of the first occurrence\n                return mid_index\n            # If the target number is not at the middle index and it's the first occurrence\n            if sorted_array[mid_index] > target_number:\n                # Set the end index to the middle index - 1\n                set end_index to mid_index - 1\n            # If the target number is at the middle index\n            else:\n                # Set the end index to the middle index - 1\n                set end_index to mid_index - 1\n        # If the target number is to the right of the middle index\n        else:\n            # Set the start index to the middle index + 1\n            set start_index to mid_index + 1\n\n    # If the target number is not in the array, return -1\n    return -1",
    "733": "function sum_of_products_of_subarrays(input_array):\n    # Initialize sum to 0\n    initialize sum to 0\n\n    # Loop through each element in the input array\n    for each element in input_array:\n        # Loop through each subarray starting from the current element\n        for each subarray starting from the current element:\n            # Calculate the product of the elements in the subarray\n            calculate the product of the elements in the subarray\n\n            # Add the product to the sum\n            add the product to the sum\n\n    # Return the sum\n    return sum",
    "734": "function toggle_bits(number):\n    # Convert the number to binary\n    convert number to binary\n\n    # Get the binary representation as a string\n    get the binary representation as a string\n\n    # Iterate over the string from the second character to the second last character\n    for each character in the string from the second character to the second last character:\n        # If the character is '1', toggle it to '0'\n        if character is '1':\n            replace character with '0'\n        # If the character is '0', toggle it to '1'\n        else if character is '0':\n            replace character with '1'\n\n    # Convert the modified string back to an integer\n    convert the modified string back to an integer\n\n    # Return the modified number\n    return the modified number",
    "735": "function locate_left_insertion_point(sorted_list, value):\n    # Initialize the start and end indices of the search range\n    set start_index to 0\n    set end_index to the length of sorted_list - 1\n\n    # Continue the search until the start and end indices meet\n    while start_index <= end_index:\n        # Calculate the midpoint of the current search range\n        set mid_index to the floor of (start_index + end_index) / 2\n\n        # If the midpoint value is less than the target value,\n        # the target value should be inserted after the midpoint\n        if sorted_list[mid_index] < value:\n            set start_index to mid_index + 1\n        # If the midpoint value is greater than or equal to the target value,\n        # the target value should be inserted before the midpoint\n        else:\n            set end_index to mid_index - 1\n\n    # Return the start index as the left insertion point\n    return start_index",
    "736": "function check_starting_vowel(input_string):\n    # Import the regular expression module\n    import regex\n\n    # Define the regular expression pattern for vowels\n    pattern = \"^[aeiou]\"\n\n    # Use the match function from the regex module to check if the input string starts with a vowel\n    if regex.match(pattern, input_string, regex.IGNORECASE):\n        # If it does, return True\n        return True\n    else:\n        # If it doesn't, return False\n        return False",
    "737": "function geometric_sum(n):\n    # If n is 0, return 0\n    if n is 0:\n        return 0\n    # Otherwise, return 1 divided by 2 raised to the power of n-1\n    else:\n        return 1 divided by 2 raised to the power of n-1",
    "738": "function find_smallest_triangular_number(n):\n    # Initialize variables\n    set variable \"i\" to 1\n    set variable \"triangular_number\" to 0\n    set variable \"smallest_index\" to 0\n\n    # Loop until we find a triangular number with n digits\n    while the number of digits in \"triangular_number\" is less than n:\n        # Calculate the next triangular number\n        set \"triangular_number\" to \"i\" * (\"i\" + 1) / 2\n\n        # Check if this triangular number has n digits\n        if the number of digits in \"triangular_number\" is equal to n:\n            # If it does, update the smallest index\n            set \"smallest_index\" to \"i\"\n\n        # Increment the counter\n        increment \"i\" by 1\n\n    # Return the smallest index\n    return \"smallest_index\"",
    "739": "function convert_tuple_to_dict(input_tuple):\n    # Create an empty dictionary to store the result\n    create an empty dictionary named \"result_dict\"\n\n    # Loop through the input tuple\n    for each index in range(0, len(input_tuple), 2):\n        # Add the current element and the next element to the dictionary\n        add input_tuple[index] as key and input_tuple[index + 1] as value to \"result_dict\"\n\n    # Return the resulting dictionary\n    return \"result_dict\"",
    "740": "function check_all_characters_same(input_string):\n    # Check if the string is empty\n    if input_string is empty:\n        # If it is, return True because there are no characters to check\n        return True\n\n    # Get the first character in the string\n    set first_character to the first character in input_string\n\n    # Loop through each character in the string\n    for each character in input_string:\n        # If the character is not the same as the first character, return False\n        if character is not the same as first_character:\n            return False\n\n    # If we've checked all characters and found they're all the same, return True\n    return True",
    "741": "function calculate_tetrahedron_area(edge_length):\n    # Calculate the area of a tetrahedron using the formula: sqrt(3) * edge_length^2\n    area = sqrt(3) * edge_length^2\n\n    # Return the calculated area\n    return area",
    "742": "function rotate_list(input_list, number_of_items):\n    # Calculate the effective number of items to rotate by taking the modulus of the length of the list\n    effective_number_of_items = number_of_items modulo length of input_list\n\n    # If the effective number of items is zero, there's no need to rotate, so return the original list\n    if effective_number_of_items is 0:\n        return input_list\n\n    # Otherwise, slice the list into two parts, the part to rotate and the rest\n    part_to_rotate = last effective_number_of_items items of input_list\n    rest_of_list = all other items of input_list\n\n    # Combine the part to rotate and the rest of the list in reverse order to get the rotated list\n    rotated_list = part_to_rotate followed by rest_of_list\n\n    # Return the rotated list\n    return rotated_list",
    "743": "function check_none_value(input_tuple):\n    # Loop through each element in the input tuple\n    for each element in input_tuple:\n        # Check if the element is None\n        if element is None:\n            # If it is, return True\n            return True\n\n    # If we've checked all elements and found no None values, return False\n    return False",
    "744": "function find_divisible_numbers(start, end):\n    # Create an empty list to store the divisible numbers\n    create an empty list named \"divisible_numbers\"\n\n    # Loop through each number in the given range\n    for each number in range from start to end:\n        # Convert the number to a string to easily access its digits\n        convert number to string and store it in \"number_string\"\n\n        # Create a flag to track if the number is divisible by all its digits\n        create a boolean variable named \"is_divisible\" and set it to True\n\n        # Loop through each digit in the number\n        for each digit in \"number_string\":\n            # Check if the number is divisible by the digit\n            if number modulo digit is not equal to 0:\n                # If it's not, set the flag to False and break the loop\n                set \"is_divisible\" to False\n                break\n\n        # If the number is divisible by all its digits, add it to the list\n        if \"is_divisible\" is True:\n            add number to \"divisible_numbers\"\n\n    # Return the list of divisible numbers\n    return \"divisible_numbers\"",
    "745": "function find_area_of_sector(radius, angle):\n    # Calculate the area of the sector\n    area = 0.5 * radius^2 * angle\n\n    # Return the calculated area\n    return area",
    "746": "function longest_common_subsequence(string1, string2, string3):\n    # Create a 3D array to store the length of the longest common subsequence\n    create a 3D array named \"length\" with dimensions equal to the lengths of the strings plus 1\n\n    # Initialize the first row, first column and first depth of the array to 0\n    for i from 0 to length of string1:\n        for j from 0 to length of string2:\n            for k from 0 to length of string3:\n                length[i][j][k] = 0\n\n    # Fill the 3D array in a bottom-up manner\n    for i from 1 to length of string1:\n        for j from 1 to length of string2:\n            for k from 1 to length of string3:\n                if string1[i-1] == string2[j-1] == string3[k-1]:\n                    length[i][j][k] = length[i-1][j-1][k-1] + 1\n                else:\n                    length[i][j][k] = max(length[i-1][j][k], length[i][j-1][k], length[i][j][k-1])\n\n    # Return the length of the longest common subsequence\n    return length[length of string1][length of string2][length of string3]",
    "747": "function put_spaces_between_words(input_string):\n    # Import the regex module\n    import regex\n\n    # Define the pattern for finding words starting with capital letters\n    pattern = \"\\b[A-Z][a-z]*\\b\"\n\n    # Use the regex.sub function to replace matches with the same text plus a space\n    result = regex.sub(pattern, lambda m: m.group(0) + \" \", input_string)\n\n    # Return the result\n    return result",
    "748": "function sort_numerically(list_of_strings):\n    # Create an empty list to store the numeric values\n    create an empty list named \"numeric_values\"\n\n    # Loop through each string in the list\n    for each string in list_of_strings:\n        # Try to convert the string to a numeric value\n        try to convert string to a number\n            if successful:\n                # If successful, add the numeric value to our list\n                add numeric value to \"numeric_values\"\n            else:\n                # If unsuccessful, skip this string\n                continue\n        catch any exceptions:\n            # If there was an error, skip this string\n            continue\n\n    # Sort the list of numeric values in ascending order\n    sort \"numeric_values\" in ascending order\n\n    # Return the sorted list of numeric values\n    return \"numeric_values\"",
    "749": "function add_tuple_to_list(list, tuple):\n    # Check if the list and tuple are not None\n    if list is not None and tuple is not None:\n        # Add the tuple to the list\n        append tuple to list\n    else:\n        # If either the list or tuple is None, return a message indicating an error\n        return \"Error: List or tuple is None\"\n\n    # Return the updated list\n    return list",
    "750": "function is_min_heap(array):\n    # Loop through each element in the array\n    for each element in array:\n        # Calculate the index of the parent of the current element\n        parent_index = (element_index - 1) / 2\n\n        # If the parent is greater than the current element, return False\n        if array[parent_index] > array[element_index]:\n            return False\n\n    # If we've checked all elements and found no violations, return True\n    return True",
    "751": "function find_nth_jacobsthal_number(n):\n    # If n is 0, return 0\n    if n is 0:\n        return 0\n    # If n is 1, return 1\n    if n is 1:\n        return 1\n    # Otherwise, calculate the nth Jacobsthal number using the formula 2*find_nth_jacobsthal_number(n-1) + find_nth_jacobsthal_number(n-2)\n    else:\n        return 2*find_nth_jacobsthal_number(n-1) + find_nth_jacobsthal_number(n-2)",
    "752": "function find_minimum_k_records(tuple_list, k):\n    # Create an empty list to keep track of minimum k records\n    create an empty list named \"minimum_k_records\"\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Check if the list of minimum k records is not full\n        if the length of \"minimum_k_records\" is less than k:\n            # If it's not full, add the tuple to the list\n            add tuple to \"minimum_k_records\"\n        else:\n            # If it's full, check if the tuple is smaller than the largest tuple in the list\n            if tuple is smaller than the largest tuple in \"minimum_k_records\":\n                # If it is, remove the largest tuple and add the new tuple\n                remove the largest tuple from \"minimum_k_records\"\n                add tuple to \"minimum_k_records\"\n\n    # Return the list of minimum k records\n    return \"minimum_k_records\"",
    "753": "function find_common_index_elements(list1, list2, list3):\n    # Create an empty list to store the common elements\n    create an empty list named \"common_elements\"\n\n    # Loop through each index in the lists\n    for each index in range(0, len(list1)):\n        # Check if the elements at this index are the same in all three lists\n        if list1[index] is equal to list2[index] and list2[index] is equal to list3[index]:\n            # If they are, add them to the common_elements list\n            add list1[index] to \"common_elements\"\n\n    # Return the list of common elements\n    return \"common_elements\"",
    "754": "function find_second_smallest(list_of_numbers):\n    # Initialize two variables to keep track of the smallest and second smallest numbers\n    set smallest to the maximum possible integer value\n    set second_smallest to the maximum possible integer value\n\n    # Loop through each number in the list\n    for each number in list_of_numbers:\n        # If the current number is smaller than the smallest number we've seen so far\n        if number is less than smallest:\n            # Update the second smallest number to be the smallest number\n            set second_smallest to smallest\n            # Update the smallest number to be the current number\n            set smallest to number\n        # If the current number is not smaller than the smallest number, but is smaller than the second smallest number\n        else if number is less than second_smallest and number is not equal to smallest:\n            # Update the second smallest number to be the current number\n            set second_smallest to number\n\n    # If we've checked all numbers and found no repeats, return a signal (like None or a message)\n    if second_smallest is equal to the maximum possible integer value:\n        return \"No second smallest number found\"\n    else:\n        return second_smallest",
    "755": "function match_string(input_string):\n    # Create a regular expression pattern to match the string\n    create a regular expression pattern named \"pattern\" that matches a string that has an 'a' followed by zero or one 'b'\n\n    # Check if the input string matches the pattern\n    if input_string matches \"pattern\":\n        # If it does, return True\n        return True\n    else:\n        # If it doesn't, return False\n        return False",
    "756": "function count_reverse_pairs(input_list):\n    # Initialize a counter for the number of reverse pairs\n    set counter to 0\n\n    # Loop through each string in the input list\n    for each string in input_list:\n        # Loop through each other string in the input list\n        for each other_string in input_list:\n            # Check if the current string and its reverse are the same\n            if string is the reverse of other_string:\n                # If they are, increment the counter\n                increment counter by 1\n\n    # Return the final count\n    return counter",
    "757": "function count_unique_lists(list_of_lists):\n    # Create an empty collection to keep track of unique lists\n    create an empty collection named \"unique_lists\"\n\n    # Loop through each list in the input list\n    for each list in list_of_lists:\n        # Check if we've come across this list before\n        if list is already in \"unique_lists\":\n            # If we have, this is a duplicate list, so skip it\n            continue\n        else:\n            # If it's a new list, add it to our collection to remember it\n            add list to \"unique_lists\"\n\n    # Return the count of unique lists\n    return the count of \"unique_lists\"",
    "758": "function check_decimal_precision(input_decimal):\n    # Convert the input decimal to a string\n    convert input_decimal to a string and store it in a variable named \"decimal_string\"\n\n    # Check if the decimal string contains a \".\"\n    if \".\" is in \"decimal_string\":\n        # If it does, split the string into two parts at the \".\"\n        split \"decimal_string\" at the \".\" and store the two parts in variables named \"integer_part\" and \"fractional_part\"\n\n        # Check if the fractional part has exactly 2 digits\n        if the length of \"fractional_part\" is equal to 2:\n            # If it does, return True\n            return True\n        else:\n            # If it doesn't, return False\n            return False\n    else:\n        # If the decimal string doesn't contain a \".\", it's an integer, so return False\n        return False",
    "759": "function check_distinct_elements(input_array):\n    # Create a variable to keep track of the first element we've seen\n    create a variable named \"first_element\" and set it to the first element of the input_array\n\n    # Loop through each element in the input array\n    for each element in input_array:\n        # Check if the current element is not equal to the first element we've seen\n        if element is not equal to \"first_element\":\n            # If it's not, this means we've found a second distinct element, so return False\n            return False\n\n    # If we've checked all elements and found no repeats, return True\n    return True",
    "760": "function calculate_arc_length(angle, radius):\n    # Check if the angle is less than 0 or greater than 360\n    if angle < 0 or angle > 360:\n        # If it is, return an error message\n        return \"Invalid angle. Angle should be between 0 and 360.\"\n\n    # Calculate the arc length using the formula: arc length = angle * radius\n    arc_length = angle * radius\n\n    # Return the calculated arc length\n    return arc_length",
    "761": "function check_month_with_30_days(month_number):\n    # Create a list of months that have 30 days\n    create a list named \"months_with_30_days\" with the numbers 4, 6, 9, 11\n\n    # Check if the given month number is in the list of months with 30 days\n    if month_number is in \"months_with_30_days\":\n        # If it is, return True\n        return True\n    else:\n        # If it's not, return False\n        return False",
    "762": "function find_minimum_difference(input_array):\n    # Check if the array has less than 2 elements\n    if the length of input_array is less than 2:\n        # If so, return a signal (like None or a message)\n        return None\n\n    # Sort the array in ascending order\n    sort input_array in ascending order\n\n    # Initialize a variable to keep track of the minimum difference\n    initialize a variable named \"min_difference\" to be the maximum possible integer value\n\n    # Loop through each pair of adjacent elements in the sorted array\n    for each pair of adjacent elements in input_array:\n        # Calculate the difference between the pair\n        calculate the difference between the pair\n\n        # If this difference is less than the current minimum difference\n        if the difference is less than min_difference:\n            # Update the minimum difference\n            update min_difference to be the difference\n\n    # Return the minimum difference\n    return min_difference",
    "763": "function count_numeric_values(input_string):\n    # Initialize a counter to keep track of numeric values\n    set a counter to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is a digit\n        if character is a digit:\n            # If it is, increment the counter\n            increment the counter by 1\n\n    # Return the final count\n    return counter",
    "764": "function find_nth_polite_number(n):\n    # Create a list to store polite numbers\n    create an empty list named \"polite_numbers\"\n\n    # Initialize the first polite number\n    add 1 to \"polite_numbers\"\n\n    # Loop until we've found n polite numbers\n    while the size of \"polite_numbers\" is less than n:\n        # Get the last number in the list\n        get the last number in \"polite_numbers\" and call it \"last_number\"\n\n        # Append the next polite number to the list\n        append \"last_number\" plus 1 to \"polite_numbers\"\n\n        # Check if the next number is polite\n        if \"last_number\" plus 1 is not a polite number:\n            # If it's not, remove it from the list\n            remove the last number in \"polite_numbers\"\n\n    # Return the nth polite number\n    return the nth number in \"polite_numbers\"",
    "765": "function iterate_over_consecutive_pairs(input_list):\n    # Loop through each index in the input list\n    for each index in range(len(input_list) - 1):\n        # Get the current item and the next item\n        current_item = input_list[index]\n        next_item = input_list[index + 1]\n\n        # Do something with the current item and the next item\n        # For example, print them out\n        print(current_item, next_item)\n\n    # If we've checked all pairs, return a signal (like None or a message)\n    return None",
    "766": "function count_pairs_with_sum(list_of_numbers, sum):\n    # Create an empty collection to keep track of numbers we've seen\n    create an empty collection named \"seen_numbers\"\n\n    # Initialize a counter for the number of pairs\n    initialize a variable named \"pair_count\" to 0\n\n    # Loop through each number in the list\n    for each number in list_of_numbers:\n        # Calculate the complement we need to reach the sum\n        calculate the complement as sum minus number\n\n        # Check if we've come across this complement before\n        if complement is already in \"seen_numbers\":\n            # If we have, this is a pair, so increment the pair count\n            increment \"pair_count\" by 1\n        else:\n            # If it's a new number, add it to our collection to remember it\n            add number to \"seen_numbers\"\n\n    # Return the pair count\n    return pair_count",
    "767": "function check_odd_parity(number):\n    # Initialize a counter to keep track of the number of 1s in the binary representation of the number\n    initialize a counter named \"one_count\" to 0\n\n    # Convert the number to its binary representation\n    convert number to binary\n\n    # Loop through each digit in the binary representation\n    for each digit in binary representation:\n        # If the digit is 1, increment the counter\n        if digit is 1:\n            increment \"one_count\" by 1\n\n    # Check if the count of 1s is odd\n    if \"one_count\" is odd:\n        # If it is, return True\n        return True\n    else:\n        # If it's not, return False\n        return False",
    "768": "function get_difference(list1, list2):\n    # Create an empty list to store the difference\n    create an empty list named \"difference\"\n\n    # Loop through each element in list1\n    for each element in list1:\n        # Check if the element is not in list2\n        if element is not in list2:\n            # If it's not in list2, add it to the difference list\n            add element to \"difference\"\n\n    # Return the difference list\n    return \"difference\"",
    "769": "function sum_of_fourth_power_of_first_n_odd_numbers(n):\n    # Initialize a variable to keep track of the sum\n    initialize a variable named \"sum\" to 0\n\n    # Initialize a variable to keep track of the current odd number\n    initialize a variable named \"current_odd_number\" to 1\n\n    # Initialize a counter to keep track of how many odd numbers we've added\n    initialize a variable named \"counter\" to 0\n\n    # Loop until we've added n odd numbers\n    while counter < n:\n        # Add the fourth power of the current odd number to the sum\n        add the fourth power of \"current_odd_number\" to \"sum\"\n\n        # Increment the counter and the current odd number\n        increment \"counter\" by 1\n        increment \"current_odd_number\" by 2\n\n    # Return the sum\n    return \"sum\"",
    "770": "function is_balanced(expression):\n    # Create a stack to keep track of opening brackets\n    create an empty stack named \"bracket_stack\"\n\n    # Loop through each character in the expression\n    for each character in expression:\n        # If the character is an opening bracket, push it onto the stack\n        if character is an opening bracket:\n            push character onto \"bracket_stack\"\n        # If the character is a closing bracket\n        else if character is a closing bracket:\n            # If the stack is empty, the expression is not balanced\n            if \"bracket_stack\" is empty:\n                return False\n            # Otherwise, pop the top bracket off the stack\n            pop the top bracket from \"bracket_stack\"\n            # If the bracket doesn't match the closing bracket, the expression is not balanced\n            if the popped bracket does not match the closing bracket:\n                return False\n\n    # If the stack is empty at the end, the expression is balanced\n    if \"bracket_stack\" is empty:\n        return True\n    # Otherwise, the expression is not balanced\n    else:\n        return False",
    "771": "function remove_words_with_k_length(input_string, k):\n    # Split the input string into a list of words\n    split input_string into words\n\n    # Create an empty list to keep track of words we'll keep\n    create an empty list named \"words_to_keep\"\n\n    # Loop through each word in the list of words\n    for each word in words:\n        # Check if the length of the word is not equal to k\n        if length of word is not equal to k:\n            # If it's not, add it to our list of words to keep\n            add word to \"words_to_keep\"\n\n    # Join the list of words to keep into a string\n    join \"words_to_keep\" into a string\n\n    # Return the string of words to keep\n    return the string",
    "772": "function find_substring_occurrence_and_position(input_string, substring):\n    # Create an empty list to keep track of occurrences and positions\n    create an empty list named \"occurrences\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the current character and the next few characters form the substring\n        if the next few characters in the input string form the substring:\n            # If they do, add the occurrence and position to our list\n            add the occurrence and position to \"occurrences\"\n\n    # Return the list of occurrences and positions\n    return \"occurrences\"",
    "773": "function is_valid_email(email):\n    # Import the regular expression module\n    import re\n\n    # Define the regular expression pattern for a valid email address\n    pattern = '^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\\.[a-zA-Z0-9-.]+$'\n\n    # Use the match function from the re module to check if the email matches the pattern\n    if re.match(pattern, email):\n        # If it does, return True\n        return True\n    else:\n        # If it doesn't, return False\n        return False",
    "774": "function check_odd_index_odd_numbers(input_list):\n    # Loop through each index in the input list\n    for each index in range(0, len(input_list), 2):\n        # Check if the number at the current index is odd\n        if input_list[index] is not odd:\n            # If it's not odd, return False\n            return False\n\n    # If we've checked all odd indices and found no odd numbers, return True\n    return True",
    "775": "function count_vowel_neighbors(input_string):\n    # Define the vowels\n    define the set of vowels as \"vowels\"\n\n    # Initialize a counter for vowel neighbors\n    initialize a counter named \"vowel_neighbors\" to 0\n\n    # Loop through each character in the string\n    for each character in input_string:\n        # Check if the character is a vowel\n        if character is in \"vowels\":\n            # Check if the previous character is also a vowel\n            if the previous character is in \"vowels\":\n                # If so, increment the counter\n                increment \"vowel_neighbors\" by 1\n            # Check if the next character is also a vowel\n            if the next character is in \"vowels\":\n                # If so, increment the counter\n                increment \"vowel_neighbors\" by 1\n\n    # Return the count of vowel neighbors\n    return \"vowel_neighbors\"",
    "776": "function find_sum_of_non_repeated_elements(input_array):\n    # Create an empty dictionary to keep track of elements and their counts\n    create an empty dictionary named \"element_counts\"\n\n    # Loop through each element in the input array\n    for each element in input_array:\n        # Check if we've come across this element before\n        if element is already in \"element_counts\":\n            # If we have, increment the count for this element\n            increment the count for element in \"element_counts\"\n        else:\n            # If it's a new element, add it to our dictionary with a count of 1\n            add element to \"element_counts\" with a count of 1\n\n    # Create a variable to keep track of the sum of non-repeated elements\n    create a variable named \"sum_of_non_repeated_elements\" and set it to 0\n\n    # Loop through each element in the input array\n    for each element in input_array:\n        # Check if the count for this element is 1\n        if the count for element in \"element_counts\" is 1:\n            # If it is, add the element to the sum of non-repeated elements\n            add element to \"sum_of_non_repeated_elements\"\n\n    # Return the sum of non-repeated elements\n    return \"sum_of_non_repeated_elements\"",
    "777": "function pack_consecutive_duplicates(input_list):\n    # Create an empty list to store the result\n    create an empty list named \"result\"\n\n    # Create a variable to store the current sublist\n    create a variable named \"current_sublist\" and set it to an empty list\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # If the current element is the same as the last one in the sublist\n        if element is the same as the last element in \"current_sublist\":\n            # Add the element to the sublist\n            add element to \"current_sublist\"\n        else:\n            # If it's a new element, add the current sublist to the result and start a new one\n            add \"current_sublist\" to \"result\"\n            create a new sublist named \"current_sublist\" and add element to it\n\n    # Add the last sublist to the result\n    add \"current_sublist\" to \"result\"\n\n    # Return the result\n    return \"result\"",
    "778": "function count_unique_lists(list_of_lists):\n    # Create an empty collection to keep track of unique lists\n    create an empty collection named \"unique_lists\"\n\n    # Loop through each list in the input list of lists\n    for each list in list_of_lists:\n        # Check if we've come across this list before\n        if list is already in \"unique_lists\":\n            # If we have, this is a duplicate list, so do nothing\n            continue\n        else:\n            # If it's a new list, add it to our collection to remember it\n            add list to \"unique_lists\"\n\n    # Return the count of unique lists\n    return the count of \"unique_lists\"",
    "779": "function find_combinations_of_sums(tuple_list, target_sum):\n    # Create an empty list to store the combinations\n    create an empty list named \"combinations\"\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Initialize a variable to keep track of the current sum\n        set a variable named \"current_sum\" to 0\n\n        # Loop through each number in the tuple\n        for each number in tuple:\n            # Add the number to the current sum\n            add number to \"current_sum\"\n\n            # If the current sum is equal to the target sum, add the tuple to the combinations\n            if \"current_sum\" is equal to \"target_sum\":\n                add tuple to \"combinations\"\n\n    # Return the combinations\n    return \"combinations\"",
    "780": "function check_divisor_count(number):\n    # Initialize a variable to keep track of the count of divisors\n    set a variable named \"divisor_count\" to 0\n\n    # Loop through each number from 1 to the input number\n    for each number from 1 to input_number:\n        # Check if the input number is divisible by the current number\n        if input_number is divisible by the current number:\n            # If it is, increment the divisor count\n            increment \"divisor_count\" by 1\n\n    # Check if the divisor count is even or odd\n    if \"divisor_count\" is even:\n        # If it is, return \"even\"\n        return \"even\"\n    else:\n        # If it's not, return \"odd\"\n        return \"odd\"",
    "781": "function sum_odd_length_subarrays(arr):\n    # Initialize the sum to 0\n    sum = 0\n\n    # Loop through each element in the array\n    for i in range(len(arr)):\n        # For each element, loop through each subarray starting from that element\n        for j in range(i, len(arr), 2):\n            # Add the sum of the subarray to the total sum\n            sum += sum(arr[i:j+1])\n\n    # Return the total sum\n    return sum",
    "782": "function rgb_to_hsv(red, green, blue):\n    # Normalize the RGB values to the range [0, 1]\n    red = red / 255.0\n    green = green / 255.0\n    blue = blue / 255.0\n\n    # Find the maximum and minimum values of RGB\n    max_value = max(red, green, blue)\n    min_value = min(red, green, blue)\n\n    # Calculate the value (which is the maximum RGB value)\n    value = max_value\n\n    # Calculate the saturation (which is the difference between the maximum and minimum RGB values)\n    saturation = 0\n    if max_value != 0:\n        saturation = (max_value - min_value) / max_value\n\n    # Calculate the hue\n    hue = 0\n    if (max_value == min_value):\n        hue = 0\n    elif (max_value == red):\n        hue = (green - blue) / (max_value - min_value)\n        if (hue < 0):\n            hue += 6\n    elif (max_value == green):\n        hue = (blue - red) / (max_value - min_value) + 2\n    elif (max_value == blue):\n        hue = (red - green) / (max_value - min_value) + 4\n    hue /= 6\n\n    # Return the HSV values\n    return hue, saturation, value",
    "783": "function find_product_of_first_even_odd(input_list):\n    # Initialize variables to keep track of the first even and odd numbers\n    create a variable named \"first_even\" and set it to None\n    create a variable named \"first_odd\" and set it to None\n\n    # Loop through each number in the input list\n    for each number in input_list:\n        # Check if the number is even\n        if number is even:\n            # If it is, and we haven't found an even number yet, set it as the first even number\n            if first_even is None:\n                set first_even to number\n        else:\n            # If it's odd, and we haven't found an odd number yet, set it as the first odd number\n            if first_odd is None:\n                set first_odd to number\n\n        # If we've found both an even and an odd number, we can stop looking\n        if first_even is not None and first_odd is not None:\n            break\n\n    # If we found both an even and an odd number, return their product\n    if first_even is not None and first_odd is not None:\n        return first_even * first_odd\n    else:\n        # If we didn't find both an even and an odd number, return a signal (like None or a message)\n        return None",
    "784": "function convert_tuple_string_to_integer(tuple_string):\n    # Split the tuple string into a list of strings\n    split tuple_string into a list named \"split_string\" using the comma as the delimiter\n\n    # Create an empty list to store the integers\n    create an empty list named \"integer_list\"\n\n    # Loop through each string in the split list\n    for each string in \"split_string\":\n        # Convert the string to an integer and add it to the integer list\n        convert string to an integer and add it to \"integer_list\"\n\n    # Convert the integer list back into a tuple and return it\n    convert \"integer_list\" to a tuple and return it",
    "785": "function find_insertion_point(sorted_list, value):\n    # Initialize the start and end indices\n    start = 0\n    end = length of sorted_list\n\n    # While the start index is less than the end index\n    while start < end:\n        # Calculate the middle index\n        middle = (start + end) / 2\n\n        # If the middle value is less than the target value\n        if sorted_list[middle] < value:\n            # The target value should be inserted after the middle value\n            # So, update the start index to be one more than the middle index\n            start = middle + 1\n        else:\n            # The target value should be inserted before the middle value\n            # So, update the end index to be the middle index\n            end = middle\n\n    # Return the start index as the insertion point\n    return start",
    "786": "function match_string_with_abb(input_string):\n    # Create a counter to keep track of 'a' and 'b'\n    create a counter named \"a_counter\" and set it to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If the character is 'a', increment the counter\n        if character is 'a':\n            increment \"a_counter\" by 1\n        # If the character is 'b' and the counter is 3, return True\n        else if character is 'b' and \"a_counter\" is 3:\n            return True\n        # If the character is 'b' and the counter is not 3, decrement the counter\n        else if character is 'b' and \"a_counter\" is not 3:\n            decrement \"a_counter\" by 1\n\n    # If we've checked all characters and found no matches, return False\n    return False",
    "787": "function create_new_tuple(input_string, input_list):\n    # Create an empty tuple to store the new elements\n    create an empty tuple named \"new_tuple\"\n\n    # Add the input string and list to the new tuple\n    add input_string and input_list to \"new_tuple\"\n\n    # Return the new tuple\n    return \"new_tuple\"",
    "788": "function calculate_perimeter(number_of_sides, side_length):\n    # Check if the number of sides is less than 3\n    if number_of_sides is less than 3:\n        # If it is, return an error message\n        return \"Error: A polygon must have at least 3 sides.\"\n\n    # Calculate the perimeter by multiplying the number of sides by the side length\n    perimeter = number_of_sides * side_length\n\n    # Return the calculated perimeter\n    return perimeter",
    "789": "function check_even_index_even_numbers(input_list):\n    # Loop through each index in the input list\n    for each index in range(0, len(input_list), 2):\n        # Check if the number at the current index is even\n        if input_list[index] is not even:\n            # If it's not even, return False\n            return False\n\n    # If we've checked all even indices and found no odd numbers, return True\n    return True",
    "790": "function remove_nested_record(input_tuple):\n    # Create an empty list to store the result\n    create an empty list named \"result\"\n\n    # Loop through each element in the input tuple\n    for each element in input_tuple:\n        # Check if the element is a tuple\n        if element is a tuple:\n            # If it is, loop through each element in the nested tuple\n            for each nested_element in element:\n                # Add each element to the result list\n                add nested_element to \"result\"\n        else:\n            # If the element is not a tuple, add it to the result list\n            add element to \"result\"\n\n    # Convert the result list to a tuple and return it\n    return convert \"result\" to a tuple",
    "791": "function count_lists(input_lists):\n    # Initialize a counter to keep track of the number of lists\n    initialize a variable named \"list_count\" to 0\n\n    # Loop through each list in the input lists\n    for each list in input_lists:\n        # If the current item is a list, increment the list count\n        if the type of list is a list:\n            increment \"list_count\" by 1\n\n    # Return the final count of lists\n    return \"list_count\"",
    "792": "function find_last_position(sorted_array, target):\n    # Initialize two pointers, one at the start and one at the end of the array\n    set start_pointer to 0\n    set end_pointer to length of sorted_array - 1\n\n    # While the start pointer is less than or equal to the end pointer\n    while start_pointer <= end_pointer:\n        # Calculate the midpoint of the array\n        set midpoint to (start_pointer + end_pointer) / 2\n\n        # If the midpoint element is less than the target\n        if sorted_array[midpoint] < target:\n            # The target must be in the right half of the array, so move the start pointer to midpoint + 1\n            set start_pointer to midpoint + 1\n        else:\n            # The target could be in the left half of the array, so move the end pointer to midpoint - 1\n            set end_pointer to midpoint - 1\n\n    # If the target is not in the array, return -1\n    if sorted_array[start_pointer] != target:\n        return -1\n\n    # Return the start pointer, which is the last position of the target in the array\n    return start_pointer",
    "793": "function match_string(input_string):\n    # Check if the string starts with 'a'\n    if the first character of input_string is 'a':\n        # Check if the string ends with 'b'\n        if the last character of input_string is 'b':\n            # If it does, return True\n            return True\n        else:\n            # If it doesn't end with 'b', return False\n            return False\n    else:\n        # If it doesn't start with 'a', return False\n        return False",
    "794": "function find_n_cheapest_items(dataset, n):\n    # Create an empty heap queue\n    create an empty heap queue named \"heap\"\n\n    # Loop through each item in the dataset\n    for each item in dataset:\n        # Add the item to the heap queue\n        add item to \"heap\"\n\n        # If the heap queue is larger than n, remove the largest item\n        if size of \"heap\" is greater than n:\n            remove the largest item from \"heap\"\n\n    # Return the heap queue as the n cheapest items\n    return \"heap\"",
    "795": "function find_sum_of_dictionary_items(input_dictionary):\n    # Create a variable to keep track of the sum\n    create a variable named \"sum\" and set it to 0\n\n    # Loop through each item in the input dictionary\n    for each item in input_dictionary:\n        # Add the value of the item to the sum\n        add the value of the item to \"sum\"\n\n    # Return the sum\n    return \"sum\"",
    "796": "function sum_of_odd_numbers(l, r):\n    # Initialize the sum to 0\n    initialize sum to 0\n\n    # Loop through each number in the range from l to r\n    for each number in range from l to r:\n        # Check if the number is odd\n        if number is odd:\n            # If it is, add it to the sum\n            add number to sum\n\n    # Return the sum\n    return sum",
    "797": "function sum_array(array):\n    # Initialize a variable to keep track of the sum\n    create a variable named \"sum\" and set it to 0\n\n    # Loop through each element in the array\n    for each element in array:\n        # Add the current element to the sum\n        add element to \"sum\"\n\n    # Return the sum\n    return \"sum\"",
    "798": "function left_rotate_bits(number, rotation_count):\n    # Convert the number to binary and remove the '0b' prefix\n    binary_number = bin(number)[2:]\n\n    # Perform the rotation\n    rotated_binary = binary_number[rotation_count:] + binary_number[:rotation_count]\n\n    # Convert the rotated binary back to a decimal number\n    rotated_number = int(rotated_binary, 2)\n\n    # Return the rotated number\n    return rotated_number",
    "799": "function remove_whitespaces(input_string):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If the character is not a whitespace, add it to the result string\n        if character is not a whitespace:\n            add character to \"result\"\n\n    # Return the result string\n    return \"result\"",
    "800": "function count_equal_numbers(num1, num2, num3):\n    # Initialize a counter to keep track of the number of equal numbers\n    set a counter to 0\n\n    # Check if num1 is equal to num2\n    if num1 is equal to num2:\n        # If it is, increment the counter\n        increment the counter by 1\n\n    # Check if num1 is equal to num3\n    if num1 is equal to num3:\n        # If it is, increment the counter\n        increment the counter by 1\n\n    # Check if num2 is equal to num3\n    if num2 is equal to num3:\n        # If it is, increment the counter\n        increment the counter by 1\n\n    # Return the counter\n    return the counter",
    "801": "function count_rotations(input_array):\n    # Initialize the start and end indices\n    start_index = 0\n    end_index = len(input_array) - 1\n\n    # While the start index is less than the end index\n    while start_index < end_index:\n        # Calculate the mid index\n        mid_index = start_index + (end_index - start_index) // 2\n\n        # If the mid element is greater than the last element, the pivot is in the right half\n        if input_array[mid_index] > input_array[end_index]:\n            start_index = mid_index + 1\n        # If the mid element is less than or equal to the last element, the pivot is in the left half\n        else:\n            end_index = mid_index\n\n    # Return the start index, which is the number of rotations\n    return start_index",
    "802": "function is_perfect_square(number):\n    # Check if the number is less than 0\n    if number is less than 0:\n        # If it is, return False because negative numbers cannot be perfect squares\n        return False\n\n    # Calculate the square root of the number\n    square_root = the square root of number\n\n    # Check if the square root is an integer\n    if square_root is an integer:\n        # If it is, return True because the number is a perfect square\n        return True\n    else:\n        # If it's not, return False because the number is not a perfect square\n        return False",
    "803": "function check_product_even_odd(numbers):\n    # Initialize a variable to keep track of the product\n    set product to 1\n\n    # Loop through each number in the list\n    for each number in numbers:\n        # Multiply the current product by the current number\n        multiply product by number\n\n    # Check if the product is even or odd\n    if product modulo 2 equals 0:\n        # If it's even, return True\n        return True\n    else:\n        # If it's odd, return False\n        return False",
    "804": "function find_max_sum_list(list_of_lists):\n    # Initialize max_sum and max_list variables\n    max_sum = 0\n    max_list = []\n\n    # Loop through each list in the list_of_lists\n    for each list in list_of_lists:\n        # Calculate the sum of the current list\n        sum_of_list = sum of elements in list\n\n        # Check if this sum is greater than max_sum\n        if sum_of_list > max_sum:\n            # If it is, update max_sum and max_list\n            max_sum = sum_of_list\n            max_list = list\n\n    # Return the list with the highest sum\n    return max_list",
    "805": "function find_max_uppercase_run(input_string):\n    # Initialize variables to keep track of the current run and the maximum run\n    set current_run to 0\n    set max_run to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If the character is uppercase\n        if character is uppercase:\n            # Increment the current run\n            increment current_run by 1\n\n            # If the current run is greater than the max run, update the max run\n            if current_run is greater than max_run:\n                set max_run to current_run\n        else:\n            # If the character is not uppercase, reset the current run\n            set current_run to 0\n\n    # Return the maximum run\n    return max_run",
    "806": "function find_first_odd_number(list_of_numbers):\n    # Loop through each number in the list\n    for each number in list_of_numbers:\n        # Check if the number is odd\n        if number modulo 2 equals 1:\n            # If it is, return the number\n            return number\n\n    # If we've checked all numbers and found no odds, return a signal (like None or a message)\n    return None",
    "807": "function check_tuples_contain_k(tuples, k):\n    # Loop through each tuple in the list of tuples\n    for each tuple in tuples:\n        # Check if the tuple contains the number k\n        if k is in tuple:\n            # If it does, return True\n            return True\n\n    # If we've checked all tuples and found no occurrences of k, return False\n    return False",
    "808": "function check_tuples(tuple1, tuple2):\n    # Check if the tuples are of equal length\n    if length of tuple1 is not equal to length of tuple2:\n        return False\n\n    # Loop through each index in the tuples\n    for each index in range from 0 to length of tuple1:\n        # Check if the element at this index in tuple2 is smaller than the element at this index in tuple1\n        if tuple2[index] is greater than tuple1[index]:\n            # If it is, return False\n            return False\n\n    # If we've checked all elements and found no inequalities, return True\n    return True",
    "809": "function repeat_elements(input_list):\n    # Create an empty list to store the repeated elements\n    create an empty list named \"repeated_elements\"\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # Get the count of the current element in the input list\n        get the count of element in input_list\n\n        # Repeat the element as many times as its count\n        repeat element count times\n\n        # Add the repeated elements to the \"repeated_elements\" list\n        add the repeated elements to \"repeated_elements\"\n\n    # Return the \"repeated_elements\" list\n    return \"repeated_elements\"",
    "810": "function are_lists_identical(list1, list2):\n    # Check if the lengths of the lists are equal\n    if the length of list1 is not equal to the length of list2:\n        # If not, the lists are not identical, so return False\n        return False\n\n    # Loop through each tuple in list1\n    for each tuple in list1:\n        # Check if the tuple is in list2\n        if the tuple is not in list2:\n            # If not, the lists are not identical, so return False\n            return False\n\n    # If we've checked all tuples and found no differences, the lists are identical, so return True\n    return True",
    "811": "function abbreviate_road(input_string):\n    # Create a list of words in the input string\n    create a list named \"words\" and split input_string into words\n\n    # Loop through each word in the list\n    for each word in words:\n        # Check if the word is 'road'\n        if word is 'road':\n            # If it is, replace it with 'rd.'\n            replace word with 'rd.'\n\n    # Join the words back together into a string and return it\n    return join words into a string",
    "812": "function find_length_of_string(input_string):\n    # Initialize a counter to keep track of the length of the string\n    initialize a counter named \"length\" to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Increment the length counter\n        increment \"length\" by 1\n\n    # Return the final length of the string\n    return \"length\"",
    "813": "function find_rombus_area(d1, d2):\n    # Calculate the area of the rombus\n    area = (d1 * d2) / 2\n\n    # Return the calculated area\n    return area",
    "814": "function sort_array(input_array):\n    # Initialize counters for 0, 1, and 2\n    count_0 = 0\n    count_1 = 0\n    count_2 = 0\n\n    # Count the occurrences of each number in the array\n    for each number in input_array:\n        if number is 0:\n            increment count_0\n        elif number is 1:\n            increment count_1\n        elif number is 2:\n            increment count_2\n\n    # Create a new array and add 0s, 1s, and 2s to it in order\n    create an empty array named \"sorted_array\"\n    while count_0 is greater than 0:\n        add 0 to \"sorted_array\"\n        decrement count_0\n    while count_1 is greater than 0:\n        add 1 to \"sorted_array\"\n        decrement count_1\n    while count_2 is greater than 0:\n        add 2 to \"sorted_array\"\n        decrement count_2\n\n    # Return the sorted array\n    return sorted_array",
    "815": "function clear_tuple_values(tuple_of_values):\n    # Create an empty list to store the cleared values\n    create an empty list named \"cleared_values\"\n\n    # Loop through each value in the tuple\n    for each value in tuple_of_values:\n        # Clear the value (for example, if it's a number, set it to 0)\n        set value to 0\n\n        # Add the cleared value to the list\n        add cleared value to \"cleared_values\"\n\n    # Convert the list to a tuple and return it\n    return convert \"cleared_values\" to a tuple",
    "816": "function find_numbers_divisible_by_m_or_n(list_of_numbers, m, n):\n    # Create an empty list to store the numbers that are divisible by m or n\n    create an empty list named \"divisible_numbers\"\n\n    # Use a lambda function to filter the list of numbers\n    filter the list_of_numbers using a lambda function that checks if a number is divisible by m or n\n        if the number modulo m equals 0 or the number modulo n equals 0:\n            return True\n        else:\n            return False\n\n    # Add the filtered numbers to the divisible_numbers list\n    add the filtered numbers to divisible_numbers\n\n    # Return the divisible_numbers list\n    return divisible_numbers",
    "817": "function count_lower_case_letters(input_string):\n    # Initialize a counter to keep track of the number of lower case letters\n    initialize a counter named \"lower_case_count\" to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is a lower case letter\n        if character is a lower case letter:\n            # If it is, increment the counter\n            increment \"lower_case_count\" by 1\n\n    # After checking all characters, return the count\n    return \"lower_case_count\"",
    "818": "function count_consecutive_duplicates(input_list):\n    # Create a variable to keep track of the current consecutive count\n    create a variable named \"consecutive_count\" and set it to 1\n\n    # Create a variable to keep track of the current character\n    create a variable named \"current_character\" and set it to the first character in the input_list\n\n    # Create a variable to keep track of the maximum consecutive count\n    create a variable named \"max_consecutive_count\" and set it to 1\n\n    # Loop through each character in the input list\n    for each character in input_list:\n        # Check if the current character is the same as the previous one\n        if character is the same as \"current_character\":\n            # If it is, increment the consecutive count\n            increment \"consecutive_count\" by 1\n        else:\n            # If it's not, reset the consecutive count to 1 and update the current character\n            set \"consecutive_count\" to 1\n            set \"current_character\" to character\n\n        # Check if the current consecutive count is greater than the maximum consecutive count\n        if \"consecutive_count\" is greater than \"max_consecutive_count\":\n            # If it is, update the maximum consecutive count\n            set \"max_consecutive_count\" to \"consecutive_count\"\n\n    # Return the maximum consecutive count\n    return \"max_consecutive_count\"",
    "819": "function is_month_has_28_days(month_number):\n    # Create a list of months that have 28 days\n    create a list named \"months_with_28_days\" with values 2, 4, 6, 9, 11\n\n    # Check if the given month number is in the list of months with 28 days\n    if month_number is in \"months_with_28_days\":\n        # If it is, return True\n        return True\n    else:\n        # If it's not, return False\n        return False",
    "820": "function merge_dictionaries(dict1, dict2):\n    # Create a new dictionary to store the merged result\n    create an empty dictionary named \"merged_dict\"\n\n    # Loop through each key-value pair in the first dictionary\n    for each key, value in dict1:\n        # Add this key-value pair to the merged dictionary\n        add key-value pair to \"merged_dict\"\n\n    # Loop through each key-value pair in the second dictionary\n    for each key, value in dict2:\n        # If the key already exists in the merged dictionary,\n        # update the value to be the sum of the old value and the new value\n        if key is already in \"merged_dict\":\n            update the value of key in \"merged_dict\" to be the sum of the old value and the new value\n        else:\n            # If the key doesn't exist in the merged dictionary,\n            # add the key-value pair to the merged dictionary\n            add key-value pair to \"merged_dict\"\n\n    # Return the merged dictionary\n    return \"merged_dict\"",
    "821": "function is_password_valid(password):\n    # Check if the password is at least 8 characters long\n    if the length of password is less than 8:\n        return false\n\n    # Check if the password contains at least one uppercase letter\n    if there is no uppercase letter in password:\n        return false\n\n    # Check if the password contains at least one lowercase letter\n    if there is no lowercase letter in password:\n        return false\n\n    # Check if the password contains at least one digit\n    if there is no digit in password:\n        return false\n\n    # Check if the password contains at least one special character\n    if there is no special character in password:\n        return false\n\n    # If all checks pass, the password is valid\n    return true",
    "822": "function check_starts_with_substring(input_string, substring):\n    # Import the regex module\n    import regex\n\n    # Create a regex pattern that matches the start of the string\n    pattern = \"^\" + regex.escape(substring)\n\n    # Check if the input string matches the pattern\n    if regex.match(pattern, input_string):\n        # If it does, return True\n        return True\n    else:\n        # If it doesn't, return False\n        return False",
    "823": "function remove_even_numbers(input_list):\n    # Create an empty list to keep track of the numbers we've kept\n    create an empty list named \"kept_numbers\"\n\n    # Loop through each number in the input list\n    for each number in input_list:\n        # Check if the number is odd\n        if number modulo 2 is not equal to 0:\n            # If it's odd, add it to our list of kept numbers\n            add number to \"kept_numbers\"\n\n    # Return the list of kept numbers\n    return \"kept_numbers\"",
    "824": "function access_elements_at_index(input_list, index_list):\n    # Create an empty list to store the elements we're going to return\n    create an empty list named \"elements_at_index\"\n\n    # Loop through each index in the index list\n    for each index in index_list:\n        # Check if the index is valid for the input list\n        if index is a valid index for input_list:\n            # If it is, add the element at that index to our list\n            add element at index in input_list to \"elements_at_index\"\n\n    # Return the list of elements we found\n    return \"elements_at_index\"",
    "825": "function find_triangle_type(side1, side2, side3):\n    # Check if the sides can form a triangle\n    if side1 + side2 <= side3 or side1 + side3 <= side2 or side2 + side3 <= side1:\n        return \"Not a triangle\"\n\n    # Check if the sides form an equilateral triangle\n    if side1 == side2 == side3:\n        return \"Equilateral triangle\"\n\n    # Check if the sides form an isosceles triangle\n    if side1 == side2 or side1 == side3 or side2 == side3:\n        return \"Isosceles triangle\"\n\n    # If the sides don't form either of the above types, it must be a scalene triangle\n    return \"Scalene triangle\"",
    "826": "function sum_column(list_of_lists, column_number):\n    # Initialize the sum to 0\n    initialize sum to 0\n\n    # Loop through each list in the list of lists\n    for each list in list_of_lists:\n        # Check if the column number is valid\n        if column_number is less than 0 or greater than the length of the list:\n            # If not, print an error message and stop the function\n            print \"Error: Invalid column number\"\n            return None\n\n        # Add the value in the specified column to the sum\n        add the value at index column_number in the list to sum\n\n    # Return the sum\n    return sum",
    "827": "function count_characters(input_string):\n    # Initialize counters for alphabets, digits, and special characters\n    set a counter named \"alphabet_count\" to 0\n    set a counter named \"digit_count\" to 0\n    set a counter named \"special_character_count\" to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is an alphabet\n        if character is an alphabet:\n            increment \"alphabet_count\" by 1\n        # Check if the character is a digit\n        else if character is a digit:\n            increment \"digit_count\" by 1\n        # If it's neither an alphabet nor a digit, it must be a special character\n        else:\n            increment \"special_character_count\" by 1\n\n    # Return the counts\n    return \"alphabet_count\", \"digit_count\", \"special_character_count\"",
    "828": "function find_second_most_repeated_string(input_sequence):\n    # Create an empty dictionary to keep track of string counts\n    create an empty dictionary named \"string_counts\"\n\n    # Loop through each string in the input sequence\n    for each string in input_sequence:\n        # If the string is already in our dictionary, increment its count\n        if string is already in \"string_counts\":\n            increment the count for string in \"string_counts\"\n        else:\n            # If it's a new string, add it to our dictionary with a count of 1\n            add string to \"string_counts\" with a count of 1\n\n    # Create an empty list to keep track of the two most frequent strings\n    create an empty list named \"most_frequent_strings\"\n\n    # Loop through each string in the dictionary\n    for each string in \"string_counts\":\n        # If the string's count is greater than the count of the first most frequent string\n        if the count for string in \"string_counts\" is greater than the count for the first string in \"most_frequent_strings\":\n            # If it is, replace the first most frequent string with this string\n            replace the first string in \"most_frequent_strings\" with string\n        else:\n            # If it's not, check if the string's count is greater than the count of the second most frequent string\n            if the count for string in \"string_counts\" is greater than the count for the second string in \"most_frequent_strings\":\n                # If it is, replace the second most frequent string with this string\n                replace the second string in \"most_frequent_strings\" with string\n\n    # If we've checked all strings and found no repeats, return a signal (like None or a message)\n    if \"most_frequent_strings\" is empty:\n        return None\n    else:\n        # If we found at least one repeated string, return the second most repeated string\n        return the second string in \"most_frequent_strings\"",
    "829": "function round_up_to_digits(number, digits):\n    # Convert the number to a string\n    convert number to a string and store it in a variable named \"number_string\"\n\n    # Find the index of the decimal point in the string\n    find the index of the decimal point in \"number_string\" and store it in a variable named \"decimal_index\"\n\n    # If the number doesn't have a decimal point, add one\n    if \"decimal_index\" is -1:\n        append a decimal point and the number of zeros equal to \"digits\" to \"number_string\"\n    else:\n        # If the number has a decimal point, round up to the specified number of digits\n        if the number of characters after the decimal point is less than \"digits\":\n            append the number of zeros equal to \"digits\" minus the number of characters after the decimal point to \"number_string\"\n\n    # Convert the string back to a number\n    convert \"number_string\" back to a number and store it in a variable named \"rounded_number\"\n\n    # Return the rounded number\n    return \"rounded_number\"",
    "830": "function count_equal_element_pairs(input_array):\n    # Create a variable to keep track of the number of pairs\n    create a variable named \"pair_count\" and set it to 0\n\n    # Loop through each element in the input array\n    for each element in input_array:\n        # Loop through each other element in the input array\n        for each other_element in input_array:\n            # Check if the current element is equal to the other element\n            if element is equal to other_element:\n                # If they are equal, increment the pair count\n                increment \"pair_count\" by 1\n\n    # Return the pair count\n    return pair_count",
    "831": "function extract_max_numeric_value(input_string):\n    # Import the regular expression module\n    import regex\n\n    # Use a regular expression to find all numeric values in the string\n    find all numeric values in input_string using regex\n\n    # If no numeric values were found, return None\n    if no numeric values were found:\n        return None\n\n    # Convert the numeric values to integers\n    convert the numeric values to integers\n\n    # Find the maximum numeric value\n    find the maximum numeric value in the list of integers\n\n    # Return the maximum numeric value\n    return the maximum numeric value",
    "832": "function get_dictionary_keys(input_dictionary):\n    # Create an empty list to store the keys\n    create an empty list named \"keys\"\n\n    # Loop through each key in the input dictionary\n    for each key in input_dictionary:\n        # Add the key to the list\n        add key to \"keys\"\n\n    # Return the list of keys\n    return \"keys\"",
    "833": "function generate_spiral_matrix(n):\n    # Create an empty matrix of size n x n\n    create a 2D array named \"matrix\" of size n x n filled with zeros\n\n    # Initialize the starting row, column, and direction\n    set row to 0\n    set column to 0\n    set direction to \"right\"\n\n    # Loop from 1 to n^2\n    for i from 1 to n^2:\n        # Fill the current cell with the current number\n        set matrix[row][column] to i\n\n        # Move to the next cell in the spiral order\n        if direction is \"right\":\n            if column + 1 < n and matrix[row][column + 1] == 0:\n                set column to column + 1\n            else:\n                set direction to \"down\"\n                set row to row + 1\n        elif direction is \"down\":\n            if row + 1 < n and matrix[row + 1][column] == 0:\n                set row to row + 1\n            else:\n                set direction to \"left\"\n                set column to column - 1\n        elif direction is \"left\":\n            if column - 1 >= 0 and matrix[row][column - 1] == 0:\n                set column to column - 1\n            else:\n                set direction to \"up\"\n                set row to row - 1\n        elif direction is \"up\":\n            if row - 1 >= 0 and matrix[row - 1][column] == 0:\n                set row to row - 1\n            else:\n                set direction to \"right\"\n                set column to column + 1\n\n    # Return the filled matrix\n    return matrix",
    "834": "function find_slope(x1, y1, x2, y2):\n    # Calculate the difference in x and y values\n    dx = x2 - x1\n    dy = y2 - y1\n\n    # Check if the line is vertical\n    if dx is equal to 0:\n        # If so, the slope is undefined, so return a special value\n        return \"undefined\"\n    else:\n        # Calculate the slope\n        slope = dy / dx\n\n        # Return the slope\n        return slope",
    "835": "function find_max_sum_subarray(input_array):\n    # Initialize variables to keep track of the maximum sum and the current sum\n    initialize variable \"max_sum\" to 0\n    initialize variable \"current_sum\" to 0\n\n    # Loop through each element in the input array\n    for each element in input_array:\n        # Add the current element to the current sum\n        add element to \"current_sum\"\n\n        # If the current sum is greater than the maximum sum, update the maximum sum\n        if \"current_sum\" is greater than \"max_sum\":\n            update \"max_sum\" to \"current_sum\"\n\n        # If the current sum becomes negative, reset it to 0\n        if \"current_sum\" is less than 0:\n            reset \"current_sum\" to 0\n\n    # Return the maximum sum\n    return \"max_sum\"",
    "836": "function cube_sum_of_first_n_odd_numbers(n):\n    # Initialize sum to 0\n    initialize sum to 0\n\n    # Initialize count to 0\n    initialize count to 0\n\n    # Initialize number to 1\n    initialize number to 1\n\n    # Loop until count is equal to n\n    while count is not equal to n:\n        # Add the cube of the number to the sum\n        add the cube of number to sum\n\n        # Increment the count by 1\n        increment count by 1\n\n        # Increment the number by 2 to get the next odd number\n        increment number by 2\n\n    # Return the sum\n    return sum",
    "837": "function min_swaps_to_make_equal(string1, string2):\n    # Check if the lengths of the strings are equal\n    if length of string1 is not equal to length of string2:\n        return -1\n\n    # Count the number of 1s in both strings\n    count1 = count_ones(string1)\n    count2 = count_ones(string2)\n\n    # If the counts are not equal, it's impossible to make them equal\n    if count1 is not equal to count2:\n        return -1\n\n    # Count the number of positions where string1 and string2 differ\n    diff = count_diff(string1, string2)\n\n    # The minimum number of swaps is half the number of differing positions\n    return diff / 2\n\nfunction count_ones(string):\n    # Initialize a counter\n    count = 0\n\n    # Loop through each character in the string\n    for each character in string:\n        # If the character is a 1, increment the counter\n        if character is equal to '1':\n            count = count + 1\n\n    # Return the counter\n    return count\n\nfunction count_diff(string1, string2):\n    # Initialize a counter\n    count = 0\n\n    # Loop through each character in the strings\n    for i from 0 to length of string1 - 1:\n        # If the characters at this position are different, increment the counter\n        if string1[i] is not equal to string2[i]:\n            count = count + 1\n\n    # Return the counter\n    return count",
    "838": "function sort_tuples_alphabetically(tuple_list):\n    # Create a new list to store the sorted tuples\n    create an empty list named \"sorted_tuples\"\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # If the sorted_tuples list is empty, add the tuple\n        if \"sorted_tuples\" is empty:\n            add tuple to \"sorted_tuples\"\n        else:\n            # Loop through each tuple in the sorted_tuples list\n            for each tuple in \"sorted_tuples\":\n                # If the first item of the tuple is less than the first item of the current tuple\n                if the first item of tuple is less than the first item of the current tuple:\n                    # Insert the current tuple before the tuple in the sorted_tuples list\n                    insert the current tuple before the tuple in \"sorted_tuples\"\n                    break\n                # If the first item of the tuple is greater than the first item of the current tuple\n                else if the first item of tuple is greater than the first item of the current tuple:\n                    # Insert the current tuple after the tuple in the sorted_tuples list\n                    insert the current tuple after the tuple in \"sorted_tuples\"\n                    break\n                # If the first item of the tuple is equal to the first item of the current tuple\n                else:\n                    # If the second item of the tuple is less than the second item of the current tuple\n                    if the second item of tuple is less than the second item of the current tuple:\n                        # Insert the current tuple before the tuple in the sorted_tuples list\n                        insert the current tuple before the tuple in \"sorted_tuples\"\n                        break\n                    # If the second item of the tuple is greater than the second item of the current tuple\n                    else if the second item of tuple is greater than the second item of the current tuple:\n                        # Insert the current tuple after the tuple in the sorted_tuples list\n                        insert the current tuple after the tuple in \"sorted_tuples\"\n                        break\n\n    # Return the sorted_tuples list\n    return \"sorted_tuples\"",
    "839": "function check_opposite_roots(a, b, c):\n    # Calculate the discriminant\n    calculate the discriminant using the quadratic formula (b^2 - 4ac)\n\n    # If the discriminant is less than zero, the roots are not numerically equal but opposite in sign\n    if discriminant is less than zero:\n        return True\n    else:\n        return False",
    "840": "function count_inversions(input_array):\n    # Initialize a variable to keep track of the number of inversions\n    initialize a variable named \"inversion_count\" to 0\n\n    # Loop through each element in the input array\n    for each element in input_array:\n        # Loop through each subsequent element in the input array\n        for each subsequent element in input_array:\n            # Check if the current element is greater than the subsequent element\n            if element > subsequent element:\n                # If it is, this is an inversion, so increment the inversion count\n                increment \"inversion_count\" by 1\n\n    # Return the total number of inversions\n    return \"inversion_count\"",
    "841": "function find_odd_occurrence_number(input_array):\n    # Create an empty dictionary to keep track of numbers and their occurrences\n    create an empty dictionary named \"number_occurrences\"\n\n    # Loop through each number in the input array\n    for each number in input_array:\n        # Check if we've come across this number before\n        if number is already in \"number_occurrences\":\n            # If we have, increment the count for this number\n            increment the count for number in \"number_occurrences\"\n        else:\n            # If it's a new number, add it to our dictionary with a count of 1\n            add number to \"number_occurrences\" with a count of 1\n\n    # Loop through each number and its count in the dictionary\n    for each number and count in \"number_occurrences\":\n        # Check if the count is odd\n        if count is odd:\n            # If it is, this is the number we're looking for, so return it\n            return number\n\n    # If we've checked all numbers and found no numbers with odd counts, return a signal (like None or a message)\n    return None",
    "842": "function find_nth_super_ugly_number(n, primes):\n    # Create a list to store the super ugly numbers\n    create a list named \"super_ugly_numbers\" and initialize it with 1\n\n    # Create a list to store the indices of the primes\n    create a list named \"indices\" and initialize it with 0 for each prime\n\n    # Create a list to store the values of the primes\n    create a list named \"values\" and initialize it with the primes\n\n    # Create a heap queue to store the values\n    create a heap queue named \"heap\" and initialize it with the values\n\n    # Loop until we've found n super ugly numbers\n    while the size of \"super_ugly_numbers\" is less than n:\n        # Pop the smallest value from the heap\n        pop the smallest value from \"heap\" and store it in \"smallest\"\n\n        # If the smallest value is not already in \"super_ugly_numbers\", add it\n        if \"smallest\" is not already in \"super_ugly_numbers\":\n            add \"smallest\" to \"super_ugly_numbers\"\n\n        # Update the values in the heap\n        for each index in the range of the size of \"primes\":\n            update the value at \"indices[index]\" in \"values\" with the value at \"indices[index]\" in \"values\" times the prime at \"index\"\n            push the value at \"indices[index]\" in \"values\" to \"heap\"\n\n    # Return the nth super ugly number\n    return the last element in \"super_ugly_numbers\"",
    "843": "function find_kth_element(array, k):\n    # Create a variable to keep track of the current index\n    create a variable named \"current_index\" and set it to 0\n\n    # Create a variable to keep track of the current element\n    create a variable named \"current_element\" and set it to None\n\n    # Loop through each element in the array\n    for each element in array:\n        # If the current index is equal to k, we've found the kth element\n        if current_index is equal to k:\n            # Set the current element to the found element\n            set current_element to element\n            # Break out of the loop\n            break\n\n        # Increment the current index\n        increment current_index by 1\n\n    # Return the current element\n    return current_element",
    "844": "function count_digits_in_factorial(n):\n    # Initialize a variable to store the factorial\n    let factorial = 1\n\n    # Calculate the factorial\n    for i from 1 to n:\n        factorial = factorial * i\n\n    # Initialize a variable to store the count of digits\n    let count = 0\n\n    # Count the number of digits in the factorial\n    while factorial > 0:\n        factorial = factorial // 10\n        count = count + 1\n\n    # Return the count of digits\n    return count",
    "845": "function find_minimum_platforms(arrival_times, departure_times):\n    # Sort the arrival and departure times\n    sort arrival_times in ascending order\n    sort departure_times in ascending order\n\n    # Initialize the number of platforms needed and the current platform count\n    set platforms_needed to 1\n    set current_platforms to 1\n\n    # Initialize the indices for arrival and departure times\n    set arrival_index to 1\n    set departure_index to 1\n\n    # Loop through the arrival and departure times\n    while arrival_index < length of arrival_times and departure_index < length of departure_times:\n        # If the next train arrives before the current train departs\n        if arrival_times[arrival_index] < departure_times[departure_index]:\n            # Increase the platform count and move to the next arrival time\n            increase current_platforms by 1\n            increase arrival_index by 1\n\n            # If the current platform count is greater than the platforms needed, update the platforms needed\n            if current_platforms > platforms_needed:\n                set platforms_needed to current_platforms\n        else:\n            # Decrease the platform count and move to the next departure time\n            decrease current_platforms by 1\n            increase departure_index by 1\n\n    # Return the minimum number of platforms needed\n    return platforms_needed",
    "846": "function copy_list_from_tuple(tuple):\n    # Check if the tuple has exactly one element\n    if the length of tuple is not equal to 1:\n        # If not, raise an error\n        raise an error \"The tuple must contain exactly one list\"\n\n    # Get the first element of the tuple\n    first_element = get the first element of tuple\n\n    # Check if the first element is a list\n    if the type of first_element is not a list:\n        # If not, raise an error\n        raise an error \"The first element of the tuple must be a list\"\n\n    # Return a copy of the list\n    return a copy of first_element",
    "847": "function find_trapezium_area(base1, base2, height):\n    # Calculate the area of the trapezium\n    area = 0.5 * (base1 + base2) * height\n\n    # Return the calculated area\n    return area",
    "848": "function find_sum_of_prime_divisors(number):\n    # Create a variable to keep track of the sum of prime divisors\n    create a variable named \"sum_of_prime_divisors\" and set it to 0\n\n    # Loop through each number from 2 to the given number\n    for each number from 2 to the given number:\n        # Check if the given number is divisible by the current number\n        if the given number is divisible by the current number:\n            # Check if the current number is a prime number\n            if the current number is a prime number:\n                # If it is, add it to the sum of prime divisors\n                add the current number to \"sum_of_prime_divisors\"\n\n    # Return the sum of prime divisors\n    return \"sum_of_prime_divisors\"\n\nfunction is_prime(number):\n    # Check if the number is less than 2\n    if the number is less than 2:\n        # If it is, it's not a prime number, so return False\n        return False\n\n    # Loop through each number from 2 to the square root of the given number\n    for each number from 2 to the square root of the given number:\n        # Check if the given number is divisible by the current number\n        if the given number is divisible by the current number:\n            # If it is, the number is not a prime number, so return False\n            return False\n\n    # If we've checked all numbers and found no divisors, the number is a prime number, so return True\n    return True",
    "849": "function is_triangle_possible(angle1, angle2, angle3):\n    # Check if the sum of the angles is 180 degrees\n    if angle1 + angle2 + angle3 is not equal to 180:\n        # If not, return False\n        return False\n\n    # Check if any of the angles is 0\n    if angle1 is equal to 0 or angle2 is equal to 0 or angle3 is equal to 0:\n        # If yes, return False\n        return False\n\n    # If the sum of the angles is 180 and none of the angles is 0, return True\n    return True",
    "850": "function sum_of_inverse_of_divisors(n):\n    # Initialize sum to 0\n    sum = 0\n\n    # Loop from 1 to n\n    for i from 1 to n:\n        # If n is divisible by i\n        if n is divisible by i:\n            # Add the inverse of i to the sum\n            sum = sum + inverse of i\n\n    # Return the sum\n    return sum",
    "851": "function remove_negative_numbers(input_list):\n    # Create an empty list to keep track of non-negative numbers\n    create an empty list named \"non_negative_numbers\"\n\n    # Loop through each number in the input list\n    for each number in input_list:\n        # Check if the number is non-negative\n        if number is not less than 0:\n            # If it's non-negative, add it to our list of non-negative numbers\n            add number to \"non_negative_numbers\"\n\n    # Return the list of non-negative numbers\n    return \"non_negative_numbers\"",
    "852": "function find_sum_of_odd_factors(number):\n    # Initialize sum to 0\n    set sum to 0\n\n    # Loop from 1 to the number\n    for each number from 1 to number:\n        # Check if the number is a factor of the given number\n        if number is a factor of given number:\n            # Check if the factor is odd\n            if factor is odd:\n                # Add the factor to the sum\n                add factor to sum\n\n    # Return the sum\n    return sum",
    "853": "function heapify(list, n, i):\n    # Initialize largest as root\n    largest = i\n    left = 2 * i + 1\n    right = 2 * i + 2\n\n    # If left child is larger than root\n    if left < n and list[i] < list[left]:\n        largest = left\n\n    # If right child is larger than largest so far\n    if right < n and list[largest] < list[right]:\n        largest = right\n\n    # If largest is not root\n    if largest != i:\n        # Swap\n        swap list[i] with list[largest]\n\n        # Heapify the root.\n        heapify(list, n, largest)\n\nfunction convert_to_heap(list):\n    # Get the length of the list\n    n = len(list)\n\n    # Build a maxheap.\n    for i in range(n, -1, -1):\n        heapify(list, n, i)\n\n    # One by one extract elements\n    for i in range(n-1, 0, -1):\n        # Swap\n        swap list[i] with list[0]\n\n        # Heapify root element\n        heapify(list, i, 0)\n\n    return list",
    "854": "function check_even_parity(number):\n    # Convert the number to binary\n    convert number to binary\n\n    # Count the number of 1s in the binary representation\n    count the number of 1s in the binary representation\n\n    # Check if the count is even\n    if the count is even:\n        # If it is, return True (the number has even parity)\n        return True\n    else:\n        # If it's not, return False (the number has odd parity)\n        return False",
    "855": "function find_minimum_swaps(binary_array):\n    # Create an empty list to store the indices of the 1's\n    create an empty list named \"one_indices\"\n\n    # Loop through each element in the binary array\n    for each index in range of length of binary_array:\n        # If the element is a 1, add its index to the list\n        if binary_array[index] is 1:\n            add index to \"one_indices\"\n\n    # Initialize a variable to keep track of the number of swaps\n    initialize a variable named \"swaps\" to 0\n\n    # Loop through each index in the list of 1's\n    for each index in \"one_indices\":\n        # If the index is not where it should be, swap it with the correct index\n        if index is not equal to \"one_indices[index]\":\n            swap binary_array[index] with binary_array[\"one_indices[index]\"]\n            increment \"swaps\" by 1\n\n    # Return the number of swaps\n    return \"swaps\"",
    "856": "function list_strings_individually(list_of_strings):\n    # Create an empty list to store the individual strings\n    create an empty list named \"individual_strings\"\n\n    # Loop through each string in the list of strings\n    for each string in list_of_strings:\n        # Add the string to the list of individual strings\n        add string to \"individual_strings\"\n\n    # Return the list of individual strings\n    return \"individual_strings\"",
    "857": "function count_and_square_lists(input_list):\n    # Initialize a counter to keep track of the number of lists\n    initialize a variable named \"list_count\" to 0\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # Check if the element is a list\n        if element is a list:\n            # If it is, increment the list count\n            increment \"list_count\" by 1\n\n    # Square the list count\n    square \"list_count\"\n\n    # Return the squared list count\n    return \"list_count\"",
    "858": "function generate_sublists(input_list):\n    # Create an empty list to store all sublists\n    create an empty list named \"sublists\"\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # Loop through each sublist in the current list of sublists\n        for each sublist in \"sublists\":\n            # Add the current element to each sublist\n            add element to sublist\n\n        # Add the current element to its own sublist\n        add element to \"sublists\"\n\n    # Return the list of all sublists\n    return \"sublists\"",
    "859": "function check_string_ending_with_alphanumeric(input_string):\n    # Import the regular expression module\n    import regex\n\n    # Define the regular expression pattern for alphanumeric characters\n    pattern = r'^[a-zA-Z0-9]*$'\n\n    # Check if the input string matches the pattern\n    if regex.match(pattern, input_string):\n        # If it does, return True\n        return True\n    else:\n        # If it doesn't, return False\n        return False",
    "860": "function find_anagrams(input_string, list_of_strings):\n    # Sort the input string and store it\n    sorted_input_string = sort the characters in input_string\n\n    # Create an empty list to store the anagrams\n    create an empty list named \"anagrams\"\n\n    # Loop through each string in the list of strings\n    for each string in list_of_strings:\n        # Sort the current string and store it\n        sorted_string = sort the characters in string\n\n        # Check if the sorted versions of the strings are the same\n        if sorted_input_string is the same as sorted_string:\n            # If they are, add the original string to the list of anagrams\n            add string to \"anagrams\"\n\n    # Return the list of anagrams\n    return \"anagrams\"",
    "861": "function find_most_common_words(input_text, n):\n    # Split the input text into words\n    split input_text into words\n\n    # Create a dictionary to keep track of word counts\n    create an empty dictionary named \"word_counts\"\n\n    # Loop through each word in the list of words\n    for each word in words:\n        # If the word is already in the dictionary, increment its count\n        if word is already in \"word_counts\":\n            increment the count for word in \"word_counts\"\n        else:\n            # If the word is not in the dictionary, add it with a count of 1\n            add word to \"word_counts\" with a count of 1\n\n    # Sort the dictionary by count in descending order\n    sort \"word_counts\" by count in descending order\n\n    # Return the first n items from the sorted dictionary\n    return the first n items from \"word_counts\"",
    "862": "function find_longest_consecutive_subsequence(input_list):\n    # Create a variable to keep track of the longest subsequence\n    create a variable named \"longest_subsequence\" and set it to 0\n\n    # Create a variable to keep track of the current subsequence\n    create a variable named \"current_subsequence\" and set it to 0\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # If the next element is the current element plus one, increment the current subsequence\n        if the next element is equal to the current element plus one:\n            increment \"current_subsequence\" by 1\n        else:\n            # If the next element is not the current element plus one, update the longest subsequence if necessary\n            if \"current_subsequence\" is greater than \"longest_subsequence\":\n                set \"longest_subsequence\" to \"current_subsequence\"\n            # Reset the current subsequence\n            set \"current_subsequence\" to 1\n\n    # After the loop, update the longest subsequence if necessary\n    if \"current_subsequence\" is greater than \"longest_subsequence\":\n        set \"longest_subsequence\" to \"current_subsequence\"\n\n    # Return the length of the longest subsequence\n    return \"longest_subsequence\"",
    "863": "function find_palindromes(list_of_strings):\n    # Create an empty list to store the palindromes\n    create an empty list named \"palindromes\"\n\n    # Loop through each string in the list\n    for each string in list_of_strings:\n        # Check if the string is a palindrome\n        if string is a palindrome:\n            # If it is, add it to the list of palindromes\n            add string to \"palindromes\"\n\n    # Return the list of palindromes\n    return \"palindromes\"\n\n# Helper function to check if a string is a palindrome\nfunction is_palindrome(string):\n    # Reverse the string and check if it's the same as the original\n    if string is the same as its reverse:\n        # If it is, return True\n        return True\n    else:\n        # If it's not, return False\n        return False\n\n# Helper function to reverse a string\nfunction reverse_string(string):\n    # Create an empty string to store the reversed string\n    create an empty string named \"reversed_string\"\n\n    # Loop through each character in the string in reverse order\n    for each character in string in reverse order:\n        # Add the character to the reversed string\n        add character to \"reversed_string\"\n\n    # Return the reversed string\n    return \"reversed_string\"",
    "864": "function print_n_times_list(input_list, n):\n    # Create an empty list to store the result\n    create an empty list named \"result\"\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # Repeat the element n times and add it to the result list\n        add n copies of element to \"result\"\n\n    # Return the result list\n    return \"result\"",
    "865": "function check_month_days(month_name):\n    # Create a dictionary to map month names to their number of days\n    create a dictionary named \"month_days\" with keys as month names and values as their number of days\n\n    # Check if the given month name exists in our dictionary\n    if month_name is in \"month_days\":\n        # If it does, return whether it has 31 days\n        return whether \"month_days[month_name]\" is equal to 31\n    else:\n        # If it doesn't exist, return a signal (like None or a message)\n        return None",
    "866": "function add_minimum_to_make_even(array):\n    # Check if the sum of the array is even\n    if sum of array is even:\n        # If it is, return 0 as no change is needed\n        return 0\n    else:\n        # If it's not, return 1 as we need to add 1 to make it even\n        return 1",
    "867": "function find_length_of_last_word(input_string):\n    # Remove trailing and leading spaces from the input string\n    input_string = remove_leading_and_trailing_spaces(input_string)\n\n    # Split the string into a list of words\n    words = split_string_into_words(input_string)\n\n    # The last word in the list is the last word in the string\n    last_word = get_last_element_from_list(words)\n\n    # Return the length of the last word\n    return get_length_of_string(last_word)\n\nfunction remove_leading_and_trailing_spaces(input_string):\n    # Remove leading spaces\n    while the first character of input_string is a space:\n        remove the first character from input_string\n\n    # Remove trailing spaces\n    while the last character of input_string is a space:\n        remove the last character from input_string\n\n    return input_string\n\nfunction split_string_into_words(input_string):\n    # Split the string into a list of words using spaces as separators\n    return split(input_string, \" \")\n\nfunction get_last_element_from_list(list):\n    # Return the last element of the list\n    return list[-1]\n\nfunction get_length_of_string(string):\n    # Return the length of the string\n    return length of string",
    "868": "function remove_sublists_outside_range(list_of_lists, range_start, range_end):\n    # Create an empty list to store the lists that are within the range\n    create an empty list named \"within_range\"\n\n    # Loop through each sublist in the list of lists\n    for each sublist in list_of_lists:\n        # Check if the sum of the sublist is within the range\n        if sum of sublist is within range_start and range_end:\n            # If it is, add it to the list of lists within the range\n            add sublist to \"within_range\"\n\n    # Return the list of lists within the range\n    return \"within_range\"",
    "869": "function calculate_sum_of_positive_numbers(list_of_numbers):\n    # Use the lambda function to filter out the positive numbers\n    positive_numbers = filter(lambda number: number > 0, list_of_numbers)\n\n    # Use the lambda function to calculate the sum of the positive numbers\n    sum_of_positive_numbers = reduce(lambda total, number: total + number, positive_numbers)\n\n    # Return the sum of the positive numbers\n    return sum_of_positive_numbers",
    "870": "function are_rotations(string1, string2):\n    # Check if the lengths of the strings are equal\n    if the length of string1 is not equal to the length of string2:\n        # If not, they can't be rotations of each other, so return False\n        return False\n\n    # Concatenate string1 with itself\n    concatenated_string = string1 + string1\n\n    # Check if string2 is a substring of the concatenated string\n    if string2 is a substring of concatenated_string:\n        # If it is, they are rotations of each other, so return True\n        return True\n    else:\n        # If it's not, they are not rotations of each other, so return False\n        return False",
    "871": "function is_subset(subset, superset):\n    # Check if the subset is empty\n    if subset is empty:\n        # If it is, the subset is a subset of the superset\n        return True\n\n    # Check if the superset is empty\n    if superset is empty:\n        # If it is, the subset is not a subset of the superset\n        return False\n\n    # Check if the first element of the subset is in the superset\n    if first element of subset is in superset:\n        # If it is, remove the first element of the subset from the superset\n        remove first element of subset from superset\n\n        # Recursively check if the rest of the subset is a subset of the superset\n        return is_subset(rest of subset, superset)\n\n    # If the first element of the subset is not in the superset, it's not a subset\n    return False",
    "872": "function fibonacci(n):\n    # Base case: if n is 0 or 1, return n\n    if n is 0 or n is 1:\n        return n\n    # Recursive case: fibonacci(n) = fibonacci(n-1) + fibonacci(n-2)\n    else:\n        return fibonacci(n-1) + fibonacci(n-2)",
    "873": "function is_concatenation(input_string, target_string):\n    # Create a variable to keep track of the current position in the target string\n    create a variable named \"target_position\" and set it to 0\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If the current character matches the character at the current position in the target string\n        if character is equal to the character at position \"target_position\" in target_string:\n            # Move to the next character in the target string\n            increment \"target_position\" by 1\n\n            # If we've reached the end of the target string, return True\n            if \"target_position\" is equal to the length of target_string:\n                return True\n\n    # If we've checked all characters in the input string and not found a match in the target string, return False\n    return False",
    "874": "function find_min_difference(tuple_pairs):\n    # Initialize a variable to keep track of the minimum difference\n    set min_difference to infinity\n\n    # Loop through each pair of tuples\n    for each pair in tuple_pairs:\n        # Calculate the difference between the two numbers in the pair\n        set difference to the absolute difference of the two numbers in the pair\n\n        # If this difference is less than the current minimum difference, update the minimum difference\n        if difference is less than min_difference:\n            set min_difference to difference\n\n    # Return the minimum difference\n    return min_difference",
    "875": "function find_lcm(num1, num2):\n    # Initialize the greater number\n    if num1 > num2:\n        greater = num1\n    else:\n        greater = num2\n\n    # Always true loop until we find the lcm\n    while(True):\n        if((greater % num1 == 0) and (greater % num2 == 0)):\n            lcm = greater\n            break\n        greater += 1\n\n    return lcm",
    "876": "function sort_string(input_string):\n    # Convert the string to a list of characters\n    convert input_string to a list named \"characters\"\n\n    # Sort the list of characters\n    sort \"characters\"\n\n    # Join the sorted list of characters back into a string\n    join \"characters\" into a string named \"sorted_string\"\n\n    # Return the sorted string\n    return \"sorted_string\"",
    "877": "function check_tuple_elements(tuple, k):\n    # Get the length of the tuple\n    get the length of tuple and store it in variable \"tuple_length\"\n\n    # Check if the length of the tuple is equal to k\n    if tuple_length is equal to k:\n        # If it is, return True\n        return True\n    else:\n        # If it's not, return False\n        return False",
    "878": "function match_string_with_regex(input_string):\n    # Import the re module for regular expressions\n    import re\n\n    # Define the regular expression pattern\n    pattern = \"a.*b$\"\n\n    # Use the re.match function to check if the input string matches the pattern\n    if re.match(pattern, input_string):\n        # If it does, return True\n        return True\n    else:\n        # If it doesn't, return False\n        return False",
    "879": "function find_number_of_solutions(a, b, c):\n    # Calculate the discriminant\n    calculate the discriminant as b^2 - 4ac\n\n    # Check the discriminant\n    if discriminant is greater than 0:\n        # If the discriminant is greater than 0, the equation has two real solutions\n        return 2\n    else if discriminant is equal to 0:\n        # If the discriminant is equal to 0, the equation has one real solution\n        return 1\n    else:\n        # If the discriminant is less than 0, the equation has no real solutions\n        return 0",
    "880": "function sum_first_even_odd_numbers(list_of_numbers):\n    # Initialize counters for even and odd numbers\n    initialize counter for even numbers as 0\n    initialize counter for odd numbers as 0\n\n    # Loop through each number in the list\n    for each number in list_of_numbers:\n        # Check if the number is even\n        if number is divisible by 2:\n            # If it is, increment the counter for even numbers\n            increment counter for even numbers by 1\n            # Add the number to the sum of even numbers\n            add number to sum of even numbers\n\n            # Check if we've found two even numbers\n            if counter for even numbers is 2:\n                # If we have, break out of the loop\n                break\n\n        # Check if the number is odd\n        else if number is not divisible by 2:\n            # If it is, increment the counter for odd numbers\n            increment counter for odd numbers by 1\n            # Add the number to the sum of odd numbers\n            add number to sum of odd numbers\n\n            # Check if we've found two odd numbers\n            if counter for odd numbers is 2:\n                # If we have, break out of the loop\n                break\n\n    # Return the sum of the first two even and odd numbers\n    return sum of even numbers and sum of odd numbers",
    "881": "function calculate_perimeter(side1, side2, side3, side4):\n    # Add all the sides together to get the perimeter\n    perimeter = side1 + side2 + side3 + side4\n\n    # Return the calculated perimeter\n    return perimeter",
    "882": "function find_numbers_divisible_by_m_and_n(list_of_numbers, m, n):\n    # Create an empty list to store the numbers that are divisible by both m and n\n    create an empty list named \"divisible_numbers\"\n\n    # Use the lambda function to filter the list of numbers\n    filter the list_of_numbers using a lambda function that checks if a number is divisible by both m and n\n    if the number is divisible by both m and n:\n        add the number to \"divisible_numbers\"\n\n    # Return the list of numbers that are divisible by both m and n\n    return \"divisible_numbers\"",
    "883": "function check_bits_in_range(number, start, end):\n    # Convert the number to binary\n    convert number to binary and store it in a variable named \"binary_number\"\n\n    # Remove the '0b' prefix from the binary number\n    remove '0b' from the start of \"binary_number\"\n\n    # Loop through each bit in the binary number\n    for each bit in \"binary_number\":\n        # Convert the bit back to an integer\n        convert bit back to an integer and store it in a variable named \"bit_as_int\"\n\n        # Check if the bit is within the given range\n        if bit_as_int is not within the range from start to end:\n            # If it's not, return False\n            return False\n\n    # If we've checked all bits and found no out-of-range bits, return True\n    return True",
    "884": "function check_isomorphic(string1, string2):\n    # If the lengths of the strings are not equal, they cannot be isomorphic\n    if the length of string1 is not equal to the length of string2:\n        return False\n\n    # Create two empty dictionaries to keep track of the mappings\n    create an empty dictionary named \"mapping1\"\n    create an empty dictionary named \"mapping2\"\n\n    # Loop through each character in the strings\n    for each character in string1 and string2:\n        # Check if the character is already in one of the mappings\n        if character from string1 is already in \"mapping1\" or character from string2 is already in \"mapping2\":\n            # If it is, check if the mappings are consistent\n            if the mapping from \"mapping1\" for character from string1 is not equal to the mapping from \"mapping2\" for character from string2:\n                # If they are not, the strings are not isomorphic\n                return False\n        else:\n            # If it's a new character, add it to the mappings\n            add character from string1 to \"mapping1\" with the corresponding character from string2\n            add character from string2 to \"mapping2\" with the corresponding character from string1\n\n    # If we've checked all characters and found no inconsistencies, the strings are isomorphic\n    return True",
    "885": "function calculate_average(list_of_numbers):\n    # Initialize a variable to keep track of the sum of all numbers\n    set a variable named \"sum\" to 0\n\n    # Loop through each number in the list\n    for each number in list_of_numbers:\n        # Add the current number to the sum\n        add number to \"sum\"\n\n    # Calculate the average by dividing the sum by the length of the list\n    set a variable named \"average\" to \"sum\" divided by the length of list_of_numbers\n\n    # Return the average\n    return average",
    "886": "function check_odd_or_even(number):\n    # Use the bitwise AND operator to check if the least significant bit is set\n    if number AND 1 equals 1:\n        # If the least significant bit is set, the number is odd\n        return \"Odd\"\n    else:\n        # If the least significant bit is not set, the number is even\n        return \"Even\"",
    "887": "function subtract_nested_tuples(tuple1, tuple2):\n    # Create an empty collection to store the result\n    create an empty collection named \"result\"\n\n    # Loop through each element in the first tuple\n    for each element in tuple1:\n        # If the element is a tuple, recursively subtract it from the corresponding element in tuple2\n        if element is a tuple:\n            subtract_nested_tuples(element, tuple2[index of element in tuple1])\n        else:\n            # If the element is not a tuple, subtract it from the corresponding element in tuple2\n            subtract element from tuple2[index of element in tuple1]\n            add the result to \"result\"\n\n    # Return the result\n    return \"result\"",
    "888": "function reverse_each_list(list_of_lists):\n    # Create an empty list to store the reversed lists\n    create an empty list named \"reversed_lists\"\n\n    # Loop through each list in the input list of lists\n    for each list in list_of_lists:\n        # Reverse the current list\n        reverse the current list\n\n        # Add the reversed list to the list of reversed lists\n        add the reversed list to \"reversed_lists\"\n\n    # Return the list of reversed lists\n    return \"reversed_lists\"",
    "889": "function find_extra_element_index(array1, array2):\n    # Initialize two pointers, one for each array\n    set pointer1 to 0\n    set pointer2 to 0\n\n    # Loop until we've checked all elements in both arrays\n    while pointer1 < length of array1 and pointer2 < length of array2:\n        # If the current elements are the same, move to the next elements\n        if array1[pointer1] is equal to array2[pointer2]:\n            increment pointer1 by 1\n            increment pointer2 by 1\n        else:\n            # If the current elements are different, the extra element is at pointer2\n            return pointer2\n\n    # If we've checked all elements and found no extra elements, return a signal (like None or a message)\n    return None",
    "890": "function check_same_digit_count(num1, num2):\n    # Convert the numbers to strings\n    convert num1 to a string and store it in a variable named \"str1\"\n    convert num2 to a string and store it in a variable named \"str2\"\n\n    # Check if the lengths of the strings are equal\n    if the length of \"str1\" is equal to the length of \"str2\":\n        # If they are, return True\n        return True\n    else:\n        # If they are not, return False\n        return False",
    "891": "function remove_multiple_spaces(input_string):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If the character is not a space or if the last character in \"result\" is not a space\n        if character is not a space or if the last character in \"result\" is not a space:\n            # Add the character to \"result\"\n            add character to \"result\"\n\n    # Return the result string\n    return \"result\"",
    "892": "function get_last_elements(list_of_sublists):\n    # Create an empty list to store the last elements\n    create an empty list named \"last_elements\"\n\n    # Loop through each sublist in the list of sublists\n    for each sublist in list_of_sublists:\n        # Check if the sublist is not empty\n        if sublist is not empty:\n            # If it's not empty, get the last element of the sublist\n            get the last element of sublist and store it in a variable named \"last_element\"\n\n            # Add the last element to the list of last elements\n            add \"last_element\" to \"last_elements\"\n\n    # Return the list of last elements\n    return \"last_elements\"",
    "893": "function convert_string_to_tuple(input_string):\n    # Create an empty list to store the float numbers\n    create an empty list named \"float_numbers\"\n\n    # Split the input string into a list of strings, each representing a float number\n    split input_string into a list of strings named \"split_string\" using \" \" as the delimiter\n\n    # Loop through each string in the list\n    for each string in \"split_string\":\n        # Try to convert the string to a float\n        try to convert string to a float named \"float_number\"\n            # If successful, add it to the list of float numbers\n            add \"float_number\" to \"float_numbers\"\n        except:\n            # If the conversion fails, ignore the string and move on to the next one\n            continue\n\n    # Convert the list of float numbers into a tuple and return it\n    convert \"float_numbers\" into a tuple named \"float_tuple\"\n    return \"float_tuple\"",
    "894": "function max_sum_subsequence(array):\n    # Create a list to store the maximum sum at each index\n    create a list named \"max_sum\" with length equal to the length of the array\n\n    # Initialize the first element of the list\n    max_sum[0] = array[0]\n\n    # Initialize the second element of the list\n    max_sum[1] = max(array[0], array[1])\n\n    # Loop through the rest of the array\n    for i from 2 to length of array:\n        # Calculate the maximum sum at this index\n        max_sum[i] = max(max_sum[i-1], max_sum[i-2] + array[i])\n\n    # Return the last element of the list, which is the maximum sum\n    return max_sum[length of array]",
    "895": "function sort_tuples_by_last_element(list_of_tuples):\n    # Create an empty list to store the sorted tuples\n    create an empty list named \"sorted_tuples\"\n\n    # Loop through each tuple in the list\n    for each tuple in list_of_tuples:\n        # Find the index of the tuple in the sorted list where the last element of the tuple should be inserted\n        find the index where the last element of the tuple should be inserted in \"sorted_tuples\"\n\n        # Insert the tuple into the sorted list at the calculated index\n        insert the tuple into \"sorted_tuples\" at the calculated index\n\n    # Return the sorted list of tuples\n    return \"sorted_tuples\"",
    "896": "function check_word_in_sentence(sentence, word):\n    # Convert the sentence and word to lowercase to make the comparison case-insensitive\n    sentence = sentence.lower()\n    word = word.lower()\n\n    # Split the sentence into words\n    words_in_sentence = sentence.split()\n\n    # Check if the word is in the list of words in the sentence\n    if word in words_in_sentence:\n        # If it is, return True\n        return True\n    else:\n        # If it's not, return False\n        return False",
    "897": "function extract_elements(input_list, number_of_elements):\n    # Create an empty list to store the extracted elements\n    create an empty list named \"extracted_elements\"\n\n    # Loop through the input list\n    for each element in input_list:\n        # If the length of \"extracted_elements\" is less than the specified number of elements\n        if length of \"extracted_elements\" is less than number_of_elements:\n            # Add the current element to \"extracted_elements\"\n            add element to \"extracted_elements\"\n        else:\n            # If the length of \"extracted_elements\" is equal to or greater than the specified number of elements\n            # Break the loop as we have enough elements\n            break\n\n    # Return the list of extracted elements\n    return \"extracted_elements\"",
    "898": "function can_be_sorted(array):\n    # Create a copy of the array\n    create a copy of array named \"copy_array\"\n\n    # Sort the copy of the array\n    sort \"copy_array\"\n\n    # Initialize a counter to keep track of how many elements are out of place\n    initialize a counter named \"out_of_place\" to 0\n\n    # Loop through each element in the array\n    for each element in array:\n        # If the element is not in the correct position in the sorted array\n        if element is not in the correct position in \"copy_array\":\n            # Increment the counter\n            increment \"out_of_place\" by 1\n\n    # If the counter is less than or equal to 2, the array can be sorted\n    if \"out_of_place\" is less than or equal to 2:\n        return True\n    else:\n        return False",
    "899": "function check_string_starts_with_number(input_string, number):\n    # Convert the number to a string\n    convert number to string\n\n    # Check if the input string starts with the number\n    if the first characters of input_string are equal to the number:\n        # If it does, return True\n        return True\n    else:\n        # If it doesn't, return False\n        return False",
    "900": "function find_smallest_multiple(n):\n    # Initialize the smallest multiple to 1\n    let smallest_multiple be 1\n\n    # Loop from 1 to n\n    for i from 1 to n:\n        # Find the greatest common divisor of the current smallest multiple and the current number\n        let gcd be the greatest common divisor of smallest_multiple and i\n\n        # Update the smallest multiple to be the product of the current smallest multiple and the current number, divided by their greatest common divisor\n        smallest_multiple be (smallest_multiple * i) / gcd\n\n    # Return the smallest multiple\n    return smallest_multiple\n\nNote: The greatest common divisor (gcd) function is not provided in the pseudocode. It is a standard function in number theory and can be implemented in many programming languages.",
    "901": "function combine_dictionaries(dict1, dict2):\n    # Create a new dictionary to store the combined values\n    create an empty dictionary named \"combined_dict\"\n\n    # Loop through each key-value pair in the first dictionary\n    for each key-value pair in dict1:\n        # If the key is in the second dictionary, add the values\n        if key is in dict2:\n            add the value from dict1 to the value in dict2\n        else:\n            # If the key is not in the second dictionary, add it to the combined dictionary\n            add key-value pair from dict1 to \"combined_dict\"\n\n    # Loop through each key-value pair in the second dictionary\n    for each key-value pair in dict2:\n        # If the key is not in the first dictionary, add it to the combined dictionary\n        if key is not in dict1:\n            add key-value pair from dict2 to \"combined_dict\"\n\n    # Return the combined dictionary\n    return combined_dict",
    "902": "function count_unset_bits(n):\n    # Initialize count to 0\n    create a variable named \"count\" and set it to 0\n\n    # Loop from 1 to n\n    for i from 1 to n:\n        # Convert i to binary and remove the '0b' prefix\n        convert i to binary and remove the '0b' prefix\n\n        # Count the number of '0's in the binary representation\n        count the number of '0's in the binary representation\n\n        # Add the count to our total\n        add the count to our total\n\n    # Return the total count\n    return the total count",
    "903": "function is_even(number):\n    # Check if the remainder of the number divided by 2 is 0\n    if the remainder of number divided by 2 is 0:\n        # If it is, the number is even, so return true\n        return true\n    else:\n        # If it's not, the number is odd, so return false\n        return false",
    "904": "function sum_of_squares_of_binomial_coefficients(n, k):\n    # Initialize sum to 0\n    initialize sum to 0\n\n    # Loop from 0 to k\n    for i from 0 to k:\n        # Calculate binomial coefficient\n        calculate binomial coefficient using n and i\n\n        # Square the binomial coefficient\n        square the binomial coefficient\n\n        # Add the squared binomial coefficient to the sum\n        add the squared binomial coefficient to sum\n\n    # Return the sum\n    return sum",
    "905": "function extract_date_from_url(url):\n    # Import the required module\n    import re\n\n    # Define the pattern for the date in the url\n    pattern = \"(\\d{4})-(\\d{2})-(\\d{2})\"\n\n    # Use the re.search function to find the first match of the pattern in the url\n    match = re.search(pattern, url)\n\n    # If a match was found, extract the year, month and date\n    if match:\n        year = match.group(1)\n        month = match.group(2)\n        day = match.group(3)\n\n        # Return the year, month and date\n        return year, month, day\n\n    # If no match was found, return a signal (like None or a message)\n    return None",
    "906": "function print_first_n_lucky_numbers(n):\n    # Initialize an empty list to store the lucky numbers\n    create an empty list named \"lucky_numbers\"\n\n    # Initialize a counter for the number of lucky numbers we've found\n    create a variable named \"counter\" and set it to 0\n\n    # Start a loop to generate lucky numbers\n    while the length of \"lucky_numbers\" is less than n:\n        # Increment the counter\n        increment \"counter\" by 1\n\n        # Check if the counter is a multiple of 2 or 3\n        if \"counter\" is divisible by 2 or \"counter\" is divisible by 3:\n            # If it is, add it to the list of lucky numbers\n            add \"counter\" to \"lucky_numbers\"\n\n    # Print each lucky number\n    for each number in \"lucky_numbers\":\n        print number",
    "907": "function find_fixed_point(input_array):\n    # Loop through each element in the input array\n    for each index in range of length of input_array:\n        # Check if the index is equal to the value at that index\n        if index equals the value at that index:\n            # If it is, this is the fixed point, so return it\n            return index\n\n    # If we've checked all elements and found no fixed points, return a signal (like None or a message)\n    return None",
    "908": "function find_previous_palindrome(number):\n    # Convert the number to a string\n    convert number to string and store it in \"number_string\"\n\n    # Reverse the string\n    reverse \"number_string\" and store it in \"reversed_string\"\n\n    # Convert the reversed string back to a number\n    convert \"reversed_string\" to a number and store it in \"reversed_number\"\n\n    # Check if the reversed number is less than the original number\n    if \"reversed_number\" is less than \"number\":\n        # If it is, return the reversed number\n        return \"reversed_number\"\n    else:\n        # If it's not, decrement the original number by 1 and repeat the process\n        decrement \"number\" by 1\n        repeat the process from the start",
    "909": "function validate_gregorian_date(year, month, day):\n    # Check if year is a valid integer\n    if year is not an integer or year is less than 1:\n        return False\n\n    # Check if month is a valid integer\n    if month is not an integer or month is less than 1 or month is greater than 12:\n        return False\n\n    # Check if day is a valid integer\n    if day is not an integer or day is less than 1:\n        return False\n\n    # Check if the day is valid for the given month and year\n    if day is greater than the number of days in the given month for the given year:\n        return False\n\n    # If all checks pass, the date is valid\n    return True",
    "910": "function max_product_of_three(array):\n    # Initialize a heap queue\n    create a heap queue named \"heap\"\n\n    # Loop through each number in the array\n    for each number in array:\n        # Add the number to the heap queue\n        add number to \"heap\"\n\n        # If the heap queue is larger than 3, remove the smallest number\n        if size of \"heap\" is greater than 3:\n            remove smallest number from \"heap\"\n\n    # The heap queue should now contain the three largest numbers\n    # Multiply them together to get the maximum product\n    return product of the numbers in \"heap\"",
    "911": "function find_first_repeated_character(input_string):\n    # Create an empty collection to keep track of characters we've seen\n    create an empty collection named \"seen_characters\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if we've come across this character before\n        if character is already in \"seen_characters\":\n            # If we have, this is the first repeated character, so return it\n            return character\n        else:\n            # If it's a new character, add it to our collection to remember it\n            add character to \"seen_characters\"\n\n    # If we've checked all characters and found no repeats, return a signal (like None or a message)\n    return None",
    "912": "function check_number_at_end(input_string):\n    # Create an empty collection to keep track of characters we've seen\n    create an empty collection named \"seen_characters\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if we've come across this character before\n        if character is already in \"seen_characters\":\n            # If we have, this is the first repeated character, so return it\n            return character\n        else:\n            # If it's a new character, add it to our collection to remember it\n            add character to \"seen_characters\"\n\n    # If we've checked all characters and found no repeats, return a signal (like None or a message)\n    return None",
    "913": "function is_alternating(input_string):\n    # If the string is empty or has only one character, it's not alternating\n    if length of input_string is less than 2:\n        return False\n\n    # Get the first character of the string\n    first_character = first character of input_string\n\n    # Loop through each character in the string, starting from the second character\n    for each character in input_string starting from the second character:\n        # If the current character is the same as the first character, the string is not alternating\n        if character is the same as first_character:\n            return False\n\n    # If we've checked all characters and found no repeats, the string is alternating\n    return True",
    "914": "function rearrange_positive_and_negative(input_array):\n    # Sort the array using lambda function\n    sort input_array using lambda function that returns the absolute value of each element\n\n    # Return the sorted array\n    return sorted array",
    "915": "function find_triplet_with_sum(array, target_sum):\n    # Sort the array in ascending order\n    sort array in ascending order\n\n    # Loop through each element in the array\n    for each element in array:\n        # Initialize two pointers, one at the start of the array and one at the end\n        set two pointers, one at the start of the array and one at the end\n\n        # While the start pointer is less than the end pointer\n        while start_pointer < end_pointer:\n            # Calculate the sum of the current element, the element at the start pointer, and the element at the end pointer\n            calculate the sum of the current element, the element at the start pointer, and the element at the end pointer\n\n            # If the sum is equal to the target sum\n            if sum is equal to the target sum:\n                # Return True, because we've found a triplet\n                return True\n            else if sum is less than the target sum:\n                # Increment the start pointer, because the current sum is too small\n                increment the start pointer\n            else:\n                # Decrement the end pointer, because the current sum is too large\n                decrement the end pointer\n\n    # If we've checked all elements and found no triplets, return False\n    return False",
    "916": "function find_sequences(input_string):\n    # Create an empty list to store the sequences\n    create an empty list named \"sequences\"\n\n    # Initialize an empty string to store the current sequence\n    create an empty string named \"current_sequence\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If the character is an uppercase letter\n        if character is an uppercase letter:\n            # If there is a current sequence, add it to the list and reset the current sequence\n            if \"current_sequence\" is not empty:\n                add \"current_sequence\" to \"sequences\"\n                reset \"current_sequence\"\n            # Add the uppercase letter to the current sequence\n            add character to \"current_sequence\"\n        # If the character is a lowercase letter\n        else if character is a lowercase letter:\n            # Add the lowercase letter to the current sequence\n            add character to \"current_sequence\"\n        # If the character is not a letter\n        else:\n            # If there is a current sequence, add it to the list and reset the current sequence\n            if \"current_sequence\" is not empty:\n                add \"current_sequence\" to \"sequences\"\n                reset \"current_sequence\"\n\n    # If there is a current sequence at the end of the string, add it to the list\n    if \"current_sequence\" is not empty:\n        add \"current_sequence\" to \"sequences\"\n\n    # Return the list of sequences\n    return \"sequences\"",
    "917": "function count_coin_change(amount, coins):\n    # Create a list to store the number of ways to make change for each amount up to the target amount\n    create a list named \"ways\" with length amount + 1 and initialize all elements to 0\n\n    # There is 1 way to make change for 0 (by not using any coins)\n    set the first element of \"ways\" to 1\n\n    # Loop through each coin\n    for each coin in coins:\n        # Loop through each amount from the coin value up to the target amount\n        for each index from coin to amount:\n            # Add the number of ways to make change for the current amount minus the coin value\n            add the number of ways to make change for the current amount minus the coin value to the current element of \"ways\"\n\n    # Return the last element of \"ways\" which represents the number of ways to make change for the target amount\n    return the last element of \"ways\"",
    "918": "function multiply_all_items(input_list):\n    # Initialize the result to 1\n    set result to 1\n\n    # Loop through each item in the input list\n    for each item in input_list:\n        # Multiply the result by the current item\n        multiply result by item\n\n    # Return the final result\n    return result",
    "919": "function remove_none_tuples(tuple_list):\n    # Create an empty list to keep track of tuples that are not all none\n    create an empty list named \"non_none_tuples\"\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Check if the tuple is not all none\n        if tuple is not all none:\n            # If it's not all none, add it to our list\n            add tuple to \"non_none_tuples\"\n\n    # Return the list of tuples that are not all none\n    return \"non_none_tuples\"",
    "920": "function chunk_tuples(tuples, n):\n    # Create an empty list to store the chunks\n    create an empty list named \"chunks\"\n\n    # Loop through each tuple in the input list\n    for each tuple in tuples:\n        # If the length of the current chunk is less than n\n        if length of current chunk is less than n:\n            # Add the current tuple to the current chunk\n            add tuple to current chunk\n        else:\n            # If the length of the current chunk is equal to n\n            # Add the current chunk to the list of chunks\n            add current chunk to chunks\n            # Create a new chunk and add the current tuple to it\n            create a new empty list named \"new_chunk\"\n            add tuple to new_chunk\n            # Set the current chunk to the new chunk\n            set current chunk to new_chunk\n\n    # If there are any remaining tuples in the current chunk\n    if there are any tuples in current chunk:\n        # Add the current chunk to the list of chunks\n        add current chunk to chunks\n\n    # Return the list of chunks\n    return chunks",
    "921": "function find_highest_product_pair(input_array):\n    # Initialize the highest product to negative infinity\n    initialize highest_product to negative infinity\n\n    # Initialize the pair of numbers with the highest product\n    initialize highest_product_pair to None\n\n    # Loop through each number in the input array\n    for each number in input_array:\n        # Loop through each other number in the input array\n        for each other_number in input_array:\n            # Skip if the number is the same as the other number\n            if number is the same as other_number:\n                continue\n\n            # Calculate the product of the current pair of numbers\n            calculate product as number * other_number\n\n            # If this product is higher than the highest product found so far\n            if product is greater than highest_product:\n                # Update the highest product and the pair of numbers\n                update highest_product to product\n                update highest_product_pair to (number, other_number)\n\n    # Return the pair of numbers with the highest product\n    return highest_product_pair",
    "922": "function find_shortest_common_subsequence(str1, str2):\n    # Create a 2D array to store the lengths of common subsequences\n    create a 2D array named \"lengths\" with dimensions (len(str1)+1) x (len(str2)+1)\n\n    # Initialize the first row and column to 0\n    for i from 0 to len(str1):\n        lengths[i][0] = 0\n    for j from 0 to len(str2):\n        lengths[0][j] = 0\n\n    # Fill in the rest of the array\n    for i from 1 to len(str1):\n        for j from 1 to len(str2):\n            if str1[i-1] == str2[j-1]:\n                lengths[i][j] = lengths[i-1][j-1] + 1\n            else:\n                lengths[i][j] = max(lengths[i-1][j], lengths[i][j-1])\n\n    # The length of the shortest common subsequence is in the bottom right corner of the array\n    return lengths[len(str1)][len(str2)]",
    "923": "function find_maximum(num1, num2):\n    # Check if num1 is greater than num2\n    if num1 > num2:\n        # If it is, return num1\n        return num1\n    else:\n        # If num1 is not greater than num2, return num2\n        return num2",
    "924": "function calculate_product_of_numbers(input_tuple):\n    # Initialize the product to 1\n    set product to 1\n\n    # Loop through each element in the input tuple\n    for each element in input_tuple:\n        # If the element is a number, multiply it with the product\n        if element is a number:\n            multiply product by element\n\n    # Return the final product\n    return product",
    "925": "function find_nth_rencontres_number(n):\n    # Initialize the first two rencontres numbers\n    let rencontres_numbers[0] = 0\n    let rencontres_numbers[1] = 1\n\n    # Loop from 2 to n\n    for i from 2 to n:\n        # Calculate the nth rencontres number\n        let rencontres_numbers[i] = rencontres_numbers[i-1] + rencontres_numbers[i-2]\n\n    # Return the nth rencontres number\n    return rencontres_numbers[n]",
    "926": "function calculate_height(root):\n    # If the tree is empty, return -1\n    if root is None:\n        return -1\n\n    # Calculate the height of the left subtree\n    left_height = calculate_height(root.left)\n\n    # Calculate the height of the right subtree\n    right_height = calculate_height(root.right)\n\n    # Return the maximum height between the left and right subtrees plus 1 (for the root)\n    return max(left_height, right_height) + 1",
    "927": "function convert_date_format(date_string):\n    # Split the date string into year, month, and day\n    split date_string into year, month, and day using \"-\" as the delimiter\n\n    # Return the date in the new format\n    return day + \"-\" + month + \"-\" + year",
    "928": "function count_repeated_items(input_tuple):\n    # Create an empty dictionary to keep track of items and their counts\n    create an empty dictionary named \"item_counts\"\n\n    # Loop through each item in the input tuple\n    for each item in input_tuple:\n        # If the item is already in our dictionary, increment its count\n        if item is already in \"item_counts\":\n            increment the count for item in \"item_counts\"\n        else:\n            # If it's a new item, add it to our dictionary with a count of 1\n            add item to \"item_counts\" with a count of 1\n\n    # Return the dictionary of item counts\n    return item_counts",
    "929": "function match_string_with_ab(input_string):\n    # Import the regular expression module\n    import regular expression module\n\n    # Define the regular expression pattern\n    pattern = \"a(b*)$\"\n\n    # Use the regular expression to match the input string\n    match = regular expression module.match(pattern, input_string)\n\n    # If the match is successful, return True\n    if match is not None:\n        return True\n    else:\n        # If the match is not successful, return False\n        return False",
    "930": "function calculate_sum_of_series(n):\n    # Initialize sum to 0\n    set sum to 0\n\n    # Loop from 1 to n\n    for i from 1 to n:\n        # Add the cube of i to the sum\n        add the cube of i to sum\n\n    # Return the sum\n    return sum",
    "931": "function remove_duplicate_words(input_list):\n    # Create an empty collection to keep track of words we've seen\n    create an empty collection named \"seen_words\"\n\n    # Create an empty list to store the result\n    create an empty list named \"result\"\n\n    # Loop through each word in the input list\n    for each word in input_list:\n        # Check if we've come across this word before\n        if word is already in \"seen_words\":\n            # If we have, this is a duplicate word, so skip it\n            continue\n        else:\n            # If it's a new word, add it to our collection to remember it\n            add word to \"seen_words\"\n            # Also add it to the result list\n            add word to \"result\"\n\n    # Return the result list\n    return \"result\"",
    "932": "function convert_camel_case_to_snake_case(input_string):\n    # Import the regex module\n    import regex\n\n    # Use the regex to find all capital letters in the input string\n    matches = regex.findall('[A-Z][^A-Z]*', input_string)\n\n    # Join the matches with underscores to form the snake case string\n    snake_case_string = '_'.join(matches).lower()\n\n    # Return the snake case string\n    return snake_case_string",
    "933": "function find_nth_delannoy_number(n):\n    # If n is 0, return 1\n    if n is 0:\n        return 1\n\n    # Initialize two variables to 1\n    let a be 1\n    let b be 1\n\n    # Loop from 1 to n\n    for i from 1 to n:\n        # Calculate the next delannoy number\n        let c be a + b + 1\n\n        # Update a and b for the next iteration\n        let a be b\n        let b be c\n\n    # Return the nth delannoy number\n    return b",
    "934": "function calculate_sum_of_squares(n):\n    # Initialize the sum to 0\n    set sum to 0\n\n    # Loop from 1 to n\n    for i from 1 to n:\n        # Add the square of i to the sum\n        add i squared to sum\n\n    # Return the final sum\n    return sum",
    "935": "function rearrange_tuples(tuples, order):\n    # Create an empty dictionary to store the tuples\n    create an empty dictionary named \"tuple_dict\"\n\n    # Loop through each tuple in the input tuples\n    for each tuple in tuples:\n        # Add the tuple to the dictionary with its first element as the key\n        add tuple to \"tuple_dict\" with tuple[0] as the key\n\n    # Create an empty list to store the rearranged tuples\n    create an empty list named \"rearranged_tuples\"\n\n    # Loop through each element in the order list\n    for each element in order:\n        # If the element is in the dictionary, add the tuple to the rearranged list\n        if element is in \"tuple_dict\":\n            add tuple with key \"element\" from \"tuple_dict\" to \"rearranged_tuples\"\n\n    # Return the rearranged list of tuples\n    return \"rearranged_tuples\"",
    "936": "function count_most_common_character(input_string):\n    # Create an empty dictionary to keep track of character counts\n    create an empty dictionary named \"character_counts\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If the character is already in our dictionary, increment its count\n        if character is already in \"character_counts\":\n            increment the count for character in \"character_counts\"\n        else:\n            # If it's a new character, add it to our dictionary with a count of 1\n            add character to \"character_counts\" with a count of 1\n\n    # Find the character with the highest count\n    set the most_common_character to the character with the highest count in \"character_counts\"\n\n    # Return the most common character\n    return most_common_character",
    "937": "function find_three_closest_elements(array1, array2, array3):\n    # Initialize three pointers for each array\n    initialize three pointers named \"pointer1\", \"pointer2\", and \"pointer3\" to 0\n\n    # Initialize variables to store the closest sum and the three closest elements\n    initialize a variable named \"closest_sum\" to infinity\n    initialize a variable named \"closest_elements\" to an empty list\n\n    # Loop until one of the pointers reaches the end of its array\n    while pointer1 is less than the length of array1 and pointer2 is less than the length of array2 and pointer3 is less than the length of array3:\n        # Calculate the sum of the current elements\n        calculate the sum of array1[pointer1], array2[pointer2], and array3[pointer3] and store it in a variable named \"current_sum\"\n\n        # If the current sum is closer to zero than the closest sum so far\n        if absolute value of (current_sum - 0) is less than absolute value of (closest_sum - 0):\n            # Update the closest sum and the closest elements\n            update closest_sum to current_sum\n            update closest_elements to a list containing array1[pointer1], array2[pointer2], and array3[pointer3]\n\n        # Move the pointer of the array with the smallest current element\n        if array1[pointer1] is less than array2[pointer2] and array1[pointer1] is less than array3[pointer3]:\n            increment pointer1 by 1\n        else if array2[pointer2] is less than array1[pointer1] and array2[pointer2] is less than array3[pointer3]:\n            increment pointer2 by 1\n        else:\n            increment pointer3 by 1\n\n    # Return the closest elements\n    return closest_elements",
    "938": "function sort_list_of_dictionaries(list_of_dictionaries, key_to_sort_by):\n    # Sort the list of dictionaries using the lambda function\n    sorted_list = sorted(list_of_dictionaries, key=lambda x: x[key_to_sort_by])\n\n    # Return the sorted list\n    return sorted_list",
    "939": "function heap_sort(array):\n    # Build a max heap from the array\n    build_max_heap(array)\n\n    # The last element in the array is the largest, so swap it with the first element\n    swap array[0] with array[array.length - 1]\n\n    # The heap size is reduced by one\n    heap_size = array.length - 1\n\n    # While the heap size is greater than 0\n    while heap_size > 0:\n        # Heapify the array\n        heapify(array, heap_size, 0)\n\n        # The last element in the array is the largest, so swap it with the first element\n        swap array[0] with array[heap_size - 1]\n\n        # Reduce the heap size by one\n        heap_size = heap_size - 1\n\n    # Return the sorted array\n    return array\n\nfunction build_max_heap(array):\n    # Get the index of the last non-leaf node\n    start_index = array.length // 2 - 1\n\n    # Loop from the last non-leaf node to the root node\n    for i from start_index down to 0:\n        # Heapify the array\n        heapify(array, array.length, i)\n\nfunction heapify(array, heap_size, index):\n    # Initialize largest as root\n    largest = index\n    left = 2 * index + 1\n    right = 2 * index + 2\n\n    # If left child is larger than root\n    if left < heap_size and array[left] > array[largest]:\n        largest = left\n\n    # If right child is larger than largest so far\n    if right < heap_size and array[right] > array[largest]:\n        largest = right\n\n    # If largest is not root\n    if largest != index:\n        # Swap the root with the largest\n        swap array[index] with array[largest]\n\n        # Heapify the affected sub-tree\n        heapify(array, heap_size, largest)",
    "940": "function count_elements_until_tuple(input_list):\n    # Create a variable to keep track of the count\n    create a variable named \"count\" and set it to 0\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # Check if the current element is a tuple\n        if element is a tuple:\n            # If it is, we're done counting, so return the count\n            return count\n        else:\n            # If it's not a tuple, increment the count\n            increment \"count\" by 1\n\n    # If we've checked all elements and found no tuples, return the count\n    return count",
    "941": "function check_list_element_presence(input_list, element_list):\n    # Loop through each element in the input list\n    for each element in input_list:\n        # Check if the element is in the element list\n        if element is in element_list:\n            # If it is, return True\n            return True\n\n    # If we've checked all elements and found no matches, return False\n    return False",
    "942": "function combine_sorted_lists(list1, list2):\n    # Import the heapq module\n    import heapq\n\n    # Combine the two lists\n    combined_list = list1 + list2\n\n    # Use the heapify function to turn the combined list into a heap\n    heapq.heapify(combined_list)\n\n    # Create an empty list to store the sorted result\n    sorted_list = []\n\n    # While there are elements in the heap\n    while combined_list:\n        # Use the heappop function to remove and return the smallest element from the heap\n        smallest_element = heapq.heappop(combined_list)\n\n        # Add the smallest element to the sorted list\n        add smallest_element to sorted_list\n\n    # Return the sorted list\n    return sorted_list",
    "943": "function separate_and_print_numbers(input_string):\n    # Create an empty list to store the numbers and their positions\n    create an empty list named \"numbers_and_positions\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is a number\n        if character is a number:\n            # If it is, add it to the list along with its position\n            add (character, position) to \"numbers_and_positions\"\n\n    # Print each number and its position\n    for each item in \"numbers_and_positions\":\n        print item\n\n    # Return the list of numbers and their positions\n    return \"numbers_and_positions\"",
    "944": "function convert_tuples_to_set(tuples):\n    # Create an empty set to store the converted set\n    create an empty set named \"converted_set\"\n\n    # Loop through each tuple in the input tuples\n    for each tuple in tuples:\n        # Convert each tuple to a set and add it to the converted_set\n        convert tuple to a set and add it to \"converted_set\"\n\n    # Return the converted_set\n    return converted_set",
    "945": "function find_most_common_elements(input_text):\n    # Create an empty dictionary to keep track of character counts\n    create an empty dictionary named \"character_counts\"\n\n    # Loop through each character in the input text\n    for each character in input_text:\n        # If the character is already in the dictionary, increment its count\n        if character is already in \"character_counts\":\n            increment the count for character in \"character_counts\"\n        else:\n            # If it's a new character, add it to the dictionary with a count of 1\n            add character to \"character_counts\" with a count of 1\n\n    # Find the character with the highest count\n    find the character with the highest count in \"character_counts\"\n\n    # Return the character and its count\n    return the character and its count",
    "946": "function find_length_of_shortest_word(input_string):\n    # Split the input string into words\n    split input_string into words\n\n    # Initialize the shortest_word_length to be the length of the first word\n    set shortest_word_length to be the length of the first word\n\n    # Loop through each word in the list of words\n    for each word in words:\n        # Check if the length of the current word is less than shortest_word_length\n        if the length of the current word is less than shortest_word_length:\n            # If it is, update shortest_word_length to be the length of the current word\n            update shortest_word_length to be the length of the current word\n\n    # Return the length of the shortest word\n    return shortest_word_length",
    "947": "function get_item_from_tuple(tuple, index):\n    # Check if the index is within the range of the tuple\n    if index is less than 0 or index is greater than or equal to the length of the tuple:\n        # If not, raise an error\n        raise an error \"Index out of range\"\n    else:\n        # If it is, return the item at the given index\n        return the item at index in tuple",
    "948": "function sort_tuple_list(tuple_list):\n    # Create an empty list to store the sums of the digits in each tuple\n    create an empty list named \"sums\"\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Calculate the sum of the digits in the tuple\n        calculate the sum of the digits in the tuple and store it in a variable named \"sum\"\n\n        # Add the sum to the list of sums\n        add \"sum\" to \"sums\"\n\n    # Create a new list to store the sorted tuple list\n    create an empty list named \"sorted_list\"\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Find the index of the tuple's sum in the list of sums\n        find the index of the tuple's sum in \"sums\" and store it in a variable named \"index\"\n\n        # Insert the tuple at the correct index in the sorted list\n        insert the tuple at the \"index\" position in \"sorted_list\"\n\n    # Return the sorted list\n    return \"sorted_list\"",
    "949": "function display_chinese_zodiac_sign(year):\n    # Create a list of chinese zodiac signs\n    create a list named \"chinese_zodiac_signs\" with the following signs:\n    \"Monkey\", \"Rooster\", \"Dog\", \"Pig\", \"Rat\", \"Ox\", \"Tiger\", \"Rabbit\", \"Dragon\", \"Snake\", \"Horse\", \"Sheep\"\n\n    # Calculate the index of the sign based on the year\n    calculate the index as (year - 4) mod 12\n\n    # Return the sign at the calculated index\n    return the sign at index in \"chinese_zodiac_signs\"",
    "950": "function find_max_similar_indices(list1, list2):\n    # Create an empty list to store the maximum values\n    create an empty list named \"max_values\"\n\n    # Loop through each index in the lists\n    for each index in range(0, length of list1):\n        # Get the values at the current index in both lists\n        get the value at index in list1 and store it in a variable named \"value1\"\n        get the value at index in list2 and store it in a variable named \"value2\"\n\n        # Compare the values and add the maximum to the list\n        if value1 > value2:\n            add value1 to \"max_values\"\n        else:\n            add value2 to \"max_values\"\n\n    # Return the list of maximum values\n    return \"max_values\"",
    "951": "function compute_ncr_mod_p(n, r, p):\n    # Create a list to store factorials\n    create a list named \"fact\" with size n+1 and initialize all elements to 0\n\n    # Compute factorials\n    for i from 0 to n:\n        if i is 0:\n            set fact[i] to 1\n        else:\n            set fact[i] to (i * fact[i-1]) mod p\n\n    # Compute ncr mod p\n    if r > n:\n        return 0\n    else:\n        return (fact[n] * (inverse(fact[r], p) * inverse(fact[n-r], p)) mod p)\n\nfunction inverse(a, p):\n    # Compute a^(p-2) mod p\n    return power(a, p-2, p)\n\nfunction power(x, y, p):\n    # Compute x^y mod p\n    res = 1\n    x = x % p\n    while y > 0:\n        if y is odd:\n            res = (res * x) % p\n        y = y // 2\n        x = (x * x) % p\n    return res",
    "952": "function find_min_subsets(input_list):\n    # Create an empty collection to keep track of subsets\n    create an empty collection named \"subsets\"\n\n    # Loop through each element in the input list\n    for each element in input_list:\n        # Check if we've come across this element before\n        if element is already in \"subsets\":\n            # If we have, this is the first repeated element, so return it\n            return element\n        else:\n            # If it's a new element, add it to our collection to remember it\n            add element to \"subsets\"\n\n    # If we've checked all elements and found no repeats, return a signal (like None or a message)\n    return None",
    "953": "function calculate_profit(cost_price, selling_price):\n    # Calculate the profit\n    profit = selling_price - cost_price\n\n    # Check if the profit is greater than zero\n    if profit > 0:\n        # If it is, return the profit\n        return profit\n    else:\n        # If it's not, return None\n        return None",
    "954": "function is_abundant(number):\n    # Create a variable to keep track of the sum of the divisors\n    create a variable named \"sum_of_divisors\" and set it to 0\n\n    # Loop through each number up to the input number\n    for each number from 1 to input_number:\n        # Check if the input number is a divisor of the current number\n        if input_number is divisible by number:\n            # If it is, add the number to the sum of divisors\n            add number to \"sum_of_divisors\"\n\n    # Check if the sum of divisors is greater than the input number\n    if \"sum_of_divisors\" is greater than input_number:\n        # If it is, the input number is abundant, so return True\n        return True\n    else:\n        # If it's not, the input number is not abundant, so return False\n        return False",
    "955": "function split_string_at_uppercase(input_string):\n    # Import the regex module\n    import regex\n\n    # Use the regex module to split the string at uppercase letters\n    split_string = regex.split('([A-Z][^A-Z]*)', input_string)\n\n    # Remove any empty strings from the list\n    split_string = [s for s in split_string if s]\n\n    # Return the split string\n    return split_string",
    "956": "function get_position_of_rightmost_set_bit(number):\n    # Initialize position to 0\n    initialize position to 0\n\n    # Loop until number becomes 0\n    while number is not 0:\n        # Check if the last bit is set\n        if last bit of number is set:\n            # If yes, return the current position\n            return position\n        else:\n            # If no, right shift the number and increment the position\n            right shift number by 1\n            increment position by 1\n\n    # If no set bit is found, return -1\n    return -1",
    "957": "function convert_to_roman(input_integer):\n    # Create a dictionary to map integers to their corresponding roman numerals\n    create a dictionary named \"roman_numerals\" with keys as integers and values as their corresponding roman numerals\n\n    # Initialize an empty string to store the result\n    create a string named \"result\" and initialize it as an empty string\n\n    # Loop through each key in the dictionary in descending order\n    for each key in the keys of \"roman_numerals\" in descending order:\n        # While the input integer is greater than or equal to the current key\n        while input_integer is greater than or equal to key:\n            # Subtract the key from the input integer\n            subtract key from input_integer\n\n            # Append the corresponding roman numeral to the result\n            append the value of \"roman_numerals\" at key to \"result\"\n\n    # Return the result\n    return \"result\"",
    "958": "function find_average(list_of_numbers):\n    # Initialize a variable to keep track of the sum of the numbers\n    create a variable named \"sum\" and set it to 0\n\n    # Initialize a variable to keep track of the count of the numbers\n    create a variable named \"count\" and set it to 0\n\n    # Loop through each number in the list\n    for each number in list_of_numbers:\n        # Add the number to the sum\n        add number to \"sum\"\n\n        # Increment the count\n        increment \"count\" by 1\n\n    # Calculate the average by dividing the sum by the count\n    calculate the average by dividing \"sum\" by \"count\"\n\n    # Return the average\n    return the average",
    "959": "function solve_tiling_problem(n):\n    # If n is 0 or 1, there is only one way to tile the floor\n    if n is 0 or n is 1:\n        return 1\n\n    # If n is 2, there are two ways to tile the floor\n    if n is 2:\n        return 2\n\n    # Initialize a list to store the number of ways to tile each floor size up to n\n    create a list named \"ways_to_tile\" with n+1 elements, all initialized to 0\n    set the first two elements of \"ways_to_tile\" to 1 and 2 respectively\n\n    # Calculate the number of ways to tile each floor size from 3 to n\n    for i from 3 to n:\n        ways_to_tile[i] = ways_to_tile[i-1] + ways_to_tile[i-2]\n\n    # Return the number of ways to tile the nth floor\n    return ways_to_tile[n]",
    "960": "function convert_roman_to_integer(roman_numeral):\n    # Create a dictionary to map roman numerals to their corresponding integers\n    create a dictionary named \"roman_to_integer\" with keys as roman numerals and values as their corresponding integers\n\n    # Initialize a variable to keep track of the total\n    set total to 0\n\n    # Loop through each character in the roman numeral\n    for each character in roman_numeral:\n        # Add the value of the current character to the total\n        add the value of character from \"roman_to_integer\" to total\n\n    # Return the total\n    return total",
    "961": "function sum_of_even_numbers(l, r):\n    # Initialize a variable to keep track of the sum\n    initialize a variable named \"sum\" to 0\n\n    # Loop through each number in the range from l to r\n    for each number in range from l to r:\n        # Check if the number is even\n        if number is even:\n            # If it is, add it to the sum\n            add number to \"sum\"\n\n    # Return the sum\n    return \"sum\"",
    "962": "function calculate_discriminant(a, b, c):\n    # Calculate the discriminant value\n    discriminant = (b^2) - (4*a*c)\n\n    # Return the discriminant value\n    return discriminant",
    "963": "function check_word_length(word):\n    # Get the length of the word\n    get the length of word\n\n    # Check if the length is even\n    if the length is divisible by 2:\n        # If it is, return True\n        return True\n    else:\n        # If it's not, return False\n        return False",
    "964": "function convert_camel_case_to_snake_case(input_string):\n    # Create an empty string to store the result\n    create an empty string named \"result\"\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # If the character is uppercase, add an underscore and the lowercase version of the character to the result\n        if character is uppercase:\n            add an underscore and the lowercase version of the character to \"result\"\n        else:\n            # If the character is not uppercase, just add it to the result\n            add the character to \"result\"\n\n    # Return the result\n    return \"result\"",
    "965": "function remove_empty_tuples(list_of_tuples):\n    # Create an empty list to store the tuples that are not empty\n    create an empty list named \"non_empty_tuples\"\n\n    # Loop through each tuple in the list of tuples\n    for each tuple in list_of_tuples:\n        # Check if the tuple is not empty\n        if tuple is not empty:\n            # If it's not empty, add it to our list of non-empty tuples\n            add tuple to \"non_empty_tuples\"\n\n    # Return the list of non-empty tuples\n    return \"non_empty_tuples\"",
    "966": "function find_first_repeated_character(input_string):\n    # Create a list of vowels\n    create a list named \"vowels\" with the elements 'a', 'e', 'i', 'o', 'u'\n\n    # Loop through each character in the input string\n    for each character in input_string:\n        # Check if the character is a vowel\n        if character is in \"vowels\":\n            # If it is, add it to our collection of vowels we've seen\n            add character to \"vowels_seen\"\n\n    # Check if we've seen all vowels\n    if \"vowels_seen\" contains all elements of \"vowels\":\n        # If we have, return True\n        return True\n    else:\n        # If we haven't, return False\n        return False",
    "967": "function find_maximum_value(function, start, end):\n    # Initialize max_value to negative infinity\n    set max_value to negative infinity\n\n    # Loop through each value in the range from start to end\n    for each value in range from start to end:\n        # Calculate the value of the function at this point\n        set function_value to function(value)\n\n        # If this function value is greater than max_value, update max_value\n        if function_value is greater than max_value:\n            set max_value to function_value\n\n    # Return the maximum value found\n    return max_value",
    "968": "function join_tuples(tuple_list):\n    # Create an empty dictionary to keep track of tuples we've seen\n    create an empty dictionary named \"seen_tuples\"\n\n    # Loop through each tuple in the tuple list\n    for each tuple in tuple_list:\n        # Check if we've come across this tuple before\n        if tuple[0] is already in \"seen_tuples\":\n            # If we have, append the second element of the tuple to the list of tuples we've seen\n            append tuple[1] to \"seen_tuples\"[tuple[0]]\n        else:\n            # If it's a new tuple, add it to our dictionary to remember it\n            add tuple to \"seen_tuples\"\n\n    # Convert the dictionary values to a list of tuples\n    convert \"seen_tuples\" values to a list of tuples\n\n    # Return the list of tuples\n    return the list of tuples",
    "969": "function find_minimum(num1, num2):\n    # Check if num1 is less than num2\n    if num1 is less than num2:\n        # If it is, return num1\n        return num1\n    else:\n        # If num1 is not less than num2, return num2\n        return num2",
    "970": "function find_max_segments(n, a, b, c):\n    # Initialize the count of segments to 0\n    count = 0\n\n    # Loop until n is less than the length of the segment\n    while n >= a:\n        n -= a\n        count += 1\n\n    # Loop until n is less than the length of the segment\n    while n >= b:\n        n -= b\n        count += 1\n\n    # Loop until n is less than the length of the segment\n    while n >= c:\n        n -= c\n        count += 1\n\n    # If n is still greater than 0, it means it's impossible to form segments of the given lengths\n    if n > 0:\n        return -1\n\n    # Return the count of segments\n    return count",
    "971": "function concatenate_tuples(tuple1, tuple2):\n    # Create a new tuple that is the concatenation of tuple1 and tuple2\n    create a new tuple named \"concatenated_tuple\"\n\n    # Add tuple1 to the concatenated_tuple\n    add tuple1 to \"concatenated_tuple\"\n\n    # Add tuple2 to the concatenated_tuple\n    add tuple2 to \"concatenated_tuple\"\n\n    # Return the concatenated_tuple\n    return \"concatenated_tuple\"",
    "972": "function left_rotate_string(input_string, rotation_count):\n    # Calculate the effective rotation count\n    effective_rotation_count = rotation_count % length of input_string\n\n    # If the effective rotation count is 0, return the original string\n    if effective_rotation_count is 0:\n        return input_string\n\n    # Create a new string that is the concatenation of the end of the original string and the start\n    new_string = substring from effective_rotation_count to end of input_string + substring from start to effective_rotation_count of input_string\n\n    # Return the new string\n    return new_string",
    "973": "function find_minimum_total_path_sum(triangle):\n    # Start from the bottom of the triangle\n    for each row in triangle in reverse order:\n        # For each number in the row, add the smaller of the two below it to it\n        for each number in row:\n            if the number below it exists:\n                add the smaller of the two below it to the number\n            else:\n                do nothing\n\n    # The top number in the triangle is the minimum total path sum\n    return the top number in the triangle"
}